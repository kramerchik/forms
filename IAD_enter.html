<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d203c286c1c0f840ee378095e6ee479f6acdc0d8fa2aae6b26f57b218c04af72536ade7013d23e69928c8c52215be495fad4b2e19a066a6b79a711389ae300c55e93d9c3b82846fd5d86cda57e33b050c4131cb23184f078521492a47ec826c63d79d67d038de17ba85bfd523f97f5a20425f4f98e1bb62f967ca3b642d42e6b8cbb2e97e58f77f5b389e6bce7881aebe51307ebc9d531c7775142c8086505b6ebdbbde5c5ac77ba00d68e065ba845f648dc873908918a5a0c5d2167a68588ccbd85a55e77a541a6465f72240fb9be75c61fca3a1a31fe1df470906883b9d1ce933850de516588ea9f54d2251b088cbc22202348ea4cee59f95fe152de7c14218e6a5cdb4ea6b2ff6c7e59207cd95f25c236f82d1eee21063ca7af5a935f39bb9401e22ae9d743bfefedf86d69a8411f1ac0a686aec544a9858520ca14fdf5d3350ffe49b3917e0e93f117607e3795c8c61dc5046c371094ff03125d010677c990ee5b64e62d0511c190c0ad7af60c4d6825c45a248795716e5e3f3d0a5c0bda9b07117d1e95f3f0c763012ebbc2e2fc6b4db0e9e2c20e483cb6a1f4260f35a5e39c84d80b49c9ec46214b23dcdb9b820e265ae5adbb1d31b24e247f9332ad25a62ac83cb7a796a1c17845dd875d46afbd28c85866648a7c12af55de45a1708ae1da9638ae06caf22253031b3984bcd98e8c7b76e0be68cb17a4f24f24fd6da99cebbf1c035a8938fb4d2cca2a90c19c75c5f91ced3fafa4905efa7f354eba274eaebde69c52e9219b42caf7d2e41ba5393e7c628d8bff5e441ca8a1b915a4d7f77c849b5c6a0137ccab78cfff824c35bd2a14a17d372860f79478ffc91463f25bf5aad9bab4519a92cfecb4f868c6a020d4da3d9bd561efbd49ab9ef99ba4bf45ecfb730cf0893bffca3703ba3a5dd879e1ebab72ed2569c28a025d3a519b10d6b75a8497cb25bc5d9022e751a29d3d3bd7b6804a24dbd60808c26b9d6fbed77410e251c89eefa34c34d558d770210e9d5db76bcb1694dfa4ff80df5a79b1218595431bd15e12e2fa1f9a6a63dfd85dac6f962ca3d42ec01dfd19cd4ebaaef42cf5aad53b72a829af5ff4588ba4de824971a7632f20d5332e54cc72fe11a80ea2ff717aefe605e9abdaf6acb1a8229d292edb0c3e9a57a64245a8fbebd564d183bb831fc64962435f2735cdd8e334eb7c7ee193d8fc469c1a67554309e28f305f391249d7adb82188c627b0dc563dcf1f8aafab6c3e21b9916a9b9a25d79176a31ebe0a82e7cb5e97888e6c5101b08901f48417581570a89f2292f1aade291750a55b5691d52f08389f4a223ffa3f61bfcfbee6b4ff3ebd985b2c218fcc457ce85e15c20131fd7404b5f1e8585fa46d355abc2dd18d763889df6552cfe8c3dafd6953b1f2c3babb701634a0567a5e206d1dd458bbf1042f03759547fb939573f640e9e698b93efbc92521885e7848852a6beed04dbef258987c14006f351f55abeead2db1723309b7d9fc37ffb84510c1d9c9ff20689cf5d678bdf8b9f3737e67b23bf55ee58f4f0971fe09a16a9f29e825fed5d41b69253fad6478cc47c7a3fe42136f095d5a0ed0f73dfed3a572603b2e0ea459fdabd09c97f0da88cf6d1c508113891a05204f822fa9cecbcbf609557ec9cbe82a51d47f105cc8f2adf90ff8e8b496ad5a1f4c00f863e851a701ec2c28a8904d5f15c297b0d198b285a58537cf713690b8ad5c0dbb6fa101b74bf1881e41784c741ee3faa291ed0cc645a8685ba24a237ae06d0d28d00722481c256419241b25816aa5c5de026c4be77f0896b39330e0746096fb72fc4e9d319ab91398603e68d6298d4c603d97d74227111f3623223e659cce1340356cf715bf01e7bf4ce5047cfe39b94693cb72673f486e3e286169ef0fb5493780262105f95f3d143d9801b2722773ebe4839d2ab9e4df47b953906c4d7ebe9cdf35ee4c833bf8ab13f39753a2cf6418f72b1a6f524797769b93c61ff9bdc53f038752738cda9486eaa50b8510fcc4e3067f6e51a8638e9e4eda0387fabfcd5f9be3f9b55a9118f2f3cdb635aa91b1d4b0787401b81cfa6aed15cf4bd0d0fd8fe1db7c65fa770a8170e1f48b66729fdaae73559eba8a4d952315dc3e311e0c4b2dc2932ad293f7ba2433cdb61f022f8e8b2f8bf1ec34111163e4b5efc49ff04c65fdcc5251f9f799ef60c76853af17376e3524ad84cdd4ac3c0b9b8dffc4621debf7b4038fff3ce9f9927f6a2666149d99843d0c0952995ddc94c423567e967b6cb871ee5388907d1b080cf514170df5af3ecff6a279d35b911f7ad4b096f6c0f06dfa761d64adefb68c2319b1db06935d11226d1cb6e2d1d230ae3242f884e714b8efbb54036133ceb9edbf2535bf63743e753db1a63f4794576a516386bd1514edd2beb07a480956dbd7b15580908b9619afa5b44f118accaf16551e92df5c533b2530e904ab85efd4c5b65b2f684ef6796a3b19dc6a3ea75f02992a2ead72dacdb829b49abcb922ae4a443d50f386f4b2a9fc6ffbb2773d1daf3d74b83676913a7a6b9c937397dcc252a411a886d49b50af3ac3846f6f55fb6a3bbe0d095c6f460107d91e51242905e4eed366a3ee2f331923069ac4496da4ed9748890c1edb00f3ae838830f3363c8ba8c51f02bb32fbd416c57167006ab909d78b341601e47efa22d4fb6216563a38e8ec1415c1f6a7d1bacd19f4dc669eddc997b94219526c2b4aad811a0bad2258ff763770f28c2243965c3f77928ac6c19c381c4a101eb81ea8b01a314904efc9d04c66b19c15cadcef3d963d3a2638b9a2e6f82d7c838daa862ef19f87f390caaf7d89770e19344047c059bd49bf1aa5426454f7f669b53566fa590a4c8b402dd4b58276da4e77f3534d4fcbc095d942ee877b8450a487b988f64ba4a9bff144e94267da905e7d546d7e7e515ec2d77003e2ae39122246399aec239b295971b334af17ac0e50a1a4e4dd21547d399901198892556d0cf1a60811d05da079fdca24260534a35e144c353ba749c94b9d25bcd60935cffe3ccac9977a5b7cbacb4580099dc03b77da359bcae40cbc10d9ba46994e17fd2459a901dc5ef26adb273cf5b150fd918b053a6c63af4cbc8feb97ceab1be7de64d87037be38b1c59315c31955da99d158b02395f02e7ba549681692d007184794809f8294f3972d39eebf3df7847054c9918f9f787904ea1bc60ed2c57fe49fa52032182de2890c565df4c41fddb1ce68ce54186be4cd560ce293857dee7d50a69c1a31e68ec54c23dac946eb7c86afad2e8d7d94da8c8388e451ac499ab7980b0eb17bdabcf8ccf74b0f7576e0ceefefc8a18d24b2a6d6a0dc6d3744df177c14bef266e7b60c3afbb18c7b69063489bfba87661fb4313906c9b417a55d48139c309e81f6fda0bd9c42315acc25e4698151f5521a689cfb21668f6e9e6dffaeb7762b0b72747d6ac74c6fb944d38bf49c48f445acb6d6ea515db4623994e84edc0c82f2ecca050b878c3c6d3badec4abe2ebe52771a69194820fee0b455eead5a041ec01e21c39dc525b732fda6e01e98ae1c160b4dd3d35200422584837dd12c8863a9ae1abb87ef4890fe9078c7f75c1ae07838d1e7e99fca61638a95077f7b8e6adea2cf26a52f1dce91269aff1531a7e17eb04bd91207d8137a68b98537eee358550bc9cfb8644cd168c884d731ceba9a4f9738f52f4375dab562e17777a1851f526088e005a40307e989e7678bdb275833d66e1c538f7190af4ebdaa6f3f932b0598382e767474c6599b1a45bec97bbc6c8e3935bce0d3b9e12b78a15214a2d46df32676bc37c2406ad6f109f5e21583d2cbbf1d54062918daa9a54bc5150510f997abe84c140cffe4c5ef0fe5f9f9d550da09948a15a6f368a9370f9ceb942f62f9b61f21399d0a1305ff12fbc6e7fb74bd040b2c0362e8a45c045700c4f5c8913553dbeb7da34662c5080c955a1f3f5007fe2c2bb6e63ceece759a40b48780ea9aba5f8cda84f516d74dcedaaf3414ba87c0d97c43c7b63ec0ab91d3444f892cc8b304bfd292f9bf069da65f26994fb9d1b00e3998366094fc1a3f7f53c36b73e6cdd6d721855e34838c3f188247959f610700c0eb4fe184ad17e48556795e74930d4b3c39a2d00c5aa8223a55495b33d0c3982811cb27b1652346503d353b2d555cf11afca5dde44eaecfef188266ab306dc3c7228b357e740d515cb167ce3016a425baef66cd346e3cabd912e3e09e5338df33cc642071295915783fb46142d8a188125a2f960489bbb69f93cd226440655473d3325021b3303e09fb1d87fd52c4e365a96bb39fd751223eed86a4a776fb50cdd192dccc622ebde87ba8620e19f5d89bd576ed81601f4f00bcecbe469b2665fc9026f538fffc583b1fb6bff7e9a43f1c15b07267e1594e9dd9fe64900cf6cc37718fafe5b6c33794fac8d3ff9b97554241ae688ecf2bb6e5d95e4a5a7aa7fa2df5aa0701c2f6c7ecdee468485127ea1ada91b075658ea7dfa765f3847185ecc79576e5238b9f737aabcfde9520ec0a35267e1eefef4cb7d8d8a498f00a86160bc71ca0a908a7d0f724efc356fa9bac4cca4a4101317ef89cbe41b3fece594bf69d63b6f0b2d75e06ad01a57abd5b9545d24ade37d398934695d8c01f94e8a2351348259a375e4c8a17e5a0494fccf6d18ad87c64b8a87a5841ce35d2e1238ef6aa1d5a398e843424d2d5c5c8b8969e94d64b294caa58e1ece8647875cf9bd4e5fc7994a448acd2c201678c23afe2896c0e0b7e1214d307dd17a6bf814f6f7984c19ea733ec9bd70de023f5abf8d87e84c6aada9220bfd2a8486dd1ca8447aec11378b19752ee600959d81815689fdce8aea23cdfcc4156d49ebbb85f886e310247cac74ee5e842d32a567d0dfeabc709a9998ca3e8e2146d47d55adcc38e3395bc08c632e564c4839fb30cd337b3100e2c3ed28c1df51388281832c13f6624a67893948fb330d3283825a43088162b126e5f701417de7ab8d4cf1e53b988d1a6fa5f469c91306083bad189c1783ebc0c1b72d313e872a15be3113a13d16db9f5e8ae588d8c0efff4a970ff5646287a735c5bf4e762735dc94842745903dc74722efaf3749e2a97bb2c5b3921b3a691270a427c73f151d6ec4d7daa767efdbcc806f2f2c0e99043058b613657bf9847d6d9d4a0cc06c085e07b4aab4f62eca10491536bb07742e9b2acd14d5862e48e068be9cee356fa383bf0976bb0649e49e286ab7e0dc51512ae51f2ed9e1e3e60012aa7ba2e080040035860b265d0c1ae4a731a2f1e0e73d343b18f633640c37e3f93d013afc119283fb4fa15e44bdcca031eb636ff70796cf1db229075131515c4c70185feb64e4520c068aebd2cbc9d94b0b8c44d77034f4f0a211d5fe1462b6f49b15228b03b18720b1359e25b9b5ba321b102aac45831b2295f9d387de36176f73da74fb3e61918eef846a7403d35de30889c7a0bc95d741f5774e91456d8989d31a7588ed740f68653532477e3cd4003dde50f2951d9a63b7c01ac9446008eae9d325f85bd9dbbf1b756496a35b6dfefbee6f8100ce75743ae1b08c1d2e8f876e424889d29a7709a4cc5b04e18f1843ddc1846b1e3cbdbf6b7cae7ba7601486513a4bd4bc85a4750a6b6579134de4dceaecb4b2f428d6c0c4ac63010c2585e13ef2620f65ba68fbe70c5fda1b6f922b4742ac63eee464075f77235cdf5ebd8f8682a45d363f3935091c393921715029e4f6ecac72a23785c267ac3fa815a1a59c558ee6b0f449c756936d017b5202a130df13faeb25053f2cbe808f4693bf9002ea944edb034f98afaf93d0fe1e08a9d26879c45d9868741d71db4770c20dc6450f14eaf738ab0712de0502097f851f7d92f6f75344986b919a552cf587235e73eff3c11acc71ce6d211de64bc9833fbe8919082708ce77707f7ede3ba0b508b1fd416cc85af1ef79cea8316486148a151928aabbda63e9f221cd101d37f094d13e897279fb8842539ff70437c598b1e85f992354001973f93b215a50a67aa26fe72623a70fb1eb33b65b2aa4eb99c5fb87aa786aca8bbeb209f88b9d98ef5dbdae03481065cbe241c8962732d2574b868113d06b399b37538306658eb47d4e2daff36517a5d670b607ed7cd2044a28eb8fdcef8c4637eb8e9e7e4d19051cd897a43f5785fbccacecd4ad0f040fc370ea1a6dcc07cfb54cf02485e697e37a5ee3310b01e47d64a7f184620bfc782e1ad056885a238e3752f34c8175a8582b8bdf0fb4e2590c62780c6c54592316c9b838c6d6c55a211e2c5e97b1b0c9b7e69559474da2001d5f3fcfb1537b3a72613ba021e183143103f814b1df20d3ae7ce76d6ffbee1716cde41db9bf8ab9781938963ae8bb0079a58bb78c4f8179fb34a5fc45a8997ea471e49e71089e14530ccf70fdcc5d7d1c6364ec9bad2cb8f134c59c861f07331fab113d9fd401962f384bd8231f707e0848ac5d981eb23f3fbcb298f27afab5f6827128fcc6efad4ea38c4202bd415e87766929f706c2881f68c4519cefc6808434e97597b8592b11aa5eb9c38360e1df9694d0ddbdf37e07c623356864f9267aa7d704161d3722c6181988bdeb86fd8584c0afbf293357b3159e0f3289db1a230dd9b4e897ee01b22ab0c3eb3f4c3c1a9edd8599d131aac868ce49a82b788530ddcd3a15de1c6e71d0098e1d917d467337b7937b8f0c80d32e0e7a6864f9cf452c739915cc2439eca27246f6cc56145101fe4323eabed9b39a2406a9f48191a46a66f0d27c26133dd40c77406d5c3dbdcba11cf04d4672e1476573e1755ed5e205a52a370594f08236e566abc70575fe6e98115c7343a87e2f980630e7047146e8cd8173eacc0a48ef28d7506256b2d9bb31e2951d8be66f6355e22d9802606c8fff9b0791e939613602970926c47dfb90928e35124b167b120bc79406003d340a01dd8a76d35a0c57d52604a92b53f2e3fd6a11609fe50ac0b37764516881676298296db32da209db9696227cdfe7d98bbbe8595f6644be67d99aaa7ec1c54807987dcb71e289d669baf943a5761ea27f6538a69e41003711cd6324e125a8cf5313d03c1d23eff45dae3aafd6fdf1c4b44f47760ce525ebda505f580e0d37296bad6f7cc655c657f6f098c2c475095a9e1fed130753aface438756abbd7d664cb27cb45eb3467793c03e801b2b11838d01da33ef8df9dc65ae0c416662f24fc5d0dc5b9fbd1a8a852e2901e1495f09d3e33bcb426db17e585e3a9b60da9679c55ec622d52ab972182e0e76805586098828b8403492de4ef574895497d55ba837e64689764ce994b7a438b54a34d6f2324f2b888e52acf24df1e4d7bf8b9fe5cd54efd2560787d099ef32323a59c05a88c012b6b1b2a025c6191f6b37859a22a37d60fb6262b115bc65a87f71f94aef17420cb964057216e589f4e0cb786e4fccea94ec91f253361c8d98d075ca6fb0b7b7eeb78315c55c3120e30a92c06c11c913ad75f4a5c1ad6a83e229066d5344607f9ebc58a40c79f6330193dfb171e4a8e9b79ab4eb016d55de147092e951dadfa5689531256f2444739e2e797fafa1e12baf14c63f5d83e30941e387f92e7ec0a024d63692a539bc024ad38d8586050d587e066b600b776bbf75e0ff5887bb7d8728e521c287bb4f8cc7626c0800f836a5c8161902564ce1c188bd9dc3f052be44869b1330068a0e9f02d853e30309dcd0a3ccda3cdbdf0002e297fbf75f5204585e5f1d90e4e533c0650a0cd3d6247d403f2d18f3c3f4cf420e69c07da69dd555d311f79a16251599e0ff98051372f202a06f134fa9db5a229077b2a31e6e7674ba71a1e1a19fa8d51385962354f15fa196cf9028ae517366d6a9314d8c9e94988b4c61ef3c27e95b87c398c51ec99bb554b8d90cfbbf7007a4a02c7e8c296997ed47e882112b4b884527ec007c7037739714bd90dee6f26fddf050303d7a0824d7e743d6fa08ec25f55e4f38f1caea1818cb6cdd78e6acb13f0078f411dfa9345f827aee51fd515f3b564b3e01b3f007d2ddb16409240fbdeb37df58a7274518bfb8b7f69ce7e9f1445d6d187fbb7356d79a338ebf469092ce1f41e656ff94c0bf7cb752b15ff8a11e0310a094ff6bf6d83568f9026794c265f43ce3e9a3fefb3165c79c74824ed93a0ce8246ba9757e077095bb1623ba9cde63cd3188709c0b728be53ccba5596e91930ac83a8173b9a726e00f1e269186e0e643c4c4ee8cc1e965ae33c71c5acfa36d2731922c5bdfa4010ba536d13f058aa9df06bdc5ebdf1f24d07794bd33abd8a5264ca9d16c3571c5378d10c1e85c40e4a4cc18d5c1c9a0f4c9c0ca0791de50a5bfafae749e0864678a6b1a807c11dc7868252d810301884ffb450ee910582e97f60a3500fe6703f939c2cd757ac7223d3513a1ab430c1f9f4a780a86031b4b9ded0e9368ac4354867a2698a2fb56c08a2239f0b41322af63b36ec214d745eb3fa8699b6145bfc8a46fb49b45b28c5d89e1ebf816d919f06ada409f9668abcb58a42ef87238976d1678cc19114deb6e3853dc0fcacdc6dc98121b157a359cdc8f14803245f1d94bf6ea0a2c5fe5f362b4b5aae3613d196eb401bc7fbc5a05fb425c996114d811c4c5725b3b5265d92eb084f6f784f83e3a001f206c32a311b91c01b7e6b27fa5c33214abb6bd9fbfe89229e5b28d3d296ee52fc4a9b271fbd47410c8737d9d558df886aa6408bad075e06c4b849f8314c86fa036fbb5cba564c8681636a80228003967bd384ed6a2f6746d75247050f907ea4a6925da2866ab2f59bab3d4dde3a2ed7e5c0a040796e0b7c57173dc515517c9fbb59767ffded2da3d370263a752b07670f26e2725080d0f26251b8aae52d608fdaca1a2f42baa22fc3047f7b10ee8fa05a2b24edd1f76e0da27b548baf4d4c61e1e005e2a93728e88e63dedf9a1238de98cb7b32e4e16995fb4f2bb1f6cd959a4f555a74dfe79030444681683236d338f1babbfbeee7dc7fb22a65f1d45874d9b28de4d44e7e13a0f3d7b3b6c110d635e099047df7db992f2f1816c00ef4731a07e71e58c1ded448d284e72f184509f7cad3f940267bf92b18325d1f2df43e45430b500470325c832ff318aa9dc599e0b90beb1a06f31636c3036947c183616275852b8295cc6d0d47032619f24d2db6ebb19be525796a1b280503ad6132392c2c7b27a9088f6d7793982abbaa87574109285948eadbd2a9a34bafd573dc973d8a4ff337ffaaf4731f59858c200eda2fcfe8d872659d724fce5161d5fc52c8938e534e75564159875a7f0b545a06a1fcfb1da8f27f72a1e1c5731ac33fff4589714a746a225b5919c489f4cef2e1b43ec066e008f531039dbb886ef3883c939e2d87ea90d9a55c37c50307b620c7a3ff102afe1fbf4f62e70ebf6d74b4440877e6bb32dd4b1f136df79c663360dfad4fa0ca06174fd88a614f0064030420b878d916b5dd0e9a8d44c4f3be381eb198f6ae9cfe7600fca6bf370460a607ca1f26f117f3de9d11d9d75e98ff2fbaad82706a84a2281a76f8c7ec115df86d71874082fd8d83aa4d152b390a536d4052bd46cd734c9affab1d1d31efaeb488c21a0866dd5087c929082b45857f8b055ffcc4133c0c37bf2b14eecf8d512c41219c419ed0624164d8b63a26714af83280e2f393672eedd3647f1f26491d6afb90cce612a5af411e1ba197cbf015d06c7d21b4abe7b37b8be7fb069d2965f8813d53f657aa77dd34f0167371f98dd76bfe20cd62ac10ac341478a85eabdfc2dafb5f2cf243bb4858038de847b5540050cc5fb644e81650cbc18e863f3ca52691947364faf10b9754b5235f20706be7ea7a4aa48e17f52a453e9b58692b46efd519db185071147bcae59ab9f32f6a06f81751a5a91aa59f7e09e99946b681c2d032144511dd95c0900084a76cb48902893226c7c3edaec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
