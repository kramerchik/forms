<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>


    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Неверный пароль!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dcbc2ffd1c01541aa81f72d7f081e47be102e31dbd23520279348cad9826be294474b010fd37d503457938c7e9f9a93c8ab4759fe36fd40e71193236ffc439c80e14abc7fd86fa41f83d888608f2dcf7647ab106e8121c08b878601776ecae11e563b5be485604d09dc27630ab83cefc00f86a35de0075a14d6874f40b5a38faee2d7e8ef68002565752cbc4dfaaeebb0420e174a9e28392fad20e59c4f6353efd376c9191af10e8f1bdeded4251da3917a49c3b516fe4bc530bf750ddf22f828de0031426d2431043beef659dd01693486c7e79f5c17fd967c519212c104faece27aaed73a640f7e23ef776eb65336e049b114eb29f77dbc3fdd72e04346fa92ab52a271fabf8d811202dbda3fac46b6c9a0b7e7c015dae81eb662c1f1b64c8d4f12a4813382bd3ea2dcac30105f9ef4b159d1481062a6861acb5ce66f99fee932cd2fef28cbad9a70e92a7aeeb6f62769706d5cab17a776f26134872336af7165401cc96f0fbaa1bc63332366adcd30f3d21187806fb56e03554760e0ddeb16614b7b39c5ad3c6167b251f98182b7286905b40279095452cf93804bf482e4c5b7df3ca771fa64f85d3314b9facfa118f31f5a3caecddf01aa0e4c1c97748470a0759fcc0de44e8defc4c02900b241deeee87c5fbcc280fdb2c949f143a8df79a491c89b5c718b26f1e2185d32e19ed51b0a962c1359a68da8c2f55041c03b7e3cf56cca828238d1fc76d42950f8c48266faa4b690c5485163509f47416cbadfd4fdb97f7ac013f8939382715434a0acf7106b539a45984ea51052d15079e085b60f624e74b140285ebd77f00be6e9db45a5ed07b064a82baed7f6705c9ed8bca4dbd4ebe3167242bf730ac779e5261ddb808505d56ce6c07f20754f049787305de7e183ef4c7d111daa818aeec662d89e68d2a59e64b74bff11f7ec13c8df5fa7c710eea400cb58e12e776cb253f5fdacf22734b38dcb4d4261856d1c68a2d9e9d47d38fd6e41b9aad0d217e3eda23e86fcf12d536829c71c4cb0febd2327bfef1240c28d18b1ff50fa1140c7887edfa4dc0ced634b09c649dcd78f5d05d37eee5b9ffa7a454698bf16d99dab9afb45e04354a1643dfd58a749b1b046a8652267d3b510e9ded2b4885adf66c2346fa154cd155be2014b89a40cf05c677d56d4426a12ce1c027f24f06bd78febf279fd1dfdfd2dad0b3aaf707ed5918ee8fcb8f70e9e8a8f1388083a50b01d4fa6a0b48367e3fc5a4f390ae600e3acdb32615ce07d8cd35dba9ae22cbe677ddc02729d7a19f9d81885b1bbf1692c87aa761d9a572a23bc4f9fc3291c346319ab234cac0c11c31bed83836c16c55a317faac29d3d3b2ad461d648a565aeb23d03bf9b8ba5ca85fd8f1f40c0431e4b032e2a34d46cb25213b19110e65c512895d14abc9b78bb86ddded7fdf630b50d1736bbf66218cd5a1c6fd36195300ac310a784cdbf9ce3ee30ff690d3d1e8daffdc919d89d3ba71c0a06ff1410e43d1205eed99d997f9e5f44a51a6628bfa77a461d4c82a1bdb5248670e93dd0a2ab275fc2be7d560de3e46209684bd227e960438642290d4d06c1d84e68574127c02459a9464e4b2bd50afd128fcb20accf58d70bfe261d260c6e0dc3a021927eefe889e3f9b4edd518bf5ff98b40c24640b307f83a870a37c42e4d4e6b50752d6ca8503f0e790a4e37e7189a74a3d87c657200f86f05886d89bbe1cf731b971a01014f20e208f2f204e66715007481f14a822105b0adfe9872ee154c0f8d13871f4ea0954456e2cf694ef605379e78aaabcc9f1cdb5e3bd8ef3fad60ba0dc559a423384ebe27f9db587686455a53686b34c40a86322e137c262eafce4406f0c60c41c90dbfa43ad0b2d4d281d547d12884f98386193bc9fb28d5aabc9cc8d5fc3a3a668ef027dea347c401505bae9d97b4cdeee793d672778f1082a431ed91be2fd8f8dedc7a51b1c1aae8178fd62146c2c9f53ac70c962b242b7ae4550cc6d946ded201985ab2f8ab7113b5a4e010ebf65147901561c9b2641def9d13eefa51dc1c601890c40193a2c549750ced348c33e7524077405895c566dfe705fb3bba813d7ce9a4c2e776ac12948359db1c96b741f97ffb2d4ff127717da3f899759c7a4a4173e6dd76eb7bca3ec70b2fe8fd5b6ff2ea1190bd6dbbfc630768868e55b5c4ecef63606746eabf2222b41b8162ca9f8f07b1eb9e650e4951a0f6cbbe30d3e9ffa490ace7c95f8aad1924f865883be8a99af09cc4a0f5f39f3abc6ba73dab5f7b58ed88e392349f6cfa8c9389cce9c95b5845da4d47f4ae82687ca134a9a514721bf1f68a949a1787709f2a333d3c29c98c4f12dadb2574fb3b8546e99a73b67a54f0afd879f6c9368de253492fb204d213acba76266056f9b1c697c1dfff4ecf98527ec0283dc09a8362d1a3696f2041ec9b1f700b307321e9a9175fec98f869cf44764e43bde74d669ac02c0710b1eff09dec8b5b775989698aef4ff467fe0a414fcf2af6202a905107be8df7a5c2566db4ff22c0828b6e50176b0609cdbb0c1bd2f0ffaa0d825bbba1db191de1a3f20af5b97e898bbd63b438bf689540e38529e276e6010192bddee8ca69c199d52ea4a7f5541485e9f4e07271347e5238a45ca86f69e54e8db447f7c7147c388ccccfed0eb4ea939dc5d69ec8e6efc1b2c9fb8be814807cd73d973e97ca4d68cd8be4fd5a880f4815faa111a5158f78e7953d50995cf2a4ce4a999c9eabcdaeb44668c85a7eaeb02d353dc51336753c41f2243c54f34dea6b28c9ab4ebb08ae8a91b2a47be2d89838f3c6af910460c048fd377903c75ab431652659c5d7e18bb1968c98e45c1a7bdc16744a660c14df5f45f3e69334c5f940a10d33bb93335cbe99e2ac5b86a9d6ca69530b4d42edbc825dc01b072be45f11dd1fcf2a8f3710ffbd88e4b59b4a62e1471c9684c45b2ca38aef63a3e8cc9838e271cd3797fc7907c2b872d2926c64a2cd40ee135e10434de368c19ff66f80342e16b3b960557e825aa61f4321cc3ae7ab2fcf6cd138ebeb48cb73c4f9560d613ecf3b926420c6a5b456bbb906d2d6787d1858aa14e12c3c590d0681ac93c397e45c23c35bde2e41069af7d86135562f2d0d2504488036ab6bd099d437f9c88f3e26a46add765e655c42fe56a94d9169f5b2577be2b24c97480b1fe715e14816a5d4275624fde662e14f2eb91fcb9946b9371ee95b945a34cb7cd14f4783629dc74ad5744bdf0ee67872cc660450f84d1bd7616c2be8419a5af26fb3a2d2b77d75d2965ab39fa0ff6286010d1cb5903f46af48ff611f33cf006a96402ced6caa0afc0748707f5e2f48057fe70c4e32f8a40516ff19bab196b6b36ab54628cb42e490505598304de5dae8d83b1d034a350b73fb61e571744b01fa8ab08784b314d09126c46be5e2c9392b9fd1fea6e227c503fce503910bd41e7b667033fe78bac7f53b02ecc51213660894427f768fa44d06d71b981e2eae26ec4c450415bde0acc652c93064da204cd29a8e50dab431e6ba6e50cfdcbd5d02a52c4cff13d271a1efafcf806f6ba6186921600602fa3c3c407efec0dcebbd0cb466bfef85fdc715306509f376d02a8dc278e7637d32c9e51702c59a2f323010ed91dc0c0a4ed29002598b2dc1f5ae5ee9acb186dde224b72572562ada8690156d9033c0e64dd7e4dd1f44e346f75858db5331e86bb0745d2530209b27977264f1b050ad1886fabae3e4d505c0a81490ba972c73951365d2824304f6e72634a410d1a9b7b0584f794a5c485aa90c75c4e836c0141c75dc38e25239010f37e01ae99ddf03f86f9781ca794b64ef08d223914f2f99c426abdbadbd84b7a229c700b19579caa7f60ea9d35968710e92b4c4bcf77d03b4b707687e823ea819cc8caa464c10c5bb86f72189f67d9dbfdd5d6b2587ae369587c7df85c6101aad4e33bad958839abc96ec9ebc31e11e083ed1932b5dfd7222a16d28c4c6ab8b8cd6e545697d04a3b3b2f484d199f3a2c948f20d7a7ee7673785e0ad0cfbeaabd0c4f7a509f5fd0d00ca9501db8fda97a6a5eaa8b1c8829aff3eecb19d901b78138685aba185cd773a070f360c9f0fec9b1c7838b90823669f4781271d11569fc49d74bb47de7839facaef60bee886c8e4d863bd31e1e1bb1cf91951fffb490080218aa29b6cb24780278e706099397f16ca0b7088e050fb11e2c6016d0e7fdec605f96b8f6381f2d6857e1619f78b57b4db37a807cb0f34282ca264a81b43df03394cc11d9750686533fcc9ae4e641b5b79a0dee6e5c6d367b86c417b2974c34d2b034500caf84a2fa1786e042ffb95c4eb9e03b3f0773e497596062a80c73f31440786cab1de35de8bfe2215355b79d722deded5ca3aa8e31802599708301a48e0facd0713f7f8fbffb6272e1bb1c60756a245c2f2611f297ffd21e5a69ebe567311cfc9c569a57bf0342d49fae39e4cc2865f697fb5c8853bb5ab7ec16e4c032c43431e4d6830ad88db615fab5b268bdefff2d95b3965b497c5d26d91f058581f04501247d4e82d96605c7308fcc9c6a1ce5ef0e2c0d1b339c22aedf38c9f7fc8af046e61a5ee0806dca22a14ab2a8ab422410808558c513b533a9f4290093d271eca24a12e3becc66e6180650bfa8f1fce81d0052b5f6c8de359019dfd3360eb07f48191037185bae227fcfdb95643930cc68d1426d7663042f3ea995d834fd97a917ee4e3207c022add0715a3f47999861ae82c88a81a8fe043ab8cc9233f40d81480cd2ecd7eb0766d96cab875c8af37d4087945a1ce047ec3b69a7caecd0c7bba926d6d7e41fac0c3af48e5adcd9284859ac9542b4e9756421054010cb88ea69febd0c7e8395444627170ae0b75838c84a20f383a967ee9fc932ce58fe342cc5f8153e10866d7b5e7842e01046b08ab64fa7953f992f4a0e09a1743f6965ab6b7cd4b875454bc75e9d18d286f8f4121314903a832099115282cbe93b72358d9b36d91c91a1b1503796f1590f9ba1cbd89bf2e3709b3cbd82a3c22ff2c0838b10d31fc6336f8e61bf6b6422f4f6ea9cb16d838110c60629dc02dae667f3a87a6dd06caf416e149de77978ca288de01cf930765a1d03b6d1e2f6a1deeab8f5ac8bfe1e763de325463a43fbb7108e51326fac32679067794e938d44ce344310dfb743cf9ad3de0ab457459a3dad9c32fbd990f1a24a8bcd99be5a5cfdf6b16f97cc8f38ae5c3a6ecdc1f73854fee20ec0ddd376d23a01a0d4f254623a4f09754685bc1ddf8ffa75d598fcae0195e3ae3f62a8d03d8dfe1c864bdbda40d0d963a2fee7947fe3e07d22fa0f9c0bed79ce490cc0ec1eff43ddc18199a721566b06a7f7d7b7968d218c8d8e13c3c110b6789836666871df3348d8f5b2d9106e15fede2bcb92bbfa79b4c68614a2c47e798250cae1ee3bf5c6bac7348ecfccc36f7669d743d15dbe9e8d52a8c4bb191d25322d5469ef3492d0cdc9379fa4634d6d7aa06ab8485ed341fc65bf0919650f5fb52bb75de3d297135ea7e89a559d86efc1d02bea10aa14dfc6e0618d6bac70fda6817b4d837074c982050397d4aa8d877b168c42d67c22fea6964d5d710868aeeab906a00bfa86e1067a2d4d8510b0d4d9c12fc8b34a2b8ede333cf2e1b266a499310222a07cb2ed8938264f0439a2bf0b9238bc12cb28d5680b9c3c351266a495ca097d22b429071c2a89e37cb9ce542465211a4e1a24b61d8a2a908ad5e70e14bc169118944d1741935fc16f59e35e35d8b0e1240bddb389cdba9adcc5514c75da0d5d34b6002eb2ef03cdca64951786bc63de94c6477efdfd716732eadce38130cab68b52cc7fdfca43bf8be3a0f47f5b2c260265ce9e58c5e60ef90084763fec64b6ccaf13e77a6037ec2d50f1011801c75ee191f99cea4650ca004f2d59ab605f9b3e11b81c37ae852f000c0c9ceed130d3285e205ab9b92071ba2de0dbfe9759a604f6179ed75e04d83c0e5288fd49e6a6237be1c19314987fd6bcff06c21c2fb748b0fce19255fb3b071435fa125eb850bcfb23d8db0e6ad8ce09048771386d724065925aa3c42fe32d8f44a98f5bc104a75c967a4b2e0bddb3f67048fc94e6616667dce482f8a80c7e02e77260d357bc0cbde096e8674b357612fd9b402227fa326f5555251235223d2b5b09abedafa2b37a8fbdb84a086cd5771dfc92ec28582ff1bcec0931d6b08dc516c33c9a89f93e8b9ba0424020fdfa6f21fff33edaad77bb6ed238eabefdf7f059bad6c34d4c08f93bd62bfee84693914325a5e9de720523c00a6bca86adea820da9581d8878634e5d4b2ec6e4c6c5fc8c9bde9b74ddef0885b8868f5da3cc9947ccae366bd9d389d0ca97de161db47ecb3eb438f43eeacc811d8442508b90a38966d6e65c5dca41feed6832ebc5401ea04aedd14bc3318c8f13c213118a47a3e014d09546ee04a8b9e63f2ec88d493da1013a3dee64fc41cac5dc23b3364379aa6ce6c0a9b8e5645d18c485580185db5a3c6d21655166eafe5578aa76010f84415be6e09afac3de4291c74afb83ced3c88b76fad4261085f510b7a50f0c30e2bb166cdd7eef39c1b29ad86ca73bcdee4a5a3d9bd62c75ef2f1a5adf9f342871a288c70a247d12fe6bf1bb39de9a501509996deeee6ed9b3fcd29766d724e31d65d407d9a6dad1f40ed638b706fef92071568740eee6621631e4f79316447e90347d05f7891ea73ad08301588d792fea6b06c652960c5c419a0db88abd3ef1360f2e9aaf7628ef1ad84f17e0082438677c193fe69a4eea0817f76b3bcade76c3b592b86c27f4035b8953dd8717308a68a2c225b1b4c54f6c39a0776c4e143cb37fb8d05a19b6aa999947617bc348660655577b20991f8a562bcd3509e62922f3a9dcabdc24ee0959a8b124ce74c9f63cd7e8bfd6b2bd202772930c5a7ade0787b6ade8adabec458ca231b88fc798497ee928298f2525607545ea99a4c2c70fe51f15525976ecdd3aafbdfbbc74514618d397f17e2192932ba5b263222f046a02c0061cfa93fad4ac7860c5983e8be2ab6e0a7bad61ee4aad4b4aebc6f3da717d303938ea11a6d270c5a8d91d219d931d8b1587930749597430d8d826a7cb997398aae18dbbf32e6c04b059607ec89b0850e3c30970473407b9fe46e9b0031ab4e47681f85e263501a28affdff37546f97badce43b8275987e0c69d40f9722e31f1824b1dd0535a9eb7ecc08a034103298a0916e95c9270587846fe38f0bf41ba809d7586189fd2d609b58e12f18405a7125a60a686b326f06416b16cb6e24d45ba0c24ab6d5033fd171eac2541f70f9e864ce1242b4b5ec5a4d9c9e8d3390404ee2b7abc42acbb3697bb7ee1ee09aff3b9bb6a3cfe7566047bc9aa8134013dc9444727da0d0008038e2d3ac20cd2c440d1c03156c4ccd7cd90e096cec0f764450d0f2b86bdc540a17e004ea78701f60c7fd4ed94bb2dadb202a29a2e35e6f72f9b9c842556914d85b7c934d7aafd21b102c12e30cff9daf26588206723c9e9b784f56d3f032fb182114eefaeb67f134c51bd8f7689aafe9ca0bc79e6529d4f01b860c4cf64ef05647174746d77c2f5beb310920e7abbdcba628688b4448c9b7c51110ea86ee0850c15d5ffb63b887faf76490fa39e55f51d15f1e8e39f14b4be7d0b7b1478a51639c05a71d47c280eed17853311f8ec47f5ac54c7fba92847de483cd281d16348a5e61fb66934bc92e234c35cc45ecddd1683159ada6379358d3cda22330ab599f9c4363bf31f19426378c2f655dd08d24c845b5d52823a85641754db5cbb8aefddf07facf4885169c524e46a1af13ab03f029a8c03c7b705e18a78617922b999c407b9eb0336a35d84935776d60a1c2139f23c2c4f51d4775ddcec2935878c987de2e1ac3ba2703110442a37b1442dc74581ddf21671b9270edd6c8cab0d35f72b507b32e31a803096f668c1524445303c693c561dd1fe14bc3640d436361fd7faa706b3419cbd7ee6c16aae8fc4e8bca43bd07f6880d1608ab2ee544ce5b23cc2621c5a460c3b3d8ca7799153c371d75628697094fa6da6349cbe3e7fb8a9dac44032236dcdf853102cd0d60da2895d818b2a7c15d6eef36baccb774b021a1af4b19bd43ba966245e4f99e3463e53c746b080d32891d195fedc3917e9e81685dc4652587a6b95cd3e73f396e692df8b3cd02d6dac0eb43ce5166035a8385705e8b4d38388d8aff311f4ecd315346a92a5a5a9a47b21af4715211ecf2369c30a876f919f42964cdd0d06cafa639eeec1ecfaa3e34f6310cc70cc85f8b879e225f544d41cb599feeeef1047b24ca2e5c11f2d9a8ca6a3619b21ecceb3bfc09f4fdde6beb1f6118d34b4e5080cf2e8884672630bf38630492bb1be0d8cb1477e7f7420ea544b04eed93a2a878b3e269750d1a23c6075380f8c1b47242b8e1dcc397cc27d7b19e4b5b94d4a3c5702ab0199b81a841989c1570904fd1a1e63efcf7f06804f91fd61243d06f2c301136b27019128e14666b54168b7603e47a849d68b1c9f46e8c6a386c018082f0dd8065836cd88b2d82de33c18dec68f734ccb443555fd7dc2889a342cbd55cfbbdb75969570a858dbe6e01e8aa07c2fd8d641033fbf3181b1b60c0a3af0ce98a168c10c9f9da0a5b7cb052e2df5b4e7cd090b3fe07e9d28850b9bbab543614aa5a9681eb795bb9da7489e1c03cbb68148af66886634432b6a26f9a2f0c410a939c71e752e4bbb37bf100bddf86d464d98ccaa51c85cc5a04f7fb499fd837c466a22eddd984d74d38102088292030cbee88a990e854ef05ad16e3642e97ea9cbd094f9ba3fe6fab1ed6e06f7b726032d47d159f45f5558e6c07bf16ee23f1f850fad65379adfb68a7c7a6d9db7765136208b459bd9870b8e19fe61073751b407dfd8b27d4316886ae1d7d765eca7bd128983653d784b8b47e4f49e81552e028ba7aefb2ca66f1d7f6b257b357a800f0093a438f4d1210a672f143c6e98a4dcf85431182f50f65d352e74be6473edcbd99ccc668a2237325f20e73e23f6ef080b9cae4efffa92223d515c77f518439a1ad558529a01278fc7dafbc71894352446c67b323bd506bb257eb45dde3e0ac44ba3f22b7723e7b3d45923e15288f0d78d8a82bba42d2d46a37f7c016645be2d2764592a9acdff667fbf7a40f2b01a1c93afe6f656684bd0be5cda0b885c0bfee9f0ce1e7fd133b5b3f1df956b60a917cf02bc607384f24e1f176987a0299eb098a9d3daaf5be085adca51b4a32cb99462dca8c0681b86f8b8ccf43ad752d55034c39a4c21a2dd7bff4b0dbb1ee4080f7209c13436d0165f9afe909bf9df03ae53b79a2aac0df40a44144dbe204cde8ad28fb583b8d84a0e17c82a00e31eafbf84c7c26413ac850b98cd9f64529ed7ca6fc37a7197f5e9e4b2c7301108fc064894d2d88d512496b08cde80fd1b42c64b4a1cd2af0bffacbed28952f2218ea5bc701f9bd1ae985272bcc362fdbcc38d13859f74b33c7dd3a27d1288ca6275dccb5de8c89eca923e102348384cc7bba7a35d12e9f6fcadcf4f17c282d7c0eb13d0af5561f73f8141602a97e060e11c8049f99bee325be11e1ce33b2de7dbc6ffcfb09f0dcdf6b91b0ee397c01ef5607ab50b92f6643a0577380760ab2b6e6df1f7c860e97cafa8a5bf6df7d8f091d9e5a73cd86d9c403707f31b7f4e6720d933cabb60386fe79b0977b157645af71b9e40a5131ca79fd7e4f112220e914730979337b7185ec0acb86fec6c7ce122f76c8bfb168f7277077f7b7af94d948207bdd1da8c1014b41e442246924575b9335a18e370e7c01159e142cfeb67927f6c4870620661ece8d495b891da36f5f3ca5fe88a2745722381bca1669c48cbfea4e6eccb8850f106b10db725a22cc5de0afd5eaef70f20b00cf980e4e46d42848dc548658b7bae885c815f9299f517aac21039cb16c9a5aefbc6d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
