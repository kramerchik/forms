<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0588980612afa06a50bcdc44caee9923cc5994f5b012eb93d469d0d522b3cbc88d6874f02e06e71ec81bac7267ee37bacf4ad55f5dd6a95dca72b57e42e4afa96ca99bdd90d4da04a808e6b954e82bd66968217aea948e90cac32691734d5f95a2dcf8c415adb5a51df1e5a141fd400972deeed3ddf70a590744fc1667e838adbbb39c804631401abc7e3d8857c9f238dc2cad723ca852845ef49d5ec4d8894f2b1d9e0223453d1ff5239c4a98673bab64c5eb7d5df9ddb4bb74b7a84cf2d34e04aa73c41bc3c825d3f9495d4a8415e3bd48df4e6283ec0bcbc47171911f69fb3b7bec4f29e45391d06e715e3e468a9b1f997052649313e19f97aa11b115472575653483b9313b17908df81fb020031a1def425fe2e10756918d93c92532beb2882e74ba63b5e264e2b81d00fd9f780e1ec7e729fb3b01afe86810ba6983b5fcff045ffe73555630cf5874d16f91b919e4d743891bc051351b93df4675e4eb62f7a7ca48a423149ec6605fc2e6df0807cfd9c436039e68c3f899c4b567eec96cf5af07e5e9d61fc70649c77a0a7f4ab3ab89a06db41c901747b6b40f14268871917492df17ae5a9a7d227e2e6d04c6c821a83551bd743b366d97e5d8ef7b190fea2581992b6f1dea61c41021275b295080114ed10fdee7217f828c5e9631d4676d58129d935cfa64643daacddac98e28bcc8c1aabd83a1526d54984084eae7aa537edc2dd9e84462e8f5ff87c15d10a7c230b005be329a7e3ca32f5fb671c0b785106f7fca6bc2d0b0ab0db8b901c0e27334730c60838be67063649efe5ffabe3b1679266e385447bcf4e7d1a367b9054e35ae245d8ffe889a1885845d87f793e465e10ab84a4c768fc8948e93346e331ffc5d5f625dcb3d0ebc9591cfd4f84408bc97518cb8dec893a3885d1a83e9ea2f6ad1679a848dcbefe9e4c068f8d994afda36992adf605d1d8bb9394e531f7db2d942952fdee82ef686819f7b7af395ccb362e022c1e5251dafb150b445b205567ed3ae2b52ff3f41ca9d813acdf9b1af9bb71187a1ccf3826436a1a83fbd486411d42bb18912e5e4bc4fea2902e7155619a16284d1fadfb6b801e4f72bcdab17ed298fec37169214847bb9d430b8be13bdfd500defe5156118e90cca29179e5ab019fbd49ca191c794e9aa129ba3e81a64daa682cc3315fc651446a07c6916971c922351e75520f9ac28668ae641718939112271ae964239dc070f0f1625c4695fb18f400cf2e209bfde687227eba62269486834800c593a9edf4fcdf74624f9198e10ae6fd09ab7bf841f8e7ccf49f6a8f038696b4e00ae9490723d2c75c41b4956f6452f751f5c8584884e5549f45383105be4ae2ac661b2859eb45a8cb4db0f32880baf4ee12e82b02f1ad215be483388a39fd87ba5052c5a2ec34b743a12ee049c433e2c997f5584223b350933501b9d792404ba4203fe60f69f2618352873bcf39a22acdea482fa61dfa3a67c330fd3b6698253efcaadadeb1508c2ea5158c93a0b75b166db53b26d616ff2324641d27d635c87da519c1ac76d825b1eca6eefe236616cfed27bfbdc1f58b7041e15eb1f28e8f5aeecffb904be17b66891bd66a7f638eb8b9becba8498cffd966034d8e126806cef7d09cb4a11dde5dc48c8deff0ef83fb6ad64050e09bd58bd67adb2c9a4243c7242bba3b399da99857c7086e90ead409b4e6ff284685350aaee2f30f5523017ae4be57732767ae31e20d055e67ca7464e6d407733d50c01a109ebd3671d753a82e8d67e39e119767d5823fc42fbd8b680634b730fddc8d8595940689e144425ad2f94df1ea4693cdb2286e1fb53c13b11d707ff5415856392f54b716557528d6dc392d1ae73f0b8ffe80eb03a68560645e264c05efdaf94ede9749f87ed01665273bd787df8ff580ff0d6c5258aefecffe16d1d6fb912fedd3bd061bcdae55f945bb70023ce844c198c76c438696238fe1665fbaf6aec8ee1267e3a73a465ee8b56fe0f023e94639dc2578e1a6f8478f1253d2ca1d5d3f0d49e42fa56ea2b844368a4097dba188e6cc60c8e682b59561acdbbe46337cad0bdc9e4ad40e9e8de23261864c017f5b01c6eae2f142e617c874ed26a2f8f4d5c630a7eb1ed071a85290d0370c379c64d75e06180b2ee8d288dbd2a86cd8c011fa817d4c313d1c790e96edf50c4e40a7877eba3aba4e3ec08361f8d47bfd79701d7b1ddf63d378c0b544f90b2c7f6f8b40d14dc4f53c626932c79187565878d2b19207914d889bd7cc7afa41717ef60c959202b99b882cb6f03f07a07c0b0512a0af0329ad5c3ba5e87de194370df3cef7f8395541180507e082ebb55e67de82e7d52ec7086cfdb52d88a6aeb788e02c9d3b32653250cd4d3705b278cea403056ccde3f0077b2f48ccedf8580af9195ed660d393b03c53387f2b68f102e4c8670c522e921d5a136630af122eb7420d72dcf825aa45b054e95018354b714472af56d53bd529f6a01aa295dbf71f5379945db2ae5a58375e360ecd573dc6e27b58189cb19c14f69eeea75ea3c2b4bfcac346d9be9dcff80c2cb9638bebfd9bf4a41fe634834a85a49a2dd6b4b369217410b3ae1d38b6b3fbd3d49dc3068430e8686304fff2741e84ca8242ffbf3b332d1c1ddfb21a80042e3ae46c7ab25a5ec10d527d8ecb5c5a0bec1fcce61385741856d2ba164da4adaaded04d728263e0545d9c558bee3eeaabf03a811d5cc6acb505a2ba5ac5fe9a92c169348a3385fab51e546673db828097c2587912f860095a8b6e7044eed7fb07e064576a1bbcea07c114b0eed6e43fce750878723d1c582ad471e609e301a0596cf32ae0ac6c086d15191d20daf7c661839d79bfb90ca3b46cf48254243a46d8622e20eaf9d808ea86d051ae6b731f372cd6c5340662b3c9e8df66831c31ddc0cea8941e65f0c50ed702d1d8a955bd4987649859615cc858bc48a3749bd74a3f1de344f9167303b937e0d6bb1e2f126b5d18010cc57f9090552471eca6b20e2716cacfeb950c70732792a8d79382270b986636a3192e707d6cf679fca1d1b72d913a67f9077b91ac774c808c0aa5aa87a7f7ca8ae045abab5849be20210b4b772b58c8b37423ec6d9388b3f16940d001c77fcfdf12cc6f52aa861e01d56d2bc2db6caf64c57f0cfd9a5fec9e22f9e9ea09ba0b2ffb6fbc661d70a71296288652e12bd4798138680a90a28aca16e000be7476a595e048c051be185766f1ab3866e18ced30baa44058fef26f37ce8849f3aed24a8337a51e52038d01396b0ea72e269bec71112e76c4816ec6fc4ec940b6a5e445d001a780d6842e1655036bac3be3ca82163fb388471aae1f68afd4537d5b9d47e47c666a8457d178f6062975b5e41e8f6d2aab3b11cba5fbe14d1da4c49cbdfb6a53c1bb95db5dddbb235d49d667b72627866ef10662a507cf876d28c14dba000340dc07c05113c9dd3676694175ce1a1634b3cb2bf00263715d87bd04a9446ec8d67107ae81b04e57d874da72af49d2b959443f6878753ec520d08a91858421a1e88339733e6cc235258dca417c9b6b2fb8ab2bb43da4ec47c81b748bd70d6c67d9bafb05775900307c5d8d34c34ab327a4c5790de845628f925526f08f13066d87e2bf708eae0909b129308f2aab3796acb6b04944728965ec34c78e06ebffcd55b6543f660eb0aa3c7c7bc6b51027275ae99c3c43ea47aafbeb4ca99c33ab9346421ede5f257aabf10136fcaff44b86817850bedbcdc7645440675afaf226f424f5a744158546f25050357f04f179a58225e2b105fe378f8ff89e955cdcee85915286642e83f1c36dd937b75c90ed5855fae72d4625880b95a2d85beedef353cd578385951534d0634504984a33d613431a815450af493a79da905bc19233c2b0d203bdd02001b03bebeb5d917883910afce2b09d368d938b0cb2740c8b6a94c7e3293fcf2cd6ab142e12ca0f1fe4e496104ae2f462e40104a6d1bcf9b0cf9c0e083c78329b4885437219e161c1e43363074891a99d560740989c4f6fa0bcff637b577bbd77c55bf4ff93f22d36afb4f0ee118d4a5736574523ebdd1c42115c0ae90a07d28a8ba4095c6558a13aed8f752e12eb4ab68b6438acee247baf0214a260d50cbb191345654a6075af53b1ada78098f299af3b663b550dd67d4388f171e55f252bfd342757cc20a21276dafba25553fbb2567b3e9c59f55b24ce18672c9a5389a67b54012efc800b38b8080582928cc59ecd64ba98ee18ad3497d32501db09f288f727bcfa83602c8aeebf0cc8298f217d7c27a5f983605ba440c9216ec0be023a3d4f693f2231bd9ed791467cfc595d5004aec5e0ff68dc5322c6f488456ff115672a0f02fc7b64b2b222958db0d7fb7ea9e04d0d076e03cf70dd58f50273d6698f6221f7241ac1b59406049b8c211e6372599857c159a3ca51624b01bea2ba7ffa1f4ea0339b799ff08a4cdbd406e3339eae56b41aec3d86c031fda3d3752452856106c1608369ed580fff922f2b861bd32600829bfb7f08965ea3846e4156acdb23a4d9b5576646ff680ef1717f7c4c5c7c580d0e825c78ba7e5649af8398a147f878fd7394b21852fcb64b8f1ca30bd07410195793164c5fddd6d1e4f06f2158f4443474adb6be3e9e1150634cf568d97843046dc2a95331724f2d12041a4b3b768379bc2172aacbd9f52543d4a422fce6423a00e77174cb54bc05f224ed7afd19ae1b8b9a88966accf77e01efe39193f12873c5cecd6b233baa7b3ec9beab18d56f3b7aa2791a5ed93e5c0f7f60ce83b276b205ddf47ad5e85208c8effb2d0846596b8c8cc0b402908f4b1093d4880994d22b32abfb19b2e0453f0eeb2da14e3fbc21a5967854f27c584b664d4d4d4a027f8304961ae95f5b856710ba604e6147487693118f520143e0cbc619fa47f502e9618329030c6f0e36b8c7302c1fa71a81adeeca67f0dd501ad089c2c59b161763534777a8ec12d75a98e9480e9f6c00fd5606108ad09275b9c13e22a51aba31a140738d51c44a51bdab151611e397af0c77188fc5941f8167e13cd6ec902951c22b427871e1a374c58d5d17a0cfe73959ae4bb0c35a2247b4316159279359d487fa4e21fc7afb1a2e67a58dd9dd6d8f15347c7712e49d4a30e361a7a43d4ab08fed717c20365dedfa48cb39795401ef9c51a762f84ae346c526ca5dcebc45d34cfa997200038499b15b5b3810469fcdf1438e3d6eba0a32b797cd3c86173912b456bc1d7d5049c912c872ed92d302137cea5fd63e9eea9fd766394e16284e743151550d74abf2eca330d55db4670fd3300d3f9943a35a9c6cce3980c61317bc61d3752dac36573a78faada716d9adc07a15408ce558da3719193950b16aff4872a09283ca5bd831e516a8f5e609117498e4f872acf0e73b42e2575a6e8018dbfc8e6c58e0d891e98f43e52d06bb4a45e10fc7a75eb461866c08aeee7dc3ec79ee461f4827d376a18f7841ea518545d449e7286c8731d0441289e3a5ceac8d8ad439ea1f4af58165ed69a5d29ce9fc6b1fdfd402bfa0b079e599b923f271c0f7ebe84e9d523bd2da3f78b70477f8d04b09039e702b2183372bce0cc41dc95843eeefb02fe74615750a34ec87cc7607b4a306f13dd7f88c1794e616e24f22bb41252bfe2be56fcbe71b183a68899198b9911eb775d7b1c2532c5be81e605d3bea321a57bbcad85b588d13520f45de711b1ec876533383b972741ddb4ff6817274d98bac4fe6b8d46226c6da84e6596f21eca5d1009aec77c8b15e563957e78b067fd30f37ad453d62b182803518cc334c10dc0d771052677f76e10e4dc8efef1a0d886043af34d81c1322749f5fee479a265171f682bf40c214822a87c405f00764a178e5f0a363abeeb999f7908c14d0764693d745df211d5853a3682735cff861021a080bfef4143fbb57bcc7e96b31df590d1fb4f266c03bf7f11bfc2fe13a0a52aa8054dc759b1800d9239285df025e1284e4e318dc7ed9ff340b66cbf3e77534d4a8da2cea821ce69b9b8216cb0e91165dde6ddb8d1d36799ec5d01f6db9226e1b174d92de039e5343080f40a567ef37baba00126a62752776cc76253164fae1c3a34e08ac1db7a47414469d2c872ed178f0c45538a1b5d2caa35aff8dda61f09e77c67d4ab170deedf875304aea2b275e5213bc3db6f0fd2d121b07d3bdcc79d5a5b2521d3b637c4402658c5508c22ef4c4836c07aef431a9a481496d8c8890ba5b4b607b203ac3ba6d23d1bdf895a9db3edbf0fc22e0c706b824ba66869d1cea197d5eb5a780eed5083559bc52db5055a309d480fce58c4e4eea0c3aea370d9019cd586f2be30afcac47f55f60b09630c3db948a9fe39326fb920d80ce5a52d303613fc0f5a9004f3f04b49db5bc291b7d1225680ce9466b38bf7346b946fbdd36cc5e63b509c405932afe339ca4c68903780e722018c53a7bcea7ea1743691371a712e5d13a1e556e44941ec0caf3117e7669dfd3e5d603482586f48bc10870cc1cf239ad64392e085645262458980be9e59cf05e9235ebd1a73607c7270a534ab67889c928d950b6479052ea6c70f4b31c9c92b50eea1ad7bbaada61f188424d0d3c4be032e19aadd9c6713895e4ed8ab177bdf6aa9e550f59c481a9f0d93868a63f3bd7f8cdd60f57247b6b777be0c7ca45c4cdd0cf728e46cbcddd8eece47307d312f3b70996cd4702ba208bbec7e8f83d7a396f0badbcffba78aa7f78c632eb98f7983fabf27a6aa1796e2d5a46d8735b478430b454b638506b526b4a5e8e96f27272f1587ee5304cca91366775d4cae8ce8db4c0773b01fe6b9abac008c749d23ed8587b750d9637167a15ac748fff15c7e111bcff13e83cce48081a941b7ae17541f3f2a4c8eab28c9a038b1c608fffe4a12b551949b041838296cb3abf7e8d99cf1391a2106fa41d9de6e2e0c7d77bcbe0fa2bffbdff37c83017191be30d50dca186670b456a85efcd189e4dcb0291642e02e9af865ef9156ac292aff1a0e46c2f8b663b51642f08f12eae009bfc7119198daa5064dc8442e360243f9860565fe97aed053d36468359177fd86d10754e9ebbbd1b7670a582b3dfff2a78d5ab80fff3b1b0301e9b455b1715fa9f810668f042ff5fa0bb852f5969e580300cf41ec8b7dcf6b8303177f9af7f5d6632b55a680bc46d939e76541509d053e40de2960b707013f50974c8c5d597fac5f26ee42f3ac3d5e1bac5ba26fde84cc302b4f3702dba3fe1965183326950447dd751c0baa1002fa9410fe98027952529ff1235ded0040d481b4f193388f83b3845532b29e829f9508bb7cc7f2678fd64a03472f8c3a49b613acd3d666d757bc038421c2f8aede5d6e0ffdf8b92494c4c4bb7784d8a4ab341b0b4082c23d8466b208d9e5c0a2b9ccd7e406bcaed74a5ad615f9946fd2b8331069c70ea3bf9e7bfbdeaa87bb5b88dc2786a605ca296408d3d467f3f8f94861a64e21e46065db076fcd8021b06d18825792845ce79e29c7d5fe9b299eeba330c846555a19af24548b0a4388d4eb1d89299fd8ea16b3045fa635afb269a0204d8b6680eab1d820990fb6117388f5d95571fc70ff25197720a9184dbeb761ae70ca95f83c1ab711c91973c3aae49b1c7848e1382d71741af0460c5879baaac45ae26da143b11f88d78b41d25b18505456c83e7000bca316957bffbaf5b192aa33c36b3ad4617fe93f773c372294281d77b13c8e9b8f447b4f6a44aa248630624747a7334797411be69641f642ba8c2fc610089f717583910a7c9799b04a38f830ba91f687e317c7a9db66882286f7dfd09a6b4d0a415b6921211855435bd54d4939952ad0ad40d8ccb3713829c81d3eab9f19d29474013ea702e6e85c88adc5770c31459ddd8b7a13ecd227ba14e570bcd806a9139a5a5b3bcd2ddad391cf893793c7111d998f5eb28c77ea83471d4b7d323987aee2f69c60907e88f50bfe427e0c5655d2de898af341518900d2026f5ea31fa29c103120cf16d3662cd02f8fd28ceace8512c329908fd58809bd10986f906c4ff48f18f39e0668950db544ca34ea24e9019446cbc32ee155c9a93e49a8e4f3cce98540797a215d40618e8772f938dc92fa5915e84b829862ebb495be02449e3fc291836f69381ad6d62d49f6e90351ecf4ea6f13dd2ed619860b7dd90a7558b86c8fc23a18c3a9d82561659775f9225c771aad26ae78819a8c24027a548661de6a284bc055c2267515bdce3a0a4977001205d0764f43fa2e444c25be1495f890f541179c94a0a49934a66d8134a85bca22a169742f089e01012d79b2c41aeef654b02ecf53398655177af94fe03529d8b7d9a5d8194780199f186a75576bf0e127420e63ff2f30133966047fcc0093d59f1a9d7153851c9fa22b1bffb156a51dd5585a45c047e2014a589be2acce1ba2152bc4191c50140cbdf3ba2ed3159fd61675b82bf5a259e21bbe37c0d75c38df6f2dad8657470c135ef76cb50c6a0fb25ae379a5cea7e1bd18779fd349a1f2eb24f95a05f9b7d724045ce3376ee64449ff8559f5bc8bd1b96e3044cd96b04535166b44fc1bdca11669c646177da21787de8e0b5a5a463fcf239af9d344360e4deb63a037f27020ec0b8b75c8cb6117674a8f5a42e7c18179753ee8dc799417979b11c32d4fe8720fc06b2f01d1fbf4eadf355670359f2897dd34b932aee0a0c5da88c75b3a461fa07c9951f6e11b71ba51bbca80cc8d156d94ad36e5d64444a86a4f54c39ad4018576a9e9afd73b4b21982df1346b8c79651569cdee73741cc06377ae060ddac9d1a69ce3194e365984212d5afdf74bbd544e289616ee3cd1e179c248d582547bab0d8e0666f05a1324f0b1d107de1b2c8fa7235b37ffb322d8b75ea59ea32b76326dc0e65602ba6a27f0a3581e4ca2eecdc314e4f006b4a2a02298376f10d58d272e0636a156d8acde56448194e4e74247bda0ba59fd7b03f2da7b769903bbd552131b771d3e20ca0f9dccaf9b424e33747ad67dd1318fd0519f3844ff7b761b4ce9d88d8a2bc16c1cb25ee41f3f4c2b14beff8657a86cc54566ab11221af03dc09fe03c8e59eefcd1e346c0409534ef5922373883fd789c253a33cea88a18261e86c60f8287bd4819c9e4ccfcc72c41d1c6f3be855c44ae30e8a7dca36a781f4ed000ed953ec14469eb06a84d6466449398823c9729b4ce6e21798a8729d7fd5b23a012ae4a365e8ae37b7f087bfd13f7c04ef600e3d8d07273e3a503ed7cb0c960018bd4c22eca3261b32c8e5f6881538bc19933fa5783b9afffc2017471f4055ad868432d779b80dd5cb4f955fa5cf6383361f236f04d69f6a0d42630447ba5ce4ff45e21201a0d27f9a2adcf1ab31b59f74c7d0a67c3451fd8dc9b4d4a9a462be847711945c853935e4c0884f4cf062a512e00186585954bb7dec1bdf52f73ffcb0815648ff1c832a139c3e4cdf4063f341436260ab88db1e00c246d7158336427b3a9149f685566ca37235f11928a322b328cdf783734a64581ee938bd3f750da8aa848882f340c6012f578ecb9b6b88f35abbb5f747ac82d3db628e06ebd002adbd395d3e55ecaf3420d21c72f2d3cc6397859269fe6d8d49ea804b5348a6f66806326010fc24004342b666e21c23e2069e758003092898a93e579f177fa8edf5ef779e285989f3a06ecb9991a4148daef351a2b73578c5740669e5a5cc6f0e4b40aa85bdac85cc7b3d9330955da93a8ab01e473339e9e2555a0a5af08aabc7dcbb5bb937b042590944ea5ac01be7d58ed24ae7f3d90cb2fd1d490c0d257dc9424b5dfc17cbd67d63e6e12674c78252fa92162fdb5d5ec4b40b4dd96874ef3723e5e8e3bb081e17a4603ad96ba8a69aa1853788fd7e3b2a59b640023dde17ded027a1bc2cf019353fcc75430d0fe9435990597e0f786eb699bcd4329512f298406ac4cf31c5b8ba9ada2aa4e0a0407e273153e9ade0e1dc71fb621cc91b2f2ab4c4fe31e341573e85d1ed3af843e3856e2480bda239e8f7a48b300c41335a6a7f191e5eca7f5a56d540836fa0a33db39b6267ef6c6a4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
