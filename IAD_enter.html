<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f521fe376f2a74748df417acc96683d48ced8e6429183bee5f2bbe7bef903b66fd5fada0e1be1c948d3ce8747d37ab98759d4d133224663431920c6162ebe240c60810ab229629fbeed1fc0b33c53c47e7f45a24dca4daeabe6891f6388e265e208ea752618ac2abead5b9d5520b7a7d675fa73b9956727864c275ed966292f0d256dd66f8fe69725287fa7fc89cbc6cbd9f544f70f8473a0caecf6fde73efa1db9681792c08e9b6feba1810520154928505384a207e6128e99a3e2f85c0fbc6fc66d0c69089f4139f59ca3d7d8ba22da9fba806e59061e6184d4ea93776bcbcefab90337d3ecd763fb75c0cbf728d9e0b27c728634e6b06530e450a66e72f64c7581ab8ff6b878414cba0658b91ab68b6223b134aeed8e047098fe78c108fce93ce151c25527b391fe7a34a740e28040c848557a8b3609d99d73fa4ff135421f941954deea362e53fadd613fe24b931e4327a485f1c854d22495e8ef8a8ed690bbb3e188159036d8cb2c4940cba0d383453546089268fa568144636a74c20b59d7fed3ee0a0946766dd48a129c7b0fa667c39b60a961ba9a2d1c80955ac31e24769c098eb9d54db21a8811dfa52c2bfbc3249a2869a8e7500b884e6b5f779206018373943b83155656e7a02931c36f60ce411ed69be11bca3fe114e780134bb11bede374130532db58248ecc793192e2ce3485c85ce07148a1603a459fdbac1e75a8252e93bd2bb3c67def2467edb2cf643f63185295d5184f893a9ad066b481e1a3b41a451092999a97ae1a46a6910d9315b4f2a6318fcd0065221a01d2c5f4d9503cbe25a21290bb1e427b9ac3c2552eb3d454008864d5a5857286a4e2825163da1cc7b159abafab2ffc0a6c512b8ca066cb09b348142c111cbee94ea9b312cfffd833ec48dea05f2c029235bfa21a3c44a77e4d2a3feaea4bfddaa253d6a6034d513bd2a7684ecec7ae95477bc3df0f3526131cd648ef88cd417a0e691d5d06097f76af4faaa766314ac4467294de19edbe65bbb048d37f26805d276f8da0a02dd1a59745a8a3c8117da387709a084e3d5fd52294a1c5306ced56832e46f60da08989dd2de0079fcef4b9f8fe132c106778de9bf865bd58880603faf728bb4f719f954c86f14ba51b72103b2c3042233055aafb3e602361ab0f0d9031c7aa1cbadc9a930c6bb2f46018a8cda0f2d6dab992879c1407e9bb5e97c147e2f2ad5b836e1b20d1a53dfaad05e1f399f13a59634ae7d600cff2821166367bfcecb8be45e9201a871f8149731a586fdb7f34e2f9fd94de70460d7d9b64042b430a12db1eba139e3368b116f5e6962ff66351b2fef5c603d5b3cba2fd12ecabc57fdb7cea7e23efe7ad8a96bbeb9d67e9ed1d1c2b8740d9f8c924e2c88b92a1f7286425bbd5417ed8072594767baa4837bc238a413f0514dd1346a83ee97005fd1ad6cf7af70d99215f903a818c126ca78b2500c98b0e2249a90caedde61cd98ede8b8928691199cec12b14459df218e23bc976af64f0799a5292a2858bb435f36e68e4f7fc8ac0158f30ea098708286759f77b49b6953eefe894ec95d0eade008a63bd1e16f26dd81a87368b1c4e34b502d7464c60fead175197bc65342b6d49b1a2f101a66cf01b7d1e5269d21024f252c26d15c03dcfa1e909fec6d0f3224302b3529adc7be1c19098e25029677c21271dbc693a9e7cbe57148469a8781d41937ff15ab272ebc2b49ba2314fc1e5f12c8f57b07655df9e6c62cf840bfa20f02c0b37594879e7802c0c5858776ed0f4aff9f91ec0633aff5685d5188641251aa8f0116b18a37e9a32fdd1b9b8959a237dfc385db145aa0c20c6d22d2eee35df638b94f2dcad64b83ae66ec8e019f7b27d42d75fe0ee17b5f3e29c00034e2c6713cfd64f9d553a29bc015dac78bdedc45bf5f7bbe208d6de3f5f7313a230be90b727e0f83dd5486d724cf486e6cfa54dc2ae67d896f44dbde7146a33eb5f0e3402220486628b6a09f248d2b79dc0b49071f6b24198852d72d77e92d468b93b28755b9fcb6ba55d578a62d938cb5fa16d2029bb9c7beea9ce88efc68efccc962535bc93fc3ea84f72e740833c7b5aef608e17fc9395bea5e453656a0eb9ee320e2012b2be5e0a1c55541cd058947523e81b89a703e41ba07b277e9894bc44345cb4def181789ca4e920d48225fbede30e1352393165604f7fbd0462d524a19ef14574a07158bc1f6ccf59c4b3382daf61d73a833ea6222afbbd1cd1db3b3d03b729f63afda893c1bcc8910ea8c5e23ca193ac9b553996367df0750954cf583410a3cf66d85880ee4cb621f24644c9f63c41d319dcc5bec6936495e11c1a14cfa57df94fdb3b9821b0472a7fd702ea7d1915d5eeb6231e76130d48587bb8af207f12ae97bb2fb2cf45b8607dd1d69981124e6d2b9f73bf16fc9e2eb60cc9ea39fb8964f5cc71c352b4bd01c6ca6de17cdf59b5cc697482343b2e3b83f5ed748f9149db9349ad1b9ac9da5496fbc416f58af027d6126deb6f7857ede53c1c044e7845ca797b4e2cc0d0f1fd0c0aa187ed22d167d1f3f0a776ff0ed0a7e5fc2af651fe0473ceb3a0880823381a02905900fed64006b71de96bed6f53eabd6e878e0f2dc491959df8be29e23c1621da813b4072ef11097e02bf2b42af310fcea53f4d6f557e7dddf55e076b40c5c0a6a0bdc9b79392fde1b028acdc78d9fb06e4d95efa0e52f7a88c348a4367a4c77528cccf9b3adcb41a0efe4408395570c45ca9c5932dbf49c6aa0b6ae10a799348fadac53b774d8f8b55314925ddc407b8be9cde594c5f2f73925b550c7a71c82c92c54f3ea1a3cd438e71b6009f518e989e2aab29bedc14e179c242c9f87e3115ab9509ef8b8bb8dc1722728bdc4b84b971f01f11849512999a3a2f70a298f2d83d5d3793116e40121e631cb4441882f59c751b6c44cf6a87fda0d061fa1cd0d4afeab8e84278abe521a3a9f8d2b1dcf108cf7e58e20f089fc9a2b3d9548465a5feae68ae2ec45aaf2dbca83d15b8a4f850561b88c2967a62b0a082744b220ee9e9ed442898a16f390fd248a6fb0f8fd915a3ff180976e19c471e17ec0b23e3a8f9968525461704a516eba1bf354e7f44f57c43d5e5f2f503306071263046285728a67486a207f20105302b6827d8a41cecc40bc04e9df64d47406c1b12376a49083b93ddd73b188cd0ae5656febfaa2a1228a6b775c0600e3b76187c2a03b332215bb707be2f80ff658aef987ce641786230d09877e4c47281f70a374e5c28549cd63daf10d4098eb8b5d1a2c5fd1dc6fcf852a903819497878c13779e6f0b6b2e7ba443e6ecdef0bb6524a6257d351b1c45b2b5ee72d819083b03ef1ae352d08a4831309d481196d340a968078ede1ad6c976928b46f41bc4c66ee2182e78744af1a7932188ea872a96b431754a5058f032d03063eccb6b901862c583e6433d2cfd97aca372016b54967e99373040790dde841e5dbc6efc4b065ecb5a6dff0806cbf23eb252b51a9de9f12fe9948875b551303c37398b904682325316dd4aa06c626bb794ab0a01b07ed32be21c6f43392ef7358528cea65e0e8d36a210e21605559db04d20dbf4dffeb928ec83d06c1438d6d28d1d5bc81a6a57fa3fa87eb7e2e7b68050c04a697a5c0f7990dfe3e5b5683556479cd3093e9fa7aaa1e7411e9a1362b1af505ec523dd7151cb571da09c0f6cef45cedc84b99ea317a05afa27e0e7a6dd29c2e4a07521aabd2e09bb1488412573f4aacc8647587f5c12719bbc0709cfd35f4f2e969c649eedda8ac38e9abc694334feb01dbba9361b8f9429851bea2e085f031570f5f8414a6babec778fc38cbd56ba084b096c357f16453a8eea65c39ff14715ccabdc93ceef2727908fbfc8a1c76268b251d07bae316781641d074dda4ee8deccbf772b00b30ac05885995b9d5a21dc5f079923477a66496b1d5bd526516fb6f9314d06a3ed400577e69c6b7542b31d508e29d5a546e3bc7be50250918be962c80ff7f39e521338b824b09d902e3135b06f0264fd5114b782986f9c0418b0d941e224fbb0727422b5be015780eb2e8b0bb22417abf93c1e2fde3f09034c136c156f8b861f13e0a0bc98f3a6edf5d8a618848f4c749b8120d9141561a725cb1bd8291c87fd822001af4fbc35a27741c48bacaee0dfa71477dd800eadacc4779ef5d2f1dcb010244aadcab67ad8f10394fd18b7859a1d02ed092b6d03bd9c7e01641d41c86f48803dd9c9b5d67cfd1e067c02516bfe3e7a90f000c56ac4ebec7df1eeea8cbb0113b045977d7ac2234e5b58d2e892d02a3c2e3d506fdd8bd8039c290a470daaa21438b0cac5682151da270989818da615f67533271b06acde5c26fa25e8a5cdca805ab91b539df20d912278273c3af71d769551389c235846639f45b49a1b0d0f1a84feec06565e79d9173214cc2a0ef2c414beb9822bfe43afbf5eb8b68c25e5e263489f14f617747dfcdb77b5d10fc4d6e08d7dd3533db41d755503b4c10660b44b2b28180678701439d393640e96cca9113b97a6a62df21aba8c3010dbf108ae48f302e0ae0064b8c2415e459a48a79f9adc306d2fa576f0283d886b3cede28b081a02127e531f0d34fbf4a7dbfa38a230c3d631961f3591f1a727092b4b9178183fea08ed76182430eaa5f5843d2735bf3af72ee99fabbeed178001a4ad8135af89c597a4fc93d39d553c478ebae600a3a86efb4f991caf2db6ceb376b77d409f82ecefb67d664c5106752aef307458d78513d4ba20a05e837ca930f895bb25795eab78431ffaac2e1833a7656a01a509d0a093f80d5c0026d302033fe5da3501189151d3e892c1dc37a54ef5a8a2fd4e78241779358871292e85ffc5d5bdb6c3684685d03c2456cea5f93b0ee6aed3fe8054b92a477a6f9dbbdd64e98acbfada2973ffff889e8c3b41fba6fc3d6491237365368b839cca9159307c12778f95dd250e2f225ccee58f8326a4e62bf05ed3a768389d12d969350f553a7a9a5b75d9459f466926e54f9b8b0e2ce751eb1f771d11f39794306323a18ed771f032b875b66f1857bbb55fd8b5c73d2339598754aa49cfa14f8e4300a648a32572ef1c0914c0c6d2032ddd2ab68d53ba7170ec548d3735b543ede1c72edeba2abd6054fb11f981eadc2b1cc8c8f4cc47561c8af5d34233109d0fd5b1ad478206a2fb67aa96dfadbf1881599653fb7b489cdd33fdb159b8f2308a88932132d06ecd4a62cb4c0d481c257ac485ce48fc244f762ab9168ba29a07e79cddbcc2e3751ffae6fee3e9e338d28e9d671fa1a99bf0a531ea189347a91c90293a6508bfc700a128f1dfc03d0ce80216ffc8b2ddc23d6be1f2698f167464d08e263bc8b502f2ee26a803be05ddf8c1d2d395be5d0d097e8edf6da9067ec0b89bb23c4a237bd6ef7f3e7441dff2b5d863d31e7cd29c624e32489d10dc6d0c6c85c3fff20ece44807ecb017645674d35ac9388dbde60ac7bce2a248078e4c44924ed27a57483cb683a36825d1bafb8f48aa62c5ad5f03be9bb140e587fb2ead02fc914502e0eca2b9bbb4d53870d7b1342fc7aca25a09d0cc4e45b437c3b9885e184f633d6569b6ecc8534b0e78a97a0ed2f4a071cae84818d95caed582082486b0e22c7fb19077d0ad7aa598b8e183d8fcfaa774c327749eac9f55bf64f73845157991063eb16c583236584781d4ef0232a34eff9768b477e013b96747ed6caa6c74006b4489f19bb3f666d95836cbd6a063fb66a7b85c6a83111724a6b1c3c99090a92a758717aef905a7751b626c1b504f5fee758e82c61ea765c96f593828e38fa936de4738918d80bf7f264700606b8e63b72dc8f9d54cf0a458cc3e7317cfa3889b5b2f08f6e787851c9fea4de8cbfdc78fcc923e6a001316f1023f4f4932836ea41ec3bc57e87145ad26f57dcd1ffe543eb5609d31deeee01d540664504795898f59fecbf9b3f66ce54d032e6c7b9586937cb0940b47489dd3fe16e5018736e12b4bbb884c12847bdb6ed37bb68c23891ccd64bdb0f3b76109ff1d0983da9d21f00fa77a309ecdbe02451fc89e1a3cd9a26212d3acb28765ec11e353efb6ad7b29e9424c40a0f3e512221f9537dd4df88927f3770c2d946ff8fdd62bb279669f6dc24b8f270bba5d9fe69eabc1bd545dc091bc042c862e67c06891a3a333d54fa6510aeda9fd054074abc6bae39ca7a643eb17c36acffe7f4befbb0ca78334778ea91c6e316f9a360d8c187d0e9c792f11d5ed3dddd30ba5978fcffd919eaa35e8694b51478c73d4c592f20dab3158c00707968794fde4d9f40a7a7c608bd48bf22bf42464386c00e3d84daa1c2004e9fed9f3503fe177ca619343d13fef036727658be7b5c361162f884eab127422b0883834ef84d9f6193c2aae1ca1aa5afb6e5070df1752516ba52bab73a8949d9cdb2a528ccd073a26fc63976030fe6c4314e66e7714b289ac73805e39ad6a47c3c76f3551765e465c3a637cfcec3fea1b903b9ecfad27519ca259a0c3619e13e3aa243034c59c57a60f8f9ddfe18ef324566e074c6762e178b2c3fd1a9a7cf38ab2a5bb4adebe760ce96acc1a65382ecfa27e40d393302258901fd7363726d093451059889c7ef3a32073985824b3265c6c7b8b4573e023e8c809c92a82783879eeb1ce6bd2c6c1f53bcab6e3edf023058a062bed69d28e4e4b985593f1b76ab8a7dca3588c95922596d76b1d005dfb707c8d22b167e6306181c6c37190dc14619a2f451a6dc8105b958d8eb66751baa2a7e80945a61ea50ea0aa86dbf55cde6e954d0834c40bdf3b021248c9b24ddff2464ded7577147eafdc385b093436092a7f92aea239f048574338ff00be4a0bb26038110f42d6544cbdee904ad6e81bc0300a1cd004ceebef28085d0f5024ab5ec2ed484f488b4d7cbfb574dd258f2c7d23ad3c3e455772c6ce9f7756613ec57567bdb8e33db1ceaa3f0557e7befbf203c39186de4eb4a974c7b5161816afeb897d455d7e3732218185a877b2c99d0aacd275c0c2a272c62fdffee0053c4006ca4ce84ab387a1cf7b68532b18bc74b1b56d8ea0ff5325de4baa6d6e0e1a8ceda20e1c66af9380c1b81326739cb20f09dbf2381c8b05ee8e89425c270a6966fbeeb789891653e4213d984e60161261e55c77bf5a5fedeef2fd20340615820a993b0f7290722c8976e3ee37919ac96a029a512a92ad42b0e3b7e2f0094f2463bcdf0c609f7c560d1980e0c3b4268485cc0339e90421db93a062ea7ea25315d986caafb1b41bf439323063be674a181c55b59f6d7f494c41735ea81652fdea0833e2e5cf05cda4bfe1d9727362dae6201f09e814d80c05e9e0dc893827941dcded5f5305e20f6694db0e8808342ae7def63191ad3cb232e1f7a03edf53718219a9c46fc4f5737e0cbf82cb49fe5cbec8b309065042ef11bb6440a74536ed2d39ca8fd370b3ebd96d7f55b62a578aa99e0436b4b4b812faf828fd20ff5a1b849a074c403d0f83e7a126767b4ca4033a7194ead23a921710bdc8986308218789a2f63874fa34f27a605ff5dc781c7c739a5ebe49bdbb8a454b716b032027c376bb9b86e9ad0c2637e5b7e12a523d63a672bf53bc5055d6f05839e77068b873873c52aa2f5d0764623c86051f71ce97f0c548d789d48ddc1f4587bc2fa7a3e9a4907df411c066f69922156514d3235ddfd1f7affb8af12779c34194542f18f310a41d02fdc72cbd1af432258cbc296fdb23625c675b0b30944ff21c2c4a809d5de393b732c66e0ff62ebc5d3216f38c522f8e1f910aba02f2373d0d64f1d190415989d8a2404189f308c8c1b43cd1b195ce0a98edacca95c4cb91aef1aa4adc926fd55fb042bd054ee0dd78d1da89bddc3926f34c70a72abbe6bce37a2320e52003a853e78f4f407a75669c47d399e091391c92eaf1396f06d689d5ae87180340a4d5b833e412ecf721f8ec281566e208b66a3a239b886a69a0b61a41725cd3ec1573303abb78006778849e5232f975c364afa5090862cbb17bbbd2b93e7f5dbaaaf9abc9a9e4cfe3318f35e500eb1b43a21f30a653ce9887c4cbaadb8fa8ee2d75c216fceda389c54ac1ae3be69f5819bde113aa81c0a89dc7e29262d9055e46061f73f189e47d25fcecea43086b8439f9a1982602e441266c9726dbb62026b64b7b43b11ce17a483daed4d045027bac219bb364e4fb59f07f9e16e36b8839912008283a15a93154675d537966307f1281090478b0ac3bc081da1787df9fc7a3876c3c76c0d59da42f551620f8b2601a4c6e02d17ddc98ce3fc5edd34039b65f6a7a19a817063005883c6c4c724c9989b702b14e48c7fa62abe3f8cab0ba96d5654261d49e939f04d2f01bf2ef56c20821181abd8d025e3c2f0bd33aecdd3bd73a4110a1af547af1a334352e9b3b7bcf624a88ef44518d5d42f707a72a3124ffc8dc709aaf27a6b494b296f9c0a3940769c6c25b1698cd9782284415d8d966381fc3c03530727845ff6a0269cfdffa1b2930bbb69eeaef0be9eefc08c7b93b3247ab570ec2f0f14c0ead57c71268cc17dc30bd057a110fa0ef8665129219c1c1567b58894fe3e02fa4330f4b956e1b43033e1269e408c1f9b8c58ca2a35d8e7b80fb69613d6be7d60dd95493472c6ae5f036cf59c8dc3be32a7f8d72e814ebc60a67386075d5dc8483c5dca9d79b093a0b495b8be1eb39d50ba7fb56d3a34f34f0b1f74628e5a30c5e6cb6855e134035919deda7166eff37ccfeb76b723530521eab99077abce31b63c1db81606650f11ec92aa74c15fde320bd45104d495eaa1dc9a5d117ddd2cc0048222e518e34c79d7ead6d8ef23109cf8252fe7512764e01854c8e0e70c8c4f9d7030f502d7c46de7a3ad394d32427f10b66ffc1769aa5767752df044e373aabc72fb10cbad986d4cccaa554dacd207883c3e4763cedb820421aadad3d5fcff41357c70b34b887bc47cff6d3f5ac013507a7830510fcba68e254224662e4d90191441fcb618a846d7e71f7431c054ba0590e61a6a347be2cc11529ccc64f39b64410bbd38a24757dc324db90892a5e1caea9992a1dd59b2f1bbf2a84da1cc9de15650050406a60c1db711c4db56115bb244f21cf5bb94f514f1d989f3a520b41b70a882c279a1250e76384948d61dd327c6869e88104b73523a1d2b1913f372ce8a14ca17a4a81e37409b4cb153b93c8fca0a5dc8fc522632a1505f9f15d18294204463e96269853039e1e16f5ba1e32020dee97276f331f00d211d94921d03be0e278f55f6bd4b9b632f5ded68a13ed174d1a7cdbe76062be99f8896319e7de2d65fd3fc1b5406d55b69eeb9fad1e9c19bb1ef070ee716b0087e11d00671b2ce04ca9304407598d8c647338e63a755a3cf1eaa8c49e5cee21c66db310714db2e9b8ba2ee5ef64c62ca948add502aaa7f813eeb9ed06cb7d7b0ea8d7ef38f7991ad0c858033a9e85488adf53b1ea0b39a73023b914345a62c06c2e07cda6f9ab05fd6cf7f4764d01d78717f5d38be827e508d5e052b5ecce50916b2d2825863512cd5d114bfbc61d033aa1e82fec6b92529764ef5899a0683b5019cd03f806deb9f23b55e251c1b71bfb02d2e3bd33a4a26a956bfb8738dcd675474ef874018273a8dbf0113a312d76e8c22af394010c8ebb083588a062c0ad416ce11d02e7ddfac093fec4a6fdc4750dfcdbc4dcefcb5e977ba3d9f60dae299396d3fdc2adb3fde73fb2d54bdead1c06a69c2e988a0b99208eb23d47f868832ecbc74a0f38171216c5a205939cfc887be89f31dd90c30bd531aff78f502bbdabf5f2923d3da4a7870b4ef22655d2d0a02b498a3e6cace9a67a21848c2c014b32d49d8c7d5f7a48bb7f40b4be21be0137401cc6fe0957bc9268918f17831726ebd7eff359f1b2709f79cec029ad17b083629c3b0d8170d48f02948abe48a0f62db5948fc33de7bdb19302007a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
