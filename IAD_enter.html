<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"950c5798bb64f5ff436775b1600299db2dfbf66b7d4bb801a9e77ec972ace0c6dc6dcc25cd1738d248fe41b199e5ac5f329a13911a80beb430559b86c5d93fdf0a4f897cc72dc42c73ea60e3a2f4af99f77a6cfeaf8f5000c203b1934896a5716afa44081702fcd278dc83859567128927ae611cd6b67a339f8094a014e781402ce9d24d929f297f8478d28de47c7094f8d2534523cb620de30ecc423d4f57cf065cabdd1c84fa50479e5fd7103ede4d02b1017399b29ccbfbe36de6adfb4296b87441c95eb66978d1bc688d090d7a2cc4a232033e6f00df92458d8257f56fa3e974f6510d40e62853f3da50d4acdd41bcce956e4eec4013cfe6e4b1e789e3c4c07a1de2f7bf14a3d244f5e32191b48195048c7e51e1512780a97ee775b0037d3168ed7cbdbf74e82c62fd6e3aca834f01b74fc1ec74102024dd522c05ada00c6f203b5e7c45f12ca622449133810c9fc148a164f56feb4f470f98887a25f402f6dc0b8681ed587b2e2952a7eb4cc991714cd896ced6cda35d250148f920145ebadf385fc679807f8cb4a09591021ef2182fe11cbd5f89ff704b6e9866cd9b5d137e1b496b454d71a3d79669801c9a4e6179babe86fd6549b000f3ab9806d38d62459566d7291ef5bf61f1e71def41422c08a7570266109b898916b97725d14b98e9fed279aa9b484ba9c9a7ca179c1f441f22ef16742f7e9efe9ae578ed1cb5ec28c9cd5d721afe3f98283cc9278dbc2d498f41c8a8874ea368801a9abbe47d6eb3d576b926a3f5bc676597fa2970f8b9b17d8400dcb8fb5d8f45db63a496d4240463b0cc149582a279701a9e5195d2c69fe858d66590457049d50438b70c7ea3ef4e8c7009a8325f1ae478a21f936185fcc5577a59b67a5d13e41f716d5e34b73ffcff6a2b0d8592fd97c309e462e4aba72b6536d44c43c670537e111c1b6e3656a59e451aec929035de215d43e4249007199ff1b2c062d72a040f116d57729becaf4788bc0a0ba493566739a4e380945337118b0ce60279044c92ba8e664b91cdafb47c252e40c5ba19bd60a42f25dadd3ae7c3b8db1d1898c5c2af22669bde191f67119bd92985d915eb92a1790e5c176970c501800df4822dce9d4fbda7f7e790e77d0d8d7f6f1dbce582575fdfef214cc13b1f046543cfe9a619243f2b54d8fe606825266d39eff3612f73db44aa6e48077f45568417058f125ade4aa2908da4eb20111c2b7e8a8308f729d7492c1c0b9ee7256682ffd060990f12c534e98b1d28a06354c7e1ac2b342e87adae48ceab401763d535f4ad91e6ca4bcc434de030ffdde7456b5f6531593f96a0f65f435a541d4cbd2347774e4a0138359fd2f2db9722f960d58ab9b27c3b6f783a7b59db61cc2bbeb653d12bf9fb42bd4b53ed6038d1d2e433f86e1d557e3650deeb8aebcaa3dcc98a2198f175221c14e25c2cbd1edbd75eb35ef3b93daa4c4dc21f65443d80b328fab84d8b87cc469d029fe5529fa7a269766f0d766812edb1d230d76d694fed2771ff1a4b1576367ecfc241731563951159358a4bd045a82406bc830d012f6c7f391f34eb3a138bd77a38d8985ad894e467dec6ee80fff5189717be7242ec1271d2d76c6ecc224b21e0ffb5c731af139ab9296a44fe6416924ad692ce048541bf3918a9c4e91b972645bf18bbecc0ddd1e42a255b84ec7aeeaaf734b7437815d6a770284e0464257617284848a7808849a7d63a6a9a8ef97df87ac44dcf0ed88abb104e3d56f987dd978012b1bd8dabc0930830fac126e1b6f6fc5e5fbb8ca066e1aa7c13b125e6e1038108ccc829c1a1f3425af60c520a22185d3549043d2506a153a4b8bb66baa7e41ae5e916997b3f185388016fbb72a994300113ea95a52b4539d8b50292a1e7ad73f674046a10cebee8da24ad2a9abc1c67603ff4f51932a0627384f297467350a5560ed69bcf7e91e4153429c5f23b0081f5912d53844e8b7021754ae69bdc0355955b0f194d967b3bcae9480df2e3d4c31561f615305747f1f33ed18ba19a0cf00737821617515ecde5280c8b5b3411362d61dcdf69b13636cdb9d9e57f05cb89e9061459b5ceb538f7db2f9fe28a87e21b4be5260d60bc237232abb75a70ed30b57494331c6d5a1dafeb80584d1a3413d54fd95933e51191026dae66c8af204e1e5fb8c300b56ded3913896733bb6d630d3897eb676f979a941429cd748b7629006ee4f5e0e2810d068fa2e991912542890bd38833ff81bd8ad8186f65e250e1cacee89b0d6cc35aa841f9b4c95258c36103abc70b0fc62782c9628ea72c0ff6816b43eee8c43d9c55b8a62e6ebb453e64ba4e3f9cd99f68660b928287aa95147529dabdcfec77915fa9397f3fe0d5c96ca63a1667b2d3249f04eccdad41eff3db7399a46916721dbf3b71c1b24d8742f96a4b25abfbe8e5e477c13061fc8f557d7bab09b7f644b9ffc3d9d0a1f9981c3a45429c2b6a67359172609d473004b6ac0a2363dc5868ebc1c0657e3cfe4e4bcebc492b42464f1084dce45c04b93256769f8b6754b95fcd79e05cd0e7aa0611113af6b3c1a57257639a4eea8fea26603e73d6c04d3202ac7728ee1e7760e812aa97ee2f308bd3ad1c1de5c44d3f889d5cac37f20db3596f5a1f6f3bb7258e7a9a3a5409c6e2fcd783233c8d0562bdf5d1f7284d4c63476f55263098e47e89cb8331d475ff17016330ce09572a2c806822a39e1574736a68b702eb73f90517d1fc50cf6b7b5e468ef8cfa23bd936f7e45d2af55dcb9d85b265cdd3031a102c1b62bbefda90c9b086bb36e1c30829eaa99fa81ab2de9f7f240779be96efd9fc34c052e6bf7bf0c4def457d57ae471c62563cc2d07968d21be744650603c804159226df268fc32cd478d77aba042131a2a2bf1cb413b33d4f387b46c97dafb5dc56b6e336628d4d6648c1dff44148ad90b30a4e0d8392738c3811246008c23ebdfc37ad10e3746ae50eb00238e7ad386077ab25ef9f2214633c39f82b73833bd2672a15889b2235dd9aef040384333df5668d192451b5be8a6ac10f20c8e9cbf3c1594a588de2c447fee222ccba77fac664f1b9da7c9ca1a7b17799d9a8c66e454b5641fe8396f5f5cc3cbb80df5ce4c23005d05673977d6bd2db0245282919dc53674319a3a45d5b1495685295c67eda23e05b4123ad8a0e356d8ddab12d107128c4d5730e4af006e92d3cacaf266cc3614ee699e5062465bf95d158aa1f02c68ae64e47f9ef5947d0068dd6180800d2da7c6b43762f9b0f762ea17583f90be259cc4ffe37a991ed6281f098407df4deae944b39bc0a86b8949a4d6296391d481b6824f6e5bdecb458439fe0de90c6948dd59a03528099c646a7a0dc353b9876912b99abc47286c30d4022c87f86ccb3dbe1ecdeb2228ca33e6031189ae1ecfbaad29ef83d99fb369209f24161510b1be30adb2eb1477d1733560e3414f1ea6f5f1a158bbfb0d6a6f340ad3ecf3dd8f4944fab7172864666483f7ead7b7a2d9ac5cf2144d88a1aeb206bd052b91302af43296a765bc76064d97cf305079e6de27d599b21ca4b13b618d4cc08aba3e480713c8cc2b127920e41df96d753a498b74c5adc7cfddc3501d53fcd9f0395617a534388588de5a44a856f3fdc32e8845a414cb4323a36326b5c698bc8c4e71010583ef8dcf9227bacb46487278f8c17715d66932c0b59b53c0f59266e364ba943c8dfb1d3b8b120cca71dc29ebaeab6e97f38cd8a376a4fecc78547f94612dd6dfe501bfd53316d22294aeba07bea7f33f3f161d47bfbd8ad0c8b8a84b57e8a0af8020c3ab27bd2595400131fcc2fc6e3608836a071d016a6250812dc01fdd50b55cec52e51b50953f819f28e46fed23eaf340cd4808584bbed01242cd4994dc989239ceb5d903a0f277b1e84c3f17d2fa8e37edc2053ea0d63b6c2b30d68b7a2b87498d4f5572861c5a31c3a6c24f2cfcd32c019836739196159efd5428d13022d164f129c0ec8f865e1b652e6ad90f77eb48af070bbb4a0ec3b0b4e613580398392dc97417eaf1c4835031becc57a26c858b7ff2e6a517a0e47d0f3201493837d532824d9b2cc3bef5543aaad1111d9c96d4d31998338c8b2a1aa0d63887e7135d16bb3662afa9f8eaac4d0668307d74b16d2ffa472f1d7f6add66b684ddab1bcf261c1cb547804d822d9831405cb97351e6ff1ab5fe7a80c23a83692e9038b02306572b75ef42eaf6be5d930b7460122cdfba2d3497c7b1631270767cbc33d01532a41167d7d1b96cc82eac0153cd610f19baf1f6471a4cfbefb147d647f59e99cf76ab3d7d5c444341725bc30cd6386d94a7fb4271fd90b3382f97518b00f1daf6fe14c55badc36a7f9c6e16a80d17b866cdeea876eed33a085b32cc75ab50be6d2be636fe2f41f096f1e13f8c84f856f9c4ff1b1f2791e52a0f2c7cfee02153010890bef2aee8ccd64890d186633f8c8806d7d3f9240883de048cd78b140665b75dde6f452d82dfcb258ae5d1b1fa95116bd37e192eb0ce5ae090ef9b2a5c97d15e39fbf55b7c16f4e56490f0a1d8b085bbb7283097a0a699b200ce0ddc1ebf510c8f88d7378dd3267ad540de0a1ee28d42bc91388966b39b642606e7362cdd7a56df500824c33373fdfa747640b8fb0834a072f69798c70036a1c3f50f017f3a693c7fd74ef2b99680afb88c414b3c509a8e1e5395b8ef663d866c9241c73d7837e3f9b31f54c99162f959e306a310b059233b0a80a99d8e864de7c53a92105070cb0c21c13042689ae037acadc36472f63292d555613ac386281b3a826ea8402a580601de9050cb0c5769e816cf72faa025e8b43c7028a0efe2b78386914aefbc368e8d108a24e31b963eabd7b9d1c686b44fd611b9c8754bc60d1c1250e566c3f5ad34f05dc857c256a8162c8cbb614d7a2ec6fe5c63bf03801307759009998443feb671bc4a8e1ed90dcc5aceee7405a33c691c996dc6f20a8400fc292bea3a043f163937ca3da001fc60d311410ef4004492823f070fca6390b4a6a1b78a1ca4eb83ac1da4b0dc8d85db7898c7e39d59756f6964ae2aa7798594d887aa5496b647f5c89922e4ff736bbe72ecaf80cba31d3e776d7261b1b70dbee7a830b9b78d675fe5a9bf1a7126edabb369e049d61ef21d35ebf7c9a4f9d23e524001221bffb3ce8dda05a56024e1e2eff1f7c38bae1f7714e039fcdec33437b484ebd62282e59b548c03220c9f10c13f9461251c6b5efd192cc0dd4572db11903cb401c62004ffcd71686334b084fd0269543977563db9a45bf803cd0d2fedde7d1fc47033c38bafccd3cf906c4804201531a9460a00a9b2738c68fa0f79b9dc7f221e23e6fbe3794516789c31ab45583fc86fd67d96780e05c8250c2fa7e7b6f0cae91b4bac70d7063130d7f7396411571be020a92369bc3221a09fa3677baf3aa1f293ceabd0b0f24d70c65f04b018b2b6fb809446ae7f8fff803f8bc421f0379488fb58d31bac0c520c3a09c56a73c117afd7707e271862595ad59905679e2ba5d3a2857a6281dc5a7f845dc8863aaaec0b27ecdab003df5a79f53d4a1b758cf06c0ffcafa083f7c04dd208ec4cd839381bb5780df6ba0f221288cba0210b39e3a30f2fe8334c2f617c70a6df4f820f799065b7ebf16e5b1017f83c7c9285dc0eb3ecee4a246aa2ac4da743993d0cee959e0b803121740c4632132a784e2f7eb4b21ff301059106ebfc52ded2680726c8ea2f17602208ac2d2f9e8ab620f2bd7df6396780238836c459739836c3b7f28892b07089e0eefcd13e9dfd9109f5cf83a751e3379140c0ed3db3873a21332a2f2bfbf9a60317c86841dde03030bc27dbe5604eccd8ba64c7231358dc194f558b3a9b04517af70c2a04bb7cf8810a875989c9383dab2e3733171728aa62657342873c5b2f24ecd5be900925505566c2b70f36b8b96b6657bcd657800764031c6dca816722287dd42d509bb284f5be2e45410d91d89f9b51b89b5a25c72f06e9b168c9a6dab75ef8582874648a7dc0eb5515621b253b692a64c769e0cdc9037830dcf16d3019c6a05c567d4f8259a40eb5c165043d7bffef23dd90900d95b8254f69c87542a4c0e86337ce9dcfaae78cffbcc5a4964ace2c21c642d8834f1e66b180a368349e95fde569351cb4e37d29e75e7e4c906d2ca3caa8dedf457b618317b9469d2e08cbd51f831773c9a89219646948926fc72a2c8ac2f85f860047327c208971cb186b886a78325709a83c7c24dd084a14eb8628b268aee4ad4f13525692ef6a42db975b4bfdf02cd72fe7be4988fec486d0aabc2916bc475fb5aa5779c732192965100fa84a2cb24b28038a47695ee5767146f8f45477d3d5ff70107d0ca1db9a22dac1e0a4b70044f42f32cd1e2afdffc6aac9f7e48104851a903e9ff38aa5851e6ecdd18cabdf3eee3908ca37b2e238b1e7bd28d2aa07e4a6b621948137e21e2d8f5f9bb2cd0de031c40b70c44cdc5c5a5c00868456c450859f29ce571cd6121b26ff0fb2fe1a1802bdd7973bb6387b2d6ac0e2dfbf65c82bcd3ebb9bfba4ea083e9962a4fba5d7f7423cb425fd42d1aef3d7e8b3e5983083d6da4f89d277ddb517ee264d69c234b45aed3cd84fc02af9c48ab61ce210a2cce7ce3ea9dbc6fb8c2c2bd86d92fd986ffb6c2398dfb2bd8ccc50383cea1aac6a5ce9f612e650d992b21a7047fb39bf59d1e2edaa201c689bfd1ebb82a533746d8d06fb87a1cc9f9b3e754ea6e3d367112ebec7e5f3e9aefc8a389bf19f7167ce4fb4d21a4a6d233a9cbda5cf4b1aa9c5260204d6a74512f34a0e38ecbde9bda8dc1b30578e0f9c3f7508701c5dccb2a9049e6fb4441db927763a1c556957d2c752b65ea28eec8be2d151c0db4833825cbfcde4bbc89a3f1dfc9f85a5b1d10d4bfd1a9b55cde63ab6e766db6e4b35d42f9f77de2695a48ec3bff9d3f9bbf7ad92bb94768f95deee8ebe018f6f4f646421a038eb7127aa6a92f854ff22c171458d4121e24e0f513e0571193203e185ac670b51df59e6ba26d0f9c32d074e84b69ef6c3506488e326696f85280c200a115be64ba546e9a88f9a19bde3e75b42472d668952810e26694c7b451a14e42f633132d0b3d56c7ad5aa368df8d2609f60b214fee5346322b400ca2c53ad54fae7942237821407503e28d99d7dd661f1bead9a78e0a017541f65501d2f570b2068790b42ed006213b33c472fb78dbf9442af24fcd1bcbce80f3d441e9cc02a47590d519fd5f21f7fd173b61c8695d12298491489d342a937a9e1ad9107e03c573e0802cf73dd636f651db061dda0a8a86a08ed2c18df8ded2219180388a50e8f03baf77b459f51ae6bd7652efb1b58509eb0fd4622294ef512e38423f3bbda074fd265a52899d299ed846925b272fa0b0b88757f102b75bc96db2a882fa05f968e2806b2ec438a7e6238fb8eaa99874cc64f276cf6f917e2d0796f94faf7327ff034fb3760f371e4552db13a595b3db6e3416a23adade27709594d547521b2cef9e1c2c479c7e29c2ea280e18296e9f96374e557ac90ac49e8c9591cdc8b4a421a37f9de559334df8f77ec66a7f6cc2dd0595355c11de3118f5cbf438c3fc0ff5160c4bf731a5a9c1262e9afdec42514795c9973b10cbe04cfe50a9e802adf004f041af629a3d80a62be80ef9dc2d220f3714e318d9bff8a6370a64f88b5c0ddd69155b60660ceb7f5a33432a319933b11f70639fe3499ca3eb25d1f6c68b918ad6434ac2d18cac0f98fa800709334412df2de523c3b8be7f40eb812833f54be126aa63e136a6ac23008e06409804f48610951ea5edcef0b9ab515170e1e2c7604f704548e3f50705ca818971b53175c5e93c8ad6c4e23ebf700835beeb7ec7f4bdb7aaecf9385006da39a75d547a28419c403731ea13fb661619271e8ede0a2304f1afea63cf8cc453c0d96432a89be7f30182a90d0fec35a1fc4e5e189a31fad9dee81c8e283770242be4a232fb86bce2fb914deb1912d61c7bcbdfbe3db801ee2866c6bb0dd9a8f527947cb6f072dca6b226dc7ecee68c38fcf1d408e682fe8ee853fae102cd53969582b4898aff707b3d882b7a5c162ec3c462deb7fc0c79914031c84321519883112179a171ea672ee8238c7e5f27632d704e083f66ad83bf71a2477075dfc1ca4244cfc589d444d70e00e2510398a3ae16c81e82afd9d595caf6a70065ebfd9148e17d20c38bd3fec3d7bad4d8005c5d22fef573c5d241b795929c5bea15c675639f9ff958338b46f3dcdc2e6ec7628d4a923e96fda890f536e2a1e0a9ff76f53058d139ee7102c5f54d262419b2400c3388fa74a7eabdedae460161dce524312bbea756b4d6bd2ec229baf04f37a61cff46d5db50b9f59481494604cf44d2745e54aee886d97626b0cbf227345b7ddca32587a4511d911a4d570c7a6a2cf4f35e2d2c2c46c85c30bb3b0eadb9947ab08f2c98f5406e77fc656c8c3bb134eadf0cc1b95ad093bf6f827216adbc0590b8f1068dbcb4d43f599be663ad99bc9831abf2400d6c7ffa1375a31fe4e77a99e7fb4c706deb70706de481f8da375c07148d3906951caf3ee6e0cbab619cb4d582837cc05442c47218337195647fce1338adc20f1057e42b211157d5f9370646200415d74ab2b214ba4b6a4b6420fe47f12fa8b54f6e253f1522902f6625684db825ac0e4d4105d7ac882e692c942e0b10bd3b2a401f4d98d3df53bd7bb007a64cae730b99bea2ce7d6a8e6a72135fc2e59f0781295455320575fe105b16cf6d195f7a291fbaaf418db553546fe84cc2265c3d1900b07d42cd0730abab4b412fd230f19ee3200ac71699f40b7566af95e513b62ddd7b2c811653a90777f6bd920b5e7cbb67f503e8a61161c70479666b33a1cea5a9c971b7bbe774d6290343089b45ccee0ad42c6ea86971e826bf7cb1f8cf67df22bfbb89b06e3cfcd76b7c5dc00b3bf512d59bf5c59f85eccd47f629481720cd32e3b37d9eb3d8da58a24eafd79be67d775f4cc45e5cc9238a8617bb505a6f28538253046bf3e737d667caad3c362706b76b95a753016ec5a139a332ea761cf7fb60d0c497e245210a82cd26bbfb151b79529cddd1d60251c1f210d467bdde7b6f3f3901402f25c9c09f79434272fb3d2fec501dac675a7f126de741dd63d4247e83885af8cb10ac0c3f72dca7e3ff53c261697ff782e154ad44d5265b7561e072202e0da0a13406626a249eba2100d1a9c873a8023de3791f2a4085b02bb9df6004df97a3d0fbd5cb491abf691cf95d9fdf2b34b114b98fcdd9db841814bffeab8a7f85acd61a94a6c74dee496c579c76bc8acc94ddd2fb8ed957d80d7bc011d8714b0a8fcfa7f4940efc73cd618d7a3a4a29a7df93854b6f6f27015dda5fe04905a11fd2dd024ee27ff047c24e8304ffe3adcf23f7a49fa08612c149ab799effeca821eaea12f0a3e7d62761001de120ddc2e390f2d13e7524fd47e7afe77ec80ed91ca2bfc575558566a293643c620b08652ecdeb794ea64ffe0dce64f608c0bd1848be5428ca81e79efe4306ca4ba14265cc9988ce109d3b9ec56845d636a387ffe15df0884139a32be1980cc204ec4c65915280fc0b42ccd08347d6c7a2b0777864301c742372e700050af3a62a4e919bcd599eca1108dd268fcf65d72a143eb3e7fe96da6a8c1b4cdb3ca31f7186f71dcb738e5aca0dd4f8a302fc5eebb3b08787c634cf514515ac7b4274c0454027c40f00e8ad263a85f66faeef36cf0c80e5441f009f2c0bb4337608f7823da3265a28320bce6ffaf4c4c469c8a467fd2c6916a51f6b30445b043fad89136a6f5e102a897f5f2ef46c126400b33899353c82b215f2ebce6d4a8552d0fe977204e83302b38abd9ac1849b6fb356eca1b065c71e28210e75a4b15acf8640415dc8283505a30eaa2dc41c067959249f71b660b5f4fe7ba086e535aa5c6ccf033cc48e98423e452","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
