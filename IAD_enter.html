<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbb397f9e682c388c6d7d1f484d4b58129f1ee9381337de8ff607ceca89b9d9c4ba3be614e85113253a1b872af241cbee36f718cc30d5044fdfbf01a2851bfec01569d9f8a13b637ec3f4128d8366ed4f3a08afe31199a85929aba786c1605ac578281b1c175fd061d8831166214044dfdf17806602efc50e6a7c7a501cfa7afadcbf58f0baf6ac3df7804faaa831f5e26af51659068374411034441123029632024d3be785aa23f1dfbb749cfd0dbb697e9ba31ebfebd70f36f0718d101e9f93793b11eaab7f86e85b0df09949276aa530b6f8f89257b4a9a2aa92c174deaed348690a49eaa901904860b4a816d9b18cf7c868610b22ec78bc319183c3156e4e6dc9c2b33d7617640a8b054f96cc6def7682085534857f3e794a557312e588025401e1d14ab97c04199724ea8ab6b9ef85e5e5e436cea9778a586441575e825423affafc2d44bbea55d997ad19e3c66586b1b2a9d74e85fd023210c44be8ec7ba24f2a17e02d65306411b3c618a4554570e7ed3eb58536d1b9fed222a86bfd77eb833525bfffa0b4f5918effa57307f7100176c891b59a3ff77f9812c4819727192e8af11fabb89fa7b98a6ee97534c9e36e049b23adeb90d8985492080845c3edd5ec40c58fd193fe294ac424bcefa2718554d97888d815d1e6a700a2e2e6feeca3dc0930b3bf345439eb121028c86ce9d81e475101f6ba911046d9abcedf7173f3ee93fe5263a0e94fe8776cbea2db5a538fc60ebf61c5759e9d76b18f663d14174ee7c43eed393064683e0e7083fc968744c0cf227f73c4a25e1dae84350cf6f949e44b9da025208b777d61966545b1a431d8b6530f607daa48c1fd0f68e416e5f61f24b176c004f3b2498d31d430fe690e964bbd591d8178a170742e01013858eefe73f104693cfadd7792a4d6fb2d2e97486747539f16e7042476c113883b0f7b499c28f9624ca3644f3f811dc5a879661b3770fbb64005410046ce23e0dcf109ff132801125c1b34b5d8fd64a152c492c010afdf054b73bf90fb47f24c6d439b38207e851a2eb02702701919a9f7ef06662e2e72ca6fdf6b0f71e9af674c0acd5d52236a6821ed687f28706e477b902dcd78bba18320752bfe1e9bdfd5326f1e3f394ef39a1246c588850d70aabcef9a229a9fda4eb6821d7f28672cd2a34f95faaef0b9022a6283fe3724839799ec0b2ceac30f93251432c532fb3a83fd2aac0bce5d0ea2da9b2426353a483e93142127bb2fef1f17ea46c4e1ed691ac02210e955ca209ae86f1341769354e7a28e08edecd01984a3e6d589f32735a79e7e26852e2554033fb2875ecdcbdc218642e23282fa4f3e1b623d5e85961ad511d70217c4c04fe8723c83190dc5e8519761eb354784a69d4140ea0ff1c6b9b3544a4573315127c991173614681bf108d6c73e310f50e54ff3bf226cf6de3680174f0b27766ea5846933f4de7cec4fc4ff0f6529d1ed1f684fb5fa9f9fbec612ac56ca38461b64abde830267b89b0e04fdcc5a6923ae389f5fdfe8a82dd54e3e886e9c4a8a216e6c16176e20d42b8ca222739a679b2344e96c5171c5dae0b7058f39ab635d7c74a8a8105a0ec7bd9a66f1f94ac6a417e031436aab1d24976e3d6d375a12e4cf81b635f0524297edc3b3229b284613444fe958d01253164f585fe9a415b5d60225357bd87f59ef14ad507b83f7611d121d5f3a65f66291438e6eb32b5e49854aab2f5b04b5c2d9751abf7df6a29c598da94faf1f71944107910d3b4d3c66a29fdc24bdbf64c882fccfd7ef4342acfdc625a645f168bb7da515bd02a0f41dd7bccf2745fe89eca5f14748357a70cbd6d6627e35769974908b6ae1fbbd082531f8f8436b14f2149bedbdb76d7c4d2a74f3e45e8328c4e94b37a775a2f69cd37a28dcd9fea6459dfd6693a82b00ce7cc8f64154ce46f4dca546be8332df019b506681eb1ed3866970eb03f346133543fd919f911fca22ae1f6d68ee7a5fe31e3f4d711db52b9323b5a22dc4e5ee620fbae2437db0b05ffb67c3467430e10c510a5b6b0a3ca6d57bb0a79c077e71d6105455240067e792af3e2314a2302181ab74f1333367fabe5c0a573f9b18e8a36716994a41b00ec4339d234f5de297f3f084848c652534b493ca6a9b8a47e35961a3aaf7ba9bf7b7924ec7ee5d3e6fc1c1414245414485aaa2e25cf8b02519670d73b3d3fb9b2e27b2578e8e0846e99afeaf58965eb0fe5e928fb8645a8781e2eba4d9a8af71f6bf34c6af541e9586d9fb6a60ac9c4fb0e66bb8281184fc3c5a2268bf605dd43445cdb3161c1f23273064adf60e9ea68c863abd43b4fa23c8dbe296c442aac3240aca1cf8e811d30b0ab706b0630715af1b707573466ef9ea0b2c410733917afeec496846a23c7e1fdaba25f777f49a5c5c3f2521353a8a5d25347eeb231446b7b3a5aae42531239dc24cf727baadab3f0250d98e32f3c9138a867434ffd5c3b7ce97d91530eec773c241f4d094f522ad2bfba89502f7b986c1e5f20ffef36fe25e1a57e3878642c24ccff163b184790ebae7e08fb61486c7f163effc64b841e9cb6405278b7fb46798dbe5e2876b53cb4a27eb350cebcffd0d0534f020872ceba8ee76444de711c5b2a93377c548f7835e2b72f6b38b2125d023d9a95b198872f84d10b0fd43ce8576b9ace2d88ebea50dbc2891e5d9004037c100ad9377c5835e1e34eccb3535423190896cb7cca472df59cc6213a56d4e05d76875591aaaafb78f0f4cf12487269f6285ad42fcbad178b616d7fac19e26fd2627f3f1ec7cf51132f5d668934cf22369c7676e4f8d02f4f3f10ca7101ae1f1eaf2de595ebd3f88da598ca2d51425f4725c673b9810a3b67735bd42a30f1c1dde53017f23c63488cce8f674c0018cdb6c738cc2fd330115824800b8cf3bc379762d5d478bfefccd61a7a7a3a442d15e25330d759b526c77fd9149d5a9a4b29649bbc48af63a2336b1bec6289e15d1567403685b18288adf10ff581755a5491a679412f83f114061345b93d88930201aa300c7cceb75006b4c962bb32ad21a503ca0d3ec6d63fadf21e56bd4ea87cd2375d96e541c0a70382239f9fcc94a6fffd5a51cbb0b7b4d6ceaf05305aaee3969e95dfab09e7dbb6ef5e56d9822b8d1d4160bd726a775d2da2d12fd11c74ffb2f341f9bc8df26664a44ef1431cdec752411725510ade0938f1a69366d70a00d233b750572758dd59f54a98713d49b47e15771c68175442045da24654f096988ad7b6566e79c4489fe9f681e8c4901d8c4910b05e5f04b893677916a48eec25e54fbcdb4d1ffd519ce1e6249d27aa53b0fa3a50586b0d734e1b94559d64b283155ce513811bfe7a92118acdf5083fa5f84fe1961a8db231ee54b35a33193c86ad6692ba0aa18a715b334eade4d5a69f7d8b646847627f0758faad1acce641c876fb3d465f912de34ee367963dbf4edca10a53921e2586b1f1f00cefe192f8d8cc82d2ec4f14f64935ec2266a9c2a34a141ec4589b521a7d1b83a03c824024857d541b4a0e768be4c7da5453dd1c3cc106c67b5b8b1945a1439b62891941fa11b0781c0d40ca62243d5cb261bc0bb6b4503d1bdad6be81c5fc47cb8d6178c77ff16b8146206e4c890366ea1fb7d65a6a80949ac3947dc4c5ee9dab3fd870eedb1ffc4483fb361767e9049c92e1a81e25f340283da27eb39daf41ca4c29ea5db5886f2dda9c2aeb5f060237eae39174c8da441004ec61b30ddf62073038a42424595c76dabc20269e6b0d45de7108a7ab5f71752bb3cc4c6b95cc9a554184d1deb44bdef300df35952fe9772b3a1d2efff41960816bd4f9325d9418cb8e164c7c3f86b6b0da350d7c660ae3e70a021c63d1eabdd5ac0c419e0ddcee1ed7eb2cdfa02f0dcbd21fe3a324374d684513b33d51a93c2cfb1dc9613c3e1477d3dcba617625bda501c7d8b726144c551ea994a4398ab837b0d562ed646d24e1d59fb582746575903506170932e56448917b78f1ac6b5a6ca35f380c733636514795eed0235d34f2c29584f6a9054b56cdcae668649a504779264291c5e5100f1f41f6b2bf3d8c11916432d0fe57f76d38bc542f53e05d95b538d972f9a07c9dabfa82bd44688654e52ebcc2ea5b515c65f563c2b8c260998b7ddeb01c72395ca41aecad0602f87eb3c00c939d354f8e5ecb0ae459d19f07aa3c5df5c088403d936c81bda35b555b568a7cf05208405c9645203da32e8ea3fb92d98253923997e3bf38caa914cb0febf12993f48c48620d81feb3efc5c34073e34e2d890e679e6074172d56cad2ffc1c8e20552c8dcc311b6f078d0f3d3cab3e05b3c6a51856877e8ca8b2638f875c3aa596b4386bf5e31b4d9d45807b3d757879a14d8afe3e9e52be71f75c871e918e857e4246c038bdaa8aa40239c8c3af9152fa53eea25b464e49fcba8fff061cfc96a1f41b5c26909c1f5be0b0c583fb507c7ee29c0f81a586f8f694613f4fac40140bc907f2d60eb672e1aed7beccdfffd7c4bed25a5b1ede580a9c681494e73806e7fad4c1fb3da7664139d4f17290a587e5695fa39f3f75dc50b9b7a2a775835c54e3b1fbb4f2f764bb5854bef2d1cab7fe62b970ae173cedbc6018ccf996a6a80ae7d9c2cd93c0094fb3e065c868c1a315d9f108a09a230ee5f3986e5d1db33435c9fd87192a2f9fe57ad70beb764ec274b2ca328988ae585f185f9ef96f5a2d7fefc3a40b85cd9c55531499812f03d83821b5c46fc398de74239033e37004bdc06e70d355287d08a4e286a2853e0a962e1df1e69e02db79fc2be78e9b6436eb69f2e9740446e31f8119432f61eec5321d4045eb15b7750ff4e156967655aa9df2d7b231a9f528b99780b2ef41898012086292cfbbda02c9db31dad96a32762effe7299e22cfb2018a177013a43c962cd15bfebad1414489c16add9bab8fc842387d5361c7b215226c5b2f1a348603067173f105e0623d45727c78692792a013c7030f7db2adcca914c4b382c7930ff84155f39f7aea1f49b9fcd755313839503b9c8da04af5a4736afe5122ee696444f5779843e5b37b651fb58b0dd53b1254994a664e7bba288f1ba273b07234018af69ed977bfb5da8258994a26ed697fb97a8102aa94e15824ce621f076d4e6a06b97d622e1e30337fd3728c05a2ee66cf6c436d1f5571a28142a49c1f898b7d5969f2021d065a12c2f31b2ac9120fbfdffbd11d95b333eeb4991acdc091d53d2ecf9e1681cf65b977b15f4b7fda85cb38d875f60e3a7c0d932b6462f808d0e4da4cd88c0ea25b00aa81682351aa7dcd4ee8a3f44210a42bc28c6c7ae9ea483ac32fda29004a2a6990063b21439c6fdf3c6bff6f3a684077f051a2129909398f5fa38145124a360936a37557d398277e9757450c1277ccee92d54bcd278d0c8f9dd4ff6f1ed49f32b90b5b2a2b76c16fc89ceeaa3e0d433a865627b0154380c51db0e376906b3c956d4ca263eb4bb674f2ccd1ab112f5edb04bc5826178ed79e4f5ca74c6a7f028b34c2ecd004326ab68196d21bc2b62c27a236cb33e46bc6fe783da5703202b929eb13ac1291808368b97d4fb2ba90f2f9e6e3ffec723d78076e4814b42ad600d511161a9d09baced7c6698ee163e76e765ee3ca35369986c04f7e1955947376e05791214d33352d7416a6b44745c0c40bf5551e42b10e1262c428fe5831032b6b9cf1f61ff680825e975721cc412c10f70cd3b6882d0bd8ef041f9303c6dce8024d3186e40402fed9b327d8fa6302175b1e2c81d7fe6aecbf9abdf639f519cccecd83bee70894bb038c4a1bcfb20162efd341b0278e27f6619271e188c2a53023610437d11020671c59694ea2cdc2585402d6d0d2b2fcb2d075bdc3a787f299cc519de60d98048eba672dc8a33c5051290bc9b01b643cd0f3736a354f85a1ffc58da3f440562c9d587bc56fd20428bc7459f152836f3753d8864d807befd31df7d9e07ac998384e9b6a96fedb570b2908516b49ec73aa817fe4ae6c1666868b317a3cee16edbd8e1528429fda7ae66e8451e63a74b3226243cb991a98ba235fa2d948211e467355d061114368d22e060d1ca81c040b99e2a2a12ac93f4cc56167ffb625362ea1d190309d3371a375cf146000e308045d265d4652c6441b7c4b9ce170bb1fbb90c7c064b504ea1294b85df25e74e27a1fae97a09f2af9cbb543b31ef7e91b5cb3cfb1031f8c9dcbf50fbbf610a5eae6a4df9a87a767aebed01949b68f64fc8debaaa62ba5a00ccbe3ceb6b124d093378dd4ff2649e6879151a1f172c9c72e0a2d6a76002fc8446dccd955d6614131c99a86d144e23816a4e87a0435b4e950f9f88533154eadd19cb71ee13d234f7125c5e2052393ec43ed8b2da255ed061e33f21d8530845cf2b2aabe6f9ed8cc071fcf6602d5a6707af0448d4e524ccc8b8e6063aa58e9c87f9e1a3b31e8aece1801e631ac7795bfc5fe4ac09742aae8251465f3fe215ed2db6e907e7fc03df3167e3f43c2c3b6f041fc804c60913f755378f98414b9f26720a34dbe4ba530f7f15a230e90dff2d725e3ab86ec80b952319e040ca6c3437874361ac16db20e79478ebcd0886afbca9209588295a4c42f976f9578c3df4bf1d23bfcc7626f2883eeddacef6a008da234e695dff35ea6b1310e2da1d5c05414bd8268f4c42d5a8d99272ac73d879243e6960c270be64c18318bcdca66e1ad1677b93806d7a085586f24c7ebb6ed871014759e14e5231413aeb160d135c41789646365d4f913b1e518b8d3c037e22cbfb1fbb47cd4017460f4f6c43f7642c8823124433687554cc7a70a8b1c3dda308496a44cf013b0700976be401b16364eadbf7e6fe5709e508d331a56a8bda8f8f909018f74b026a69f73ed0eb7f3aebaca081891e89a127c8fa90bf78f7e7ac6fad4c17cbafa5ba6a25e6c4780047800962d1e7a7d7057318a1394888eb01a991d166a03133a8c43c561695d8ca02fad03ef20b0e443d7f4af85cc508b98e1c2dc97faa3859fbdc406d469ede3686036993792db6c5d1c6ebb0918b8a1d1ed29e6d2eabdc9cb9c939ce562fbf3396cbf85dc486193e09b1cd99df359841d7f805a080ca0ffb48e98782596f1d14e6a4d4579f6ceb33d7c97d2e715ded6c2f9875c2423a3749557c66034a7a2963cabff14db28e9faa98f7402539f0fdadfb2c1451fd0f4157ab652bd76832cd16c0df4e276b9dd725e0b4a75d7deb67374d385f362e8b6459e650a13cbbe51c5911c64533158d1b7e445bd6912fbb34e49565a18506d9b6b7930d68ff1f20ec5b305f866617e362ff1cfc390cc25f36b2b908bb5f0d3365af5fac8b23dd41f9804b7816073abb901797073929f3abef60be9b8a371fe0e6718a4743689779cc48c3f40c7ad8eeb423205865b6a9c5eec0535eeb425082e1bde41060b34f58ec541411c0717aceb598edf0698060a034f82badeb78d7c5da99fad4925ed9e7dd37a1b842f844a96f7789183d2f6d1790abb3644a48db771fcd59a54eb8f61f9fdc5ef76e2b3d0ac3f2518e6c63f9ba48cc0e92877a1567e4d52b1b12dd471489f92d19d20d303e257f25aa259bd2ea01f60e533d945dd42db8c09c3005f314dda3f272523ecd88757aa98cd8a0ed18d5d6f1f4adb9f8aa03c8b0684bb743eedff30d6e743d123bb60d4c1f726ce0f6d6e71e778af81cb9a64b3a777a2c44c170d8e24c45b12348dcabb09077e5405a4df913027502171b71246dae01bd9d496fe0173892a741eb03a5d56ac79826af42a2f939dc8683eb7ecd6dca0eb35b536f676178888b6696c5629a05abf76d7ccff91050f30bfa08220bf6fc7dff9352fa6bfcc49afe4bb8a317d5912b458c3dcb08c537dde63a0d09236b98bd75f57a8e68d754029ea6f155d3a6333b893f1b7f091801c8c83001d59747ae3d03b48e38de406928f7a161623b2d90e0edcba289cb48b1219ed2480c37fe6cd7b233119ed82dfa70db8d375ce8ff55cabd0d539c76bed2bf30a6b19e4a4e88fa7d35ca57cd776bba126c971d52d0770090855380df832fb65b3647ac46fadb85b06c7e7bf648262f39f7277795814018eea4ca3b97535f95c5632c95578184ca7934f1450d4ee0712c77a6f55d9d01be9a081896e0a93ae5d754b4566a94d977ffcdbf2785da4592f4dd662a116948f43acea36445cd28454915d76aa7759824f56cd7948df40b520d6c7304b939128503e6bb1f4d44e3133e541f50b80b191db8fd95b67699bc2334c1b273e468db5dca63774adf28ab24dc5a9e092937eaf481da699ae045162d323d4d1259d9da806d3d8e513210f854f503ceabb496c992a066ec8776f3006e2dba90ea4ee8e4e73709bd02d5ef7512aec35562bbd7a3c99c363d8410fb44b81fff856ef4746aaf2159ad5d77d3bb1c00dfddba58f5d02825c282d808bebd328737e588445014d975862da141d4a005d8e7db8532ae1b9f3b47dba8b29d5b743f715b40dbe174d4e810793ebd3fef4b68ff18c620f3b1ed73b336cf091ccfc36489d73ff52ecee847d99287881d36da841f66603817d708e03adb4097c33787add74462db240ef387a91462aed095949fc843b2e612910a2b36d4357c5b9ce921c165a7da80dc32f8b9ed461b79f4f9670e0e15b4148efdea70c87becebc1dd99a94f4f659bfbab007a9c03f1dfc22fcb0e02fde838ee880e6a01bc5767ab6018d2c2ba062e330d10738ee2af13c8608f1c67c2287ecd12246f0b8a1f14c722f2b2e76f5e00810f5e68c535a49a8f2eece34a431236f75c225304590eebebc0f2c92e7bdf272b1a9962c4f9608d3ff44eff64df1be50ce8eec61dd6c6a23ddb7ae7556ba4e37d69ac23314de152c9a278874d72f660ed6639ad6148feb2ddf281b9dd2e3572d53e687582fed0034dc21880cc7a00e6e368c42d37695b204893a72248a6a6adc7d0b0bb6b2cc624968e65d3d9e851f37612e30b4d7cbd856d7bbc4e25d288552179395416a268193b29c9a07f3f07342c9860cfed9500a2554f81a219fbd72f4230cf33f0cd3328b0347aed73890dc25d868583c56110bd7ac945d9c605bcca0898469cbab3f1a90bd316634cb4c04a2b2345e53078d2a2f7621fa343b66874509703081742a3e1f347bc499d5fd1ef77cad754772ae4d3325d775a6ec0990902a6454f52a90e1532ba949069334e0778fc9aa1fc1be2eec02005122a5b892b38841882241af207340360416c5f07055c38fbaf5eba7d7979054e96dc43a6e4d35da56e74813e84382f25bcbf0a729630aa466caa9dd8104684270b546c359312a4150bc8437df555aa1603d6527113dac0afb2623d2b4ffc30835c920d070df3bb3d320ee830644dddf74e3f10e1304ba72c4df69ed483afe70c9536f47246bb931074f79173cc502ecc57ecc74879701053b1512709ef4175fae688388d72a09e280262962dd264fe1b4f1793843aba133c0e637e3f4babc78d03d29ae874844eaa9ec056a8e5aa5f3309ff0c50a88199bf02c09a27f750bac6e023d6da02d6ded455777218024d3c70217f83c27af10ae8a962e7bb18e60b27026d1645531fbe53d810151897e4bd0efd0d122e9b8859e3cb0fab1d08dd0f28f90abe9ad6ce671ebfab09fb86e297e3f8ca75b440727b51532e4b3b1e8d8ed5e3ad5ce5f7de14fbfa739d10bec1daa5fa3a614fa56589cd3767238b9ca82fc144646ec3b8f50fba334dc6b6cf2a7d543d1608936fdbebd663a1e8a4422bb87ba919b3f1cc9455cec16f1ceb2ea641b9d20a6233c87ba81216184c4c7b5437ca4a5eefaf681c5cdb4cd1e00081b37612dea94497089bc556df1caec80cff6ef63cee8cb7b6e070454514834c824ae9f191bb17b2128aa4417ffa22768f5dc17d95db337bc6b0320b528b2676a0e672172bc7f892fd676f3868cc6f4bbdafc8ca43c7add596432ec5e80a7c9df0db9d6a312c6ba1fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
