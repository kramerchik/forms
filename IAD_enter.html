<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"067d25943ce120a392f787b4654938ad611319398e6d0f49e3a770c3b409824dc48eda4d4e2ffa5f37f4988c87cc63670c3a19aa42312fe1a5bb62bb48b65e58116d9a91036a540aaefc5e5f2f20b1b949c7f39cae39b0518314428cd842b4b12d2681288251584f8ffdb59658e5c888229f61f40483c38b015026dac687e71930cce493d631bab72e86f0cf4499c385a6ea39c75f3755f6834ccf4e862404fb838c10526e4c23cdbef6007e9224716e92196fca92a50dda26aa0a6c7c27af6bc6dd4a664f8e226c3c0db405d88f3138f39ec7ad75146247a9642f74cdc32cb28bfb00720ca857dac12ed633b0ca4de2910afba49284540005edac2fb38b2defe9b8cfe643968bb9d0b53dbdb00009d5536ce6267c9213b9ba8d82b10678e8b6c529544e55fe0b287a0499558d31f1f60f9bd011f7d4165418a6f7eaa9cf3b3ba17d7dae849cd047ded8ac4e3905a1b5724a6fa7dd48b0ef61670107703f1697be7663d5e8c1f18ed4d8c24238d2aec373438aee0cfb04a5e861618b1c080aa8b2e4452b3165c2168ff27e667902f6fc0ab00d462e853b5bf90476e5d09e30ecdaa3e6b865f77831fc23585aa63a3ce9b44d7385d9cbc7f1c88e50e26e6735bc0a2be6073a656e4fff6a99aad3a98312206596fad7215680b7204792e6604b5ef76d3e34a69614a941d4d4416457b40e68b63dd305d53b16ca425830c8b3e8565990cdbc41e81540be583f9da3f9cd7a34142fcef50104aafb5236e5bd3262c979359d100da9e9f6d5ab36c1fa72a4280cbc988c4e212b2637bb70a35d898a786463e103ed8b7663fa1644c63cb9b71c6c5807cacf70a81c2d9de2b6db3cfa47755a99e3652a14a4536e6a9f5841f8181474f183fcb158a08b1a63ae49b46f73f2bb850a10e77b34fa00c1aedf12a84a94274a505c94e0b01c4ee5fe9528094a0ca4c288bad12b4a3c064d10468550f9878685f7b6561bd3258bc53a749364a2c038aad47149f0e46b60764f65e0927d53059c5336759def756f13e3d806e46393223592daaaff507a65d57c4e555cf5e64e009f29f961c7b866fd5ae68fbd85242dd4ccefa0544a5af6f8bc5d8a3d33eca4f98ed6c05e0d18bbae751ba7200b1ed84e0fc8d6a6045f5dc63e5a3743590f49a413334e4d8a5896975f3e1df461a4a2fc4ee51ec1f01bfbfd3747fe624a022d19175896aa7dbcb5ec62e55113f108e3f7b07d3aa896806884146f461ba3954e266aa0ad9665f164bfd606562f880307f23c1f5310b69cedd200e8dd6448f51bf83130d24dab16180b13c56f1a474ddd48bb0015e9b89937cbbd5ca20ea1681c1ab2bb8841a98f2145c9899d24ba8be840fe7159ca96f9ec57c19d51753239f9973685625cd4bece5a43ebc2466b42daed3e43b757c20ef8fdbfcc2b69f38dc3137c8e673369fb481577728050a40ee4563fde74c51b4ca81faa086e3956637585a2ef182191fe2b8e95e5571fe23752b64627825fe720436f4327305335cfacb2df6338cd20182a867f50bf8eb8ec1a93f13e4a465fc7359475d3f31c6f970ba621b16ccaeee0dc0eb440df948abf308546503f01a4d43b2063745bdec65c9d3140a5dd0ebf46b15c1683979bbabc5b9e7141ed91163c8baf820e82c876532f5d11cbce8c57047927e85c2500c76c26ce226074fda953ecb67732ad0a2f953d9136528bb3dc8ac24d9f26a1405dc80fca74a2cb04ba55f10a69877b3090ae44c9d8cd7fa63ee9ee8eb7531ee09c64f1d2e5d6ae1f078cd41b347a527df974e3af3df576b4b04e92b2e2000c4cd3bc8bca51fe1fd6bc9b85ef0a6d9a76e568758c1ec2cdfbc88a7d63ac1374d6f9fd3966446ea62d40a7a053c3b63b61fc6094a66f2e6c6485c7920ea1b813ef38a5b2a3db4841a7fea582a021b77327b2c3c76258f658c80160d3ba4ba7c5deaba7c59f160b128ebfc1157fb62527e4c264baadf83161c7d397fbeddf80d14e816d86989492c192b8819ab100a5d501cb1f9bf747d27fcefc95613d4a1da4d2d6613d44b2b90b4dbf8507a66d060fef1e99a44102e97f54880f9f5f1a9b1fde663284060e2c54661e08ab3eda7dea3a46538e8c6a009248edeb8c618d5f1ffff2623dc6b626ee983ee32481b87445936f419041d71ad2d36bdc6d0262c4ea19784d7d235a10f8a59e718e48fcff6266ee1560ef42e874d17e61b9fb05c925d059edc7b941128c902df90d2494d79b3cfb253b09115d3d9fdd000a4178dcb9394b85c8a4f5e04f2ec2f57b6aa25e158c342d3fd360234e5fa8bb364f50f1cc12ffb9fcfdd67293e4fa6294ed579c52f075d3e2ea5e89321ef76761859b8e3483a3232bd047c26a4b2967f5807d8f0777144ced80938bec7fa889c8f09f90f079241599aca2135d7223cb121f1bf6b98a4bbfa9724ca9cc562a8d1796091b2268859a43e8057baa70f61e38995fd74c02eccd6cb9903de2daa44c9cf8dca8bb09e0dc08d2fd1b36b74b3d1efb8a028be5df5437b356c13cdf7b9767c8fbb28223c0eeb48f67ed59257b9a89290a72cc47c3823fe32ffc6c21e40538f06773ffe5ceb516656559906830ed9e9909fa6676bcf095acb92427a79d7a70e13f69a529c342806d8d6c455b3e6836dcf6dcb3a59a1bd64b61953686e47f03dbb0b5a1fae2799fa3986fd7e3c1ebca5865e0ab1585f54a4aa59489cc10b940a3c2ae7864983cfdf30b490306d6446e27a44fc5e21d98b9a24c1cb12e8722181c0da2a62734f9ca14486f502315f6ca93a15e0116612252706f4cefced2d4e86c794d6e498b213cdaf97ade5ce1e27e89928f4217da9655a72fc5eb5b1a74b583c0bdd65ac478cbf725b8bf06a52419798731e9a06c8b98135f72ee387f8f9a67e38c3df67cefd7899073e0a9cb502bb76eccdc15a94a773679114646b6a8338b14f5b9e2748847c6de30f0014e5becb1278a8d3fc33cae0c8df075d0348d71bd6ebf81405fa81ab1a80f99874d5f99ccbad12d4c2b650c4f6fac81c4567badcb776dbbf72bf929e64b0a8d6ea61e67d9b77923b2dcf202f74ee61b373fef435c7ebb2ee32ce77deee37288bf4a7c621b92db22a7e6db96799860513252a4e56d6770b09b40ff72a980b4e85aaf503be092e6492a00e885b4987076cfa8adc708dfd7db89b59e08dc356f45ba2ff3df786a9b9afa45e59eba8ac0049ecf6b55bf6388199a8dd82cff3efbf2382ff5666f27f8c0740997809483c5c3bd9fed9713a5cc5585bdd7488975b78b0360d055cbc2ea560762a8e7ec8a2e2af4df50f90bc73b088bb0efec4cb8d50f18cbe70dd3ea712649627759dacc07a942c089076d06af5d92ef5b69bbfe0728e13604fb732e1f64669abe301fd8df13ddfd5b280f79ffe95ed09b628ccad67e9e533bd9bc4087094083212f04171bb69184198157753d39bf3608a6e80496e435e81fc2be966802e4c70d8576ba9521a4be51b17724d79bde6ccfa0a051c93f2f519bdac12924aeadb99f8b310660568f39c20b47ebf9d2ef2bdab49939c64b9b29b1542ae5247f707912b219326973c1a75b0a52bd2586c1e6a90c1d584b665374b542fced7fdbda10cca497c08874499de12263f551f2d5f9dcebe7c5e8ccd184a179cd113b9a07cde072bc7a2ca5b404bef1c6b73dfeeae318f8315d0242e68cbfa1a6eb1b472a2c9ccb4b1391e7c4003295da6df1b5ca6175f8ba682a17e1b2ca307c6c809197609fb558ac3de92bf6dba4cc48bb1032381bacc2dc01f0f4d815baefa5e2001d391afc4ced94c38d71e6501deb25d2dd1b80c9a06ad6b952caa002cab154b5c34461f96234911eff65e8cd5ecaf5ab7bb364eba588f5b9404f6dc83bebb437dad0f214ce01ac76bcc7521f05a2f4f769a30a93fa0eaa204a489ce8ba828b709e43bb990affd54e5da5109851fd71e44b8acab8f90250cce6a1b53729c5981901267f437618348cb942dd15e8477a0969aba5c43fc9d127b5af3bf8eb388f7f5a9d7122d8938625e7d022d3c544fb93739f3a09e3a6b6ab3508b9c2a876dd16dd0eca6d9a39b46ca94821e46bb66cdf89455b64aa09890043f187c41d7b01c928cae70dced6df33a6ff4ce4a566358c45ab7fc1353700542d84e0302ab0163a3ed8224a4d4a13475d61025c8ada2f63b59fae387cd2b663824f312517093bea7ab95e125a705cec620a4da74ffddd12658242b69227c48e5829ccfb182867c72752396692db6370a4e2098937cf22c5fb50d8ca93866c795a2d8361ef9bc1a801adc106263fce758a3a8d8766ee3cb34abd45892a478ba1d0b7c815830298eca1de1886d4cd1d9dc0119ca9235297a4c10b731dbf88b7bbda6f72dec445142e00365b075fc298c24db13f571024148516fcf9b77496a10c7c55a7c7da1e7c7f09a2d2f2ad602aab497b150902bb3c4e8c132c46bca32c9b3cc33c626e7e47d4d345d05d71ece010a149e82afadd24f54f767b6f04a2fec003299091c6854317a65b2d15a9f11f526fcec2bcc3492e554f7d5ee1c36efb8ca1f3975cf2fd51333ba796b825a7d2a20c9f039e9e99dd876bd53066b794cd82dbd7976d266e6d29228464b98aa2668666af336f6d00f791780c1d02298c85923e0d3510a89aee8e0832f23ef641ed99604c9eabc280deae8a0532f5672a86258aba59a5eb4bb0d5c03a9fcf13091b786d65aaa1b522bcef7d1c14d1da2a59361096b7e7007d53b8dfdb61fd4c095ad349bf0a42921801f26576ccea28ce0742132196c944fa354da57fb1aa31c295c9a3d9ef6c910205eed4c88bc0c9d84b5877a001d52bff47b80700ee80ded72c5faadb8cbb82f790b8d16590638803af7c10078bd283633fc637c7743077b593bda0a5ca2b462a5dba719b7e732c3f2b4374e0d2b46fb03f5f1460052f0bcb34191c550953355aed54341b357fd9f97d47689375e0398b6eec0b370324986323b665e23391865a7603404dd5bb13f0821d3b85c7f3859bb67236d342501f7c7491565947f3aa0ee0ae8126a3d834c807170ef9a15197ce1be6c5049e29ec6d819dbd856872aab353f142aa2ab7523299fb36ad7b07e60f41f540280f3427e726326a227140304586cf9fe27d1f82411ac6145b3d20d313ae859200ee9e9676eb0b2549df3a7bc0079e099312a7c6ea2b9624ad387c5b4a37cdcefe0b96edbdbc54aff15ae9b424896e99d514ede1cf9d211f0412ce1b53d310d5e4d9fa56e2bace8b2e70c5ccd9ab33020e20cecb705f0b506af0a0115a551deca2bd579b4a3a4c350e5545cf7a5868ea26c359c46a9d74078460192d92de787c15d0c71de2cdd0cc8367c5e68d92376e19c83567f4ded19df4b89044b26bd0748cb3861345d4ff78a343edb62f2983bef3c69557f1c965585f0b867696ed98da1705eaea71006f2498e3246a466f3b0e17e3c1ee9bcfb594d3dce1e5d863301ef6afcab713060bcc548a0c52457422dd1c0effc3d71e6d84bed9ecc0cdeb77a2a8e0049bc6c1f9be9e592e62b989bbcf7ab6e9c62dd28c41ae30f2644eeac04f8d2f89ad3fd2f1b6c8219e179f03ed7d1917b7e039733c63df8da91e94b93d8b3cb4e253bed4f920c9ff5ca7f3d9594be89fd5da273ac9ed96b457fe5360bb18a208d89e8d9ab35d57aca7a6d6939d6901a05fb57c40b7d204278d6103cb0fc812ed0062ea0ec2fb550cc0ab4b74a509f207fbec65a9f5b9f953795f2347770527f26d471ead2851386c8682a1950b3c0b10a0e5d5782ecf97b3a0a250cb3f0f520a142eabb0b1cbefc0dc04623113c7adb8442e4e50e8575c3f7841aa5dbc40fb7394d1d72f4515a008fb91ab3494a122bd179030a42a2dd02535fcf303e8a94c773f8f32a174cdfc5366279bc0a1ccf985fe29e11a752713e7c7210b20b4d03c9807b2e72ac7e03dff19ccea49c1dd825835259cdfd8478185a16f302ebe15cfc0c04767397211f5e724f0e48e608ad90a5813a7ed88c08bfa8741a6e5b04449c00121d53fe97b5c6807c33a52dac337fee56b2c0b43d629c5f3ccdec0d6d7a070eb9cb424cb36ad2d972dd93f4fed204974c9cd9126e954742ae04c97e2d22660dd33e7dd3aa3885f1ffe92cf5bd3b135031c72bb1e0faa0dd9778f5b1f64c8cb21326986f4c1ec77675472454b145ff4e4d39ce568953deababd9e898ce417a8b1d86601ad01d53a3b614fc3d56bfecc5f437350322145dbb5409f27d429e4315da22a87df57cdc32e720cb54fd142c7bbafe7a914e6a667f5015d208db295cd1a46b702df7adfc8139c9011e4af8609533b66fc6c8672bea16ae796f7a57e89f1e921960ed5d033975dd970626eb2cfff8332db539591a52483a64a71b4fa0b1ed3fffaac98ad0327057bec53aa7d9f2cc2986fa3013f293f580c899cb9b32cebd04ea026c5e02d78607c3cb123dc8d7d41ac90f28276d841f5ace04a3e36b5e1b3c3d48d67d4adf7056303f3e0786463b022ede746d0fc00ec21f7342ed67d7927e3313fc863aaaa7ed9d861b45ab125dad7afed13a9dca73e2bdbb030e216d45ce17e0057f12728a3390f92134389fef8309f00bb7b7f34880505e7febddff9e66bc2fb336c5b665f9ce545665014437766ac49d8db6add87f3222e2773116a20dc8bb64594ea155e3352ed31b6966ef6a73114b04951e91da349a1ae44d4d863058f0356ac5ef722a5f06a9a537193a1cfd497f77d5a2c2200cf0bfe96d6439ad0c32a6eb0ee8d504cb9aa6b839ffb32eff92697fb60b1d4439a36dffbe6ab98925876c8f15ad2f3d6b503387f31e99a06e5f3b0cd86b452bf886941cd6d5ee8c0609b8239bbae00f3f8a4399e230a8f10d2bf616b53e673f6947b4a4fbded5b9537185d66b1c6d549874f6598d340ab6dea6562f76d5c6757e6caf566624867cc05de1184e8f777de23e6d237b441de208f5a3ac85f905ff6af8ad847b22c72372eefc1fd337886a32b137b762f37ad61b0e953de21bb828dca7e6f249a2e1164c92243e8bbe51b01c41f9f5a583bcd1183d46a3ef849f76baff3922edcf699b26fa3db89456f841a4e889a42befce553cda14da9e0fad7a985c940264002795bc3cc8e3860449cf1cb4c933263246fdd27299c291835691e6566c22b8d45ab387e8d074b3b32e82e16c87720dca8c2030c05272bdfa40a9123d9cce69c174e9607a412a8220c0ee4781f45da212933e8d1d27130472d0b36b662d2e2b1dd8047203cbce88f035bd1e17d8fea0d89ecae4d9fd7dbb9e7c1d41a481d45c4d9ae9d6e601b527fcb800ae5c51caab070f8dc2b047a24b94556244a012122dba00e7e61df18eea216dee8698849f881ff653aa8b3e586d6fed65184f837496525d3f0313e9b88ecafb453107714b07b17d3e0bde81aa59e86c56df130d34ba9f4bbb0843982c2735e98a6713b432fa50bce298043387218273889963515d19f4d1f0cd52152110a0f54a70ef3914e7c9eea0032638cb1798af2a03d89074f713ec2de0b54b387a4de68ccc553e17e7640286751f8fe62fb6b54eae2798abf762010823eaf132f1766c0502dfe9fb5d55d81bf581e5913799b0e70fc40daf46889557d4e3c177fa4fc1ccf4d2f6c6d1f92d2d70450017513a6bf56965fda840a35d349583c3710700450da094d042dd046d886e95375f4552ac4b36d77e401f3f49c3ccfa54b129d130a9e12a8d51024b8bb5e4d7f868e29bf937b658b55324aa6de8f31927f0f344a9a71730d7773c4616030750500908ee3caa35a358ffc6b1a7f9ab8a4254786b998c7b08d4d44c1a65f2ebb427dd56e9e4b0a446cf2ec9ddab60821e69daa560cafd0ca7c4727d2d53275447ee3ae807699f9b0e6e6e1e971770c0dbe0a2da279698779044bb59971aff3b911643f01b0e17025023caddcdd4005d31cc075bd5967793cf0a30d3d8a4394aa49c8a8d5aad695c39358e01de6d19a70bdb1d7f0873cf3a45e24e22baafbddedfa303b4b27cfe1ff4734539cfadd22264bc7ad81058efd8276b003b63e08e952be37ff340352ea482ce3a91b4aa2f0ce92a849929b5c7ad0dcc342800aa6c603eb28ef1886086997b4a9a4b3c1def86b3a2ab2e0a458ebb66055547921b4d14b6a69d52b0c0901915cf2facbd348e9303ab01c5eeb7df18369a3797849c745a86f6e37a6bd4e3b61c419cf2cb4ed5be2676aff29229c65138f0df8854767359f317d0543936291e4872f33225380b0b84d8d7b5eb5e431a4d6ef0205912d6287c7e88d497ef6b31248adfdc64c117ba4edc2f012c6dfe5818638f991be6b96b423120c8a32c1ed12e6bd43249cf457e95fd238c380659ef6b32e30d60d84a60feb7d837c767dab78a0a44d0ec778bfe5049d35572845880cb0c7a7bb1051e451c89e1ae6660c8953a07d5033f0161a0858a7c97b58a79d09d1ced51b3bab81e5f6719001c124a21c9384ca2aab63d250b1181f82d1bf455770bd5f5a7643665b904600b25f116cd494ce8e18a7b1e3365da3d4f74e8f19d9bb24fb81c34505a0d2661ca1c23483e012aa3a381aef6ff25abf2b5754d86f23ab2ec1cfe4300986966fd1e4f2ff5c04efb62ef1825d41d705b904cf2178056558322f1271f3db7ba4a2834346bd88a4f8c6fb12d142fbe3f3cbcbbf06a5e39544476f3a6abc57f6fa8097ff8f30168c0153836cda488d47dab4c0272c86b91f1c27a308c9d61695860ab492dc0a644894f7e4ccc00de4daf3860d5ec5649c19cba7bf9d5fe78e3ec4fb16a06453e54698f1b015a302023805ebfd583eb600aa03a8efb9c776280cf759facce5eea55edc351d328b9842dcbc6369494023eef8df86780bf68d67c5c2c013f64ed707bb5b96629233a6ed4a22f298e8efaddebf9b4f85f5bc1ec2141a268285e3684e92017c3a825a6cf0764232a53afd4d01b4a2ac283d685c133966bc679fc28e696b7cf1f4776bda71b2c7355a008ea6980864069dfcc4f320c96b440128f6e384c5470d80380167087b9ca222e898e7b06999c32acd66bf7959c200ef3bad36c179f563bb65ddeec324945b4ba59fd93e938a945a3f84c1fc0d0d86c2ef4653f83029eb9e69264050cc9718642785b7ad53ef6601e6438d369e987bdd75d9f3bdf3dd01a1f7afedcb3fdced12d66e34018ef92de21863b4cdc26d94928daa57767e76506d8a8fea9627d018c0f1467b6ac3d3bbf7a67fb59a5d8d34cae594466f5e0152bfb4785561cd97b49f6d5019c175941500f4494a3e20273d5dfa6d30b4fc375a552d6ba65e4ad746cf5ee761661eb011bc4ec0a14adb52999adf160d4dd0677e03f730aec05f128fa7ce9a310e72c819b5fae1b9acac3a0309dd0aa59f70b3616c423897aa71efd2f220a2bb01281167a60858881ec362b722cf8b639a3a40a3a6a33eec500428ff23c9493d2837e67631f743427d2de89754cde068f72fe58f62c0a4429df4b2a548658920110e394aa9559cb3bc7b54e7beaa39c9cff4307b2cc606e5b2ab71d88289c3185247232866362fd9527a27608e90ca9d88e8660db830ab95fc5728f77e4fd21004406c067aec59ef05783be92b1e7a9332f086661ff5f05501dec151123758e5ac7c1934a6101bc0b34ab5ab7e2cfbf899937188b82443c3028f559ca6679a3d76c75fe9018b7a3a2efcc40950d82b527639ddf0f19be3c916582f297356e82678998dd91ebe0cc40506e6b10b7789bc4741d7f27f0e2cd0857c1d2eefd4ebaf29aeee95d45b0085936dc603b7608f87997a1aa3cd595423fde62aa58d41c365a13ef83b3e2ef277885efdd04d45e762eb44474f57501eab535a6ad43037d0c4968d71c27b104a5aff3c3cf8cc09ee8ae44c312723ce98ad2a528dd450cd0d5a3f07bcec7d1b82ecb734bc0212e49949b81d76777e19654469a772bc3e6c16011516622b3bff1eb93d230df1be77f4798a50c0d621b27372c129146b786721c4279a993c2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
