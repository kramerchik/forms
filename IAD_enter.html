<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8411424eb394a0d13a0f59e52de05a3bca128ff982d17c87bca0e8edd1b59a2a833e0b99699528be895ff12f388e85a6c4fcfbc5768ecf51fdec7aae9b5ce23417f90c296e32783b582c29934184c98b60d39b0f33fb33c6cafed35f906d7098a161ec128a3ea7b0c91bb79a30a9ca4a3920c79006c6b25b6230b346945148c4679ae3f1d8868bd1c7dc850e3979dc5e1f2e8e5d1ecf392516e27bd1b9018f4496338cdacc5ef07f0e98d2ddb7e13552e9858b3b99017ee6e3f5f502a74dd2ffc1becfdc9c08a823d4a0d5cdd37f6f40cf34decbada4042b40c2a52b035d95fb14c523806aa21bda29c51046677aece7700ffecb4e60a587617db2f0e787e329b664c8511d5a9669ba1324bbb35917b14e07eb2dee2ce93b851202f6333331d131e45264125c5472687838dbeeb072afd1de8778940f40a1b14246d56a1e7ed523d4717cc669926656a7b2b4eccec45330d4643d9e7d2578c0d4e9affb50cb81ac071a3dafacdcd5abe954db4acf9ff36a817599a29ad1a2d0d5b3ef607b5a4a74de09f44d5640dd35a11ba2e23050386bd98371ba44702e9582805064761197ac0972aca91592c953b83209a16c55e19f11639e9122104122b93c691093a0be526aa007fbfb92c07a0ad613531d4ba162cc481effe2d020102fa191546d93ce4df4a8be739de86a43d92da7d1e6ba0a249c1a95400d1681000ed1157dd0ca20c3bedff5f09fb3bd6d5c2d34e5f36a61f6856da475f01cc2502a93117eb75b7ff9de14ecee69eb553353774f809039894bc040c4fa78d10ff5d2d803b7209d39909c6272a568a074861c2e346f81d92af1a746d9499ef5c5af92f74e7cae0940f1ae904a74476081bda6a65c36a7a6f3188c93c4af942ab422f05d1e9fa0806d0865b4bee0b834d828d5cb1b493d5ccea32bdc04349bd5e543684b236697b87a80caebfcd333413c52221a1b639d7fbb1c3673cbba94156948c7c9a7752d7b608a6a36acc7cb7ceb5e6e85bd2a8ff479ecb1fe47ac6f8ecc012649b9eebd83dee39b72cfa22c9408fcc09e9189a6b31c05fad8aa43ba31ed193163e4eb82f8e31b0d68c38b333e9bd243283add81bbdaab3aa30d122320cd7731d3baa64dcfebae4c92f10e0d85eabae22197d5021625c7e03ac9e84a0198ae6bc92f7c889d34effed01840689487d7625716e5acfc63734c1ae8e80a303bcd2960312870a7485dccecda9347fb472e81a8684defbe310f4f26a7ca900db6d18ce96d4cbe0294fe74f5add6eaa11f20be96e43952f3feae9f758c61ede9361e98f35d028a9f68fd95db3eadf257a09a2dd55b71b41df6174cb8de9bbc7285e61649120aca06a05d95ea81df6171258d4cb111da8367b9e848921331fd56dcc24503dbafdf342535dc6a548eaa4f60c15f4869847ff62580b9b995457702e8757739824ea223010f4ca3840292bc41091ef318ddb772552094f9a3915fcfe8bcd23efed6413f8cf0a7e84123dc5ca14ccf2c52e88bbd41ddfe17b56ae6e951ebef3957b97a113a011a5c03b24f3245b72e06284e688559e78d369d51f7e6847fe06377f97de459e6890d6ff9c70545a394fcab86b65feec0df548ce3c65180ed66b70c3b083b12d2e650f34532872e88c97ef9045b8d0b2644f4e25ba1ebfb3564edb79a1b70b288c124e70e47bb684725424cfe63573a5ac2c73204fa2c4043779449c033571449c0b08ce0f3f0bedf87a5d7558b5b0a3ee3dbb48720214113488d921083cdf0261f2e740ba24e7e2f81b1bab8ab93617331723f2de9df8ab8331ade62ee456403c418583de4d59eda2a7f9d2797aaea36ec4ed81799c9890d60e12b8705b1720aef7c127c069a17d42170d6552af31a794ba371347d7b8a5778dde2ff8c62f62943e33690b3852ffa98d74f1e1ff1a3d6df7c38451b896f544c74afe04d818737ef4ba889b289bb796d67b0d20a2361e7e33318a9e44e90547538d92d3a3878ffa971d32126224e67621936eef471d87bd31b0fdaee66324ad1f96ba9c37168f7e258921ebafa8e04f887f6202d0025212ab5c3ba5f54a3d6292aab3c8198975913d05381012fd3bca099299ea6fb65922bd414a87eff8ba7d69b5f6c257d50d0e828aa92891e12ba5496961bdc33bd1553288ce2d365ba559718ee2384851f2fded5657f09d28445ecffef6621a90a1f239fa61c80a3a76a3dad442e13bc5885e572be601047e5a61490b04e8f7b7fae8d9ff2d7faa613f5cb3cd2615a5062913c5783eaf85c7793000d41ddf5cc4cb1d03a69998807ecd836cbabe8b14219ad0c8ac2024844ab17640d8f07689f093e8162527511bee021a0b6fbf4636c93231c0beb9bef3b05abf34de964f1654002bb9164f5c35761e5719af939c0521c7e64acecf2873799d4e9d6db23256a8fe9de7d27cb2ccb5c58b9a71c8b5aba518c3e9c910bd3b743679d9c372e6cd0b4b3c947ed11a8335303f28c58bda1cbfd3d76958b9a68016978e1d41b43556aebc29f50c8e8d4221b4efc7385025de7bb10c77065be63d89735555d0dfd1e80341640c2f1d76c874c94732f01a155510f20ba95399156a85e064a85aedbe86cc9fbba78350e0f1d226edf5947e35455b902ede82959131c7d1624710e53865b0531e39e82b6744a38545f24e6f7ae1acc8ed9393db0c703ee48d1a4ab44384f02d447b63737918329dd05139f0faff59532c100125d8d6675b5627835d2e26a5d49f016d4956c84f3efd1a3c4f041ca33dd0811924999990e93cac9a4c32778cfd35a817ec194ee7cf3cbc72dd4d11914246bbf8b1dd59a12befea910bae5382bad902c45f729366854982f95045718a299a27368282a61a7bbc25ad25b77af8551edbc55136f5ba046862feded0c5baf880764f2224ab6e316a75716afb07eb22bd404f85675c72c4385741e19de2d9047e02e84daffe15864074bbd8df172181cc8bb5506b8d661a2e43593825603ff36fa8449b3ba88d8c8a9c1008cc765c402eed45d33a5dc45b72610a5925ba18fb705c0e0ef98bb98d8b702a4d85a993b198acd862a5276d23ba4677732799b5d1199206cf1aa4020fec3d5d32f573a058166befe1d832354dfe1796f91468f2bb257933f2a7131ba2b2aeca0374738e9114648c64da20b417bcc659e3a2da3879782084823801219a5b185f28bc4a75f509a310f1e84d4a6d64080ebd2f9a59c788326cea134ad129c5f4a1fc02b0569e72021fddcd136787dc5966d50c8708e33c8cd611779206c57d4a21d4cf196e98cc807c722be11369a55cbb7c5387ff2460ec4d57c9a193875384527416a22a25c20ec42334f0febf88d30e178d40699b7a49f0cbbcf43d13b30689e7017710b4321d33bb2f33d09bf4f107190ec1ce5d1c5601f6ea652376a214ec970f82011fed9383684a5a83b1024a94af5e94e19f8226db754c08b603aef73a6ad3b87cca25ad9a350f8146154de631e59cc41643b5a6a0da1711502bc662d64b452ebf4dfb73e7e0ea33d6968ee4fa39ab568e07ba1c4f94f128a74ac20bb11b4b3209466b95b9eb195e5496938c53019e2c115fda413f0fe22fdb2f9bae3c31b9db3b1bea986f902f29cff0e465b72a3c13d7fc8eed9057c12e3aa2a72ea101de6d69269dc785c5dd5549552d264dab8106600880f3cefff9c418d042751d727620f121730bcfc8931df6b60020674aead3e13828dcb846f68f3e84920e2f22c84f75be82aaeac73ef6c5e8cda8730f79c0992393e85e878adaf2230389a0b570266a6096c4ba11f9e2727a7858d9b19f878462ae06a6bf14fc115d133e41179c989a7fac9e47df39841887f76d01e5d869b08871d2e480cbeeb7aebcc5eb936c3d7b6b0103767be794834f893585456c2b363f113e00b6fb61c9944c8dcb8e0c98448af716f9d8cb52115f1eb5570ab3fecdb6cf7d7642b1bacaf37690e76c1ceee2386a173279707cb2b230de980f39cb756dcc9e4138dd0d2821d73079d7be5dd5e84f2498e8320668bc794caa5106bce1943d28fed8fefad3c5d61433d9491289381ea9e3d80644811ef80a81701b21e9c39235adce4efa74d8f483e40342a209d10100782606a4c67e3ca370cd830afd675588681e207d3b61826b3a975c490872f9e4ba10c4360ab1e8305cfe148df3a55fddc8e7a85734fae78c730e4d12ce6547603cd9362f73268ee41042ba8141391f020b6d8547ddbfacb33ded7727ccc0b3c56c6b789c40e50c41f689ccd91b30ba908092abdc00adc956973dc3b034220e0c5e3d2d6d8f7ad82c42bab47ed4c6547686bb6b0b4c14dd77985c6d06de4fc06fa9bf11caeb04959f7cd1ae86df502585585e38af529ea94d6dbf9b4ca776646a9ee41dcece8ba92c854795688b248da146ce61b3a324ff481412480c4094657b8b8ab72c9497fea9db494d5c86f022a381754ee30eb97c3f08dd5c8abf0583666c732d1ddbec9928528a594b7c62566020a98f478f6cb394f516a50a426c0fc65dd365e52b060ab2c97273fd989d74139fc1a4e7a33630446b5a485c7fb0dc82144dfd282b980506afc7f9d55a15405ad2b7efe44221a684eb7885bbf0264d59d510db2f51aaa1a376f8791edac9c9a55bd64dd7e6a1892ab79f12ab1c3b9ee98c15d98a6583fd75c6167094647abdd48a94b6a702fa411dcbf7d0da9fd6dbcf4941ce166be00ca88129fecf7ff4eb1900328d1d2cd038b693901efc33b1dce6dff1e67cf25a34f910800bcf0d74d6b01d781e46fa4c33cef312448dcd2f9cdf9463ad6bdbfc5399e7b4077031d819226f049d19dbf1ed7c8b8c669db6f9a4b2eb1096820af416036d1d98524bbe804be474d7a312f8e47347c62dceafe1917adf54b789470ff78bea88d0b122bba13fcac2faa6f35f145ede36ae74f340e867aa862c6ec38edb573d029f5a446b5ef8cc1b5734aaf468ce5894b4b2f59e95a0783fcbca7bf5c18713af51a28642baa538ef7d66491262f551cc3872285a5666b39f8a8d6cfbf38ef5fc1eee25216647782d21d70e612aca3e2ae590812939e6c41eeabe542874743f667c374fdb878be77e66d101235e9b5f0ede12a5c831e8b796f16e040312d670176bde2421e4e5e2a6aadbe0c0f3456180ee335b62a9ca81e487296618e2638a6b075c5e27f2bd418085c29162d233bfe1e332fe849a85ea7d3acd73cb57ee1dd6dd388a07c6518503090a286b2a005f772fa4481852c9fc8e06d2b211a9de5cdb1a68f596e22883d53e8831ddb52802e0e6425eb399a4c6f5187a2fd86022afef9aa6997d2031ffbd6fe051c821f870df25c9f54b0be9a38d4c1a12f781f10758e4e51d005eca17d192fcb5ac7fbb36df621fd60ccad05d6c49de3b61d240b00d14d3259151113fb7704bbfa38869384b7ab2b351e2587e8619523d1446cc91d29d580e2de9a29f40e3ea1149de982c45e67f1b904814cf3846417956ac813b793e8265870d2a0a37fe9d3df5e3650572b3b38fd10a10a8440473ec9e8dedc8f3e0974e94f58c684268e7f403fece4f68a561d4d15af4fb40e0e9e2496333eda532ea17cf52bed8f22faf2361c45bb0ee36b31a3b031b8d992d04c944da0c584b44b9ec1852e3957de34be9d3529a22c1245a4e39d278871491956b08e871180553f3c045b430c4879dd504b7157b7806f7f66412f774affb4cbeb6df6c676e97cfe7d3a2562c140a6420ad0fe6a627660815689c69258754d669c1f0ae29a519bd7d6bf39c553a6624ee078bc679931d664513ddf94443c9b0bf5507a35b5194b70a94f9909daeefa5a82fd8adc4827f708726eed34895340df69ce87003964c3d2571b476e463aa440eb89a92d21eda70b67edbf8d9bf63c995de3c91ad5ecfdeb49e36f88ad825f418e16c6fd5bd969befca394f67c89c391128b373d2f4707ae1645b8f23973eaf2247a1d206d30269d02ab5c172a3caa8d0a6c71c1e67eafa4ce804a6e62d6f0422635839393879bb76f8d85c53497c5b623cf1c8ccc68d75fc957b4e61c3ecacf4cf68a7f789f18546dd1000c51984396eccefffb9ee55df25777faf2a48076a84da03687950c1c3e93d41ca49734008a5ce5d129b31163cf0db4d494a702d2d65503760e89849d0c5bb615c36b652b7e8d0e589c7e8fa1ab5c9e8d3a987bce615287e13c496f63d2f4ded196ee9586cfef9b359d3f4261640b5dc950845c9fc9895d6461717256bbed1d9292bf548af5b9d3a73f7583b05598f23a4d9a50fcba89e7dbf1804d0a1d705a091a9a1abe8b9f1015dec8b046ec52ece304a462f137a40b7efd9fe8d720da3145dff4c40dd850f019b65b5fb75f8d77d2a13ddb7d4c6cb606bae81c69c70e56da881347a4f2748f363d585b3ba31adb98edbfb391b672c84f68da63e88138fe1beef497d8a888730891193be66c4f3751d32301065ef87c38fad604be572739bf03926a735848014d79b46e765d57b8e27d558071a3b2037c63b7986a30fbdac37f6414f4b0349a6ff6bc41842e7662a2d119adf5477db0c46527d0641782dacedcd14354521fca7bef0359d268c70b4eeeadc19a16d6aea3a5fa5fb5d7b7089c981282f951271bd72bbecece0e5547fa649d8f9e8e127c977d3647779b0189e2e04b702fd3b5ff826de345a293cdffa9ecf0ea87585ac4ca70f7dcb51f59d544632b84f9be5a4e9adcc397dc2bddacf40f811bd25cdd07d7505acdb09858bb70939cd382e930e4a2d12a3854f0e9b670bc429b3f0013d8632548976f9c43949ea4db4d572cf85b3f5074c0ede686742f44d28cbef5f0ff59bfa9dcd7c95dcb2373f9cf204572cc3e9456e3ee4bd44696b852567456e44749438a78dded0835d4a40fbc5ba992aca6461aa69bee8c1d933cd2d32173404de7d19b595c7ada608335f3e4e1684b474d1860a9d3a841da6cdaddec5d7353a3ff9c0a6fe10da83dbc80649fd30f654b0d59200488e80fbd80122dee5b6cfc9166f0babd9cb23495d631376b81f71a7fb1cd8b4afab8802f09e5ebbea3a4f1166f495bb4a6aad53b990b7b880a7f2af332041955c21fc953603c3ece9e8aec24fbd4dad34c9bf364fd5b7109ddb7fc13cd4e62361a3a7d1fe50200f200573b13b75f734da243d7c8fed0aaf9f5cc3f61767aa0b23b7e2bd61f49198df5dde7148e4f1808865fa5781a51b34523dd512062930c3388311c7e7fc2689f156698d6d136716e1bef682d638d1c9938d30524ce317d1904e50a7d223d44e049140b5d73e4fad8f42d4134df9e61ff8386dc69beec3e8dcb5165505e68237194968677212bc70a38d93af61a4b879f79d1c584618af51896085539a17343d797533ffc4cc2fcdaa055a4e9a858502b3032eaecdd7f408ae3a70bdca7cb3adb49ce6254694ff7acee191e396661db99e3379a80f42e72121982be991ac0322b82e3894f4244659411bb50642bb66eb9f71d66cc9dc35da3dcf5b0a42023939efda504093cbddb6fec3d111b6c0b5b288872557ca5d2f9e9cec995577eecd622db1c20c9fd5ed0771b6eefce715beaec23644a1d160bb069d1d6f8fcb549e60dba13bbc98bcd9896a63ee51e2046f7c817d65de09454420ffab848873b65159d939f100548c1807249d176af29bb52fa1ddcd9c2201d73c0ffbdd2f93dd06d2fe3e41e5ef63039e44ca29ae68277ea4cfa78354efe0c56e47b2a9cc8c9d19f784d1f305663bb4db9a342beae2d496b455ee37bf48eb7672867499f46c3db3f25de8dc1acbd0492e06787393425e6e709320fb80a5af076c4b25962759a545c8cf0c28a06c9cea0e83927be0381fd0549a3fcbfd49c6a0b128912311dc61316fbadeb7d4b6c52e30f595ed3c3d38ed50083d3604768cc2ccf620d5e0c883ab7ef002f09b6f85bbd4afa402d3f57a37593af2fcd54bdf3b6728e3014707329d48a530e6f878437f79b37030c4b68e43496446fb474b7eae16b078130193634fba018ae601ecf84ee53eb6bf9fcb59166bc4621f120727966f488d887595bf0115749597bfb4a4fe72865bf696e15dde1df50891ecf86439735a11c8e6620761e2d6b3e81ed73fe4a1d93d08dd5d708dacb405bf85abbd1ee94e98799a476caf0c38acbb04e9efd7a612ce3f302fa5df2caf05c9f3248cf8549109666bc6bc6fd62d921aba3368d54ae5c5c5258ea695fc762eed8c84664d49f053d8048a40303d23687a3cd7a22d2707088fddb1086fd3e91ce9af57c1de8c8924ac8dcf28f67872b79351b4019c979871d6ea35198f1110a35ec5e7fe4dd0db8e4753b76cdb401a22e5b51959ac7872920a0b3d2e7bea49db3cb2b868a6455ff187e5a97771dc95e0078725c79ef0a548e06e2e38e4e7284cd6ba928ec44b0c003740ec5174e729dfe7f6a16ed5540ed04c7187eafd9342b8352c25fba44f50e23c59541c559484e9d27c88920b5895e4ea94b61ab2c677457261840475f90ab0fbe1981087f68495af014eac1bba1ebc06c148395c37f92d688da789ed883fa49996152560241ed19f2c4f4428a87051c57bdd61317d62d7ae5b0d728f308107429019291ec85679f3bcea6d7e6f4b25fe70dd672cab2db9df0eab11714b1a5008d8040655e379be3e9b401a5639c80b888fe11dcfad9ccf493d44837b619888f9d162d0fbeb0c2623e992c7cdee271ce6dbd9ba7d57e5c7cad15b460f2e5265b958712a522ec4e44058a1402cbcaa252c4ae11dc7e684e2db69cb62129384f5164ace0a8de2a1505e814c1d81295c9d536811884d6d2318be6b8a06a8a5892ab7d41f2da91dc21f953f3dad238a34b3ea2b8b496b5cda96bba7376cab8afcf58e496aa24f21e34f50b50449b52c1be8e0444d64142bfa4cbf33151c679bae2b01461a3b22e0eb193c645d67a0f37eb118b569122c65ec57114396fa0b83f9cebbbc4ec6baf8bfd31bb33508df12a7589470663cf1f6b1f56526e94e78a1b1dcbf51f7b7c7dfacfa88f1f93b624a3fb7d69c8f8f5fd51da4f955005cf91bbae9f9c9ab6120470aab707d6fdb484e001bc77358a75de61537bc802623a856790e7108bafdc56915fdd06e25fabee62f20df7a93ab4ee6aa70b3f5163113bfa5c0f61afabd8339565f1d2cc41f7671762620b426128669fe2f07432e721d098f917cf34efcd83a08dfe404c9c80687a90b5c910c679769ea880c4fd2585f6c97f1679802ed6ecdb4298eacdb3ffff15f019f00865ff20de759dcbc3769760aadafceb631285bd391d27c3767337a78a70df568d76ef6c9b1585d0bbd6ce7b60a1fc7c8f25e16cd5f4ef75494c8515da2c59b32529cdef80ea90f7b20bf155529d12e8946666cd04e232d485ab70e18be5aaecac2de6a15f761f47414a48b87c913949a6d4272cf8253c08898e7dca1304ef8efb9d34558595cd7314da657704033e8a82a25d8222859773a02c81142142560f59c5c2b85819142b2a41b0b8497d3bddcfdbbfada6b39cdbee801a470c423ee66a6adb3b2cfd941400bd3c95665496c1c0af5c293e58670b87376bd7b9f222b2a0b884acab8f15e3dff6f5d10d12903da74ee39e1e2582fccd36cc5e6171ae082fbfcede4f8d241965d3c7b5a24744b7d0c749962974ed6ec0a977bff7a60c1e77da19d93514e9d69fd4c11d067235dba972cf8d72c01e7d37a307b9caf0bde476a566ae9c233d239aae228b8c6de438ee9349af95d4df2f4f6589bd7ac82752d63040a9ba2808a95432b65ba655eccbaf54b3617b1b901a29d04ccba8d6a254a36491bba79ba252221bcb1ecd9736470603dc1d6a50be41f09ff4e2386238526fc994ba6abd5cc63c2af1d6765bb31f706091875381d39b1c863446a986c7b4074ff376616ce3907878532fbd3865c3d12b49da1a4874211143a46529822af775834ef3964b8b6ba9e5bd614b4ba1e1e2fa9e8fc46dc0e596bfb8eb11bf7397d7c5db5bea95a9b45fb24502ea63ea4f723c9a1ee3a962c7ebd27930452fbd97cd31e3c970530dba6b862ec8225829408da265b58cd40c35a5d89349a3a9f77de10071795e05cc856f92cf6ec6d3741fb7a3ab4e8d050427e17489146bd5589a45a4655d9fff3efdeda32464cdd8b3fd8372322add56e2894321fca65721ebc794d7116b3de278306e71bc1068b087d1e4f7f6e8738390a857cd0bc47fa04cb21e6bd359b8b23b9eff06bed598d63458d01ea15a4d7942799f57369b570617962893c64bb2d232f7fff6ea01f9dc2779732c46650defe8f8de6e480baaf947f90a2249c637c6cace363b352a73694ada67befae100852404724f4bdeb295361d74dbf0fba72b49ca2ab6ad07c402b35d1c67c863632700d880d6f4a68dc5c5e944638cda84ade71aa83088da31d6f5fc97fe75b3b3f46a01d359f89c9778d821ceec424bd7931bcaf7c01f9ae5d2c021d1447e82147fc0719cf44a2de442a428151cca4d922a613b36e933522dd2deb019dd12e6c2fc06ca58885364b8548965fac112712798c73e4e861d2df79c9bbd63375454263b1b54ae7f3117f4a77e666f506873c99abc655b3e7899ddcf8350a1bbf73633f8ef726058d612213a20f6b3187f7e50ffdfe2a876646552a06ee595803ffdc88cad2c842273edaf47741b5958333a1aab6ff0f0428edc416328cce6e9d0713c9fae4f7a9081bd5339a4aab9847567912dceba1000fe49848e62b570042978292b601d9720374e0d3889a95c8a515f748fd1451c40abbc1b1891b5e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
