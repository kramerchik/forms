
<!DOCTYPE html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>

          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"667355baaed6378ad522c92a38d0d06e3ebae87c272c63d65ac63059cbe9a2a8dbf24be402b07d43f54b4a6c30ac5905905fbcf61defdef083e1813767e55f83ed24d64ae7657effb5b95ba5f564d16d9cf272e8c393a9a02f58f5d551a576d06f33c43ceaf56ea39e2f5fe4f6c718a8656dd2f73e6319b862c56ea817c875f46b3308290a7b4cffaa48a36f7aac1bd196cd2c2afb855729bace578da1e8d8320afcd5222fbd00aa02ffed6bfe43c03116cc8dbce167d582c22f3621527bf448c053f2cb78dc5790a4db546578d34f57eecff9bec5a8fe639b4215fe45c3abb9d50bcfc999335ca962fbce8799bdbba4fd5231258d92a7cccb3a07dea5c5513c9dc061aff89a95accdbadd9793f8515e97b84f2b95fc10fb96986235e40803a36596c9152d6359dcce09791e7db7271a8e8c0440987ff370ca333f432d6aebe40fbf3d1b4c1418dd2dbe8671f18887a4f78a15a998b616894efedd89c3b99cab9d3e810e5a9cdb4f8bf08f8af3800b1fc4932841c765aa40b58d107a17f3ffe785928718115aec25ef492abee8f8a5384d63f8359adea21b3e09b82c778e13f7e20e7857ded1b4b309a434c7273cfbbb03e4ff6543cb509c3f55516860f62aefe0756f134e61fef685252aa111f200ca693e52686bd8f133549734bb15ef6af9005a3da704025e633ecb3e7a8f075432584facd8944fa47f74a8095b7b1425b74b6236c82448a4b03e9c819a0b93ed187524637ff1a6fb33d4861bd7684f8083211b4241f613ac34726976cf7ca706c109dfa4bf6d253a2484b4452864098ae311f8d7907c32a5060e5c547cf2e7d9ca49d6f7efde23f0272b8697ec06ae28b95a2c0a6a75b1f5d1127d896c68c6eccb15505d560ea2f5573ba6939748cfef1dc5cb0e10318cc907f3d4f1bc31c6085ddab54cb428019b50fa4a20a59ca185250205207dd66852e1bb3cbb4c578e505f5c8e2aa2e84df74c039eb5c785b3d23525896bfe71a19c4cb0410de513b216f374abbbcadfc1030554cf038b421733d23d902e64953b017b62c51a7dffbb29beaac91df1ae3fa57ed63f0ea3f551204fe947475772fc6bfbd4f9293be18f3467c2cdf2a4e6299e90a3bd948b706fd5b2e1a1e45eca834240fee326af2f1239b97ce5d034f06e5b40d3c99bc5ec0e0285df8e84874bea99495c38df5eb65f067079b1c4dd670b2c54520907c9a99723e541eb0b1d75695bb31cdc725eb9a7401bf359ca64f6dd3afd234bece62f8397aac05c081bae617b9f07ad32e34af59df0a0039ee93dd754a4bb3dac9e77fd06e839b095310176f5e2778a209170a0493c15e6b34572f1f785971c2fdc0d3e0ccd1dd6da0fb66cc1fb90b9ebcc4b7ca827fdb97ee1febd5d197b765ef971e7a7038bfb5bca4fede00ebd3b232c62acdd1ba0fb66af184480a0b198d1dd3214165789d31ceebe041041e7582735f6f14695541767d22f5350138a4e4e41f21dc7a79ad019424af965dafe99008feca5415604198c6f0d406a76bbd600537785ab6a33bd90ef8bcb2178f21383d9dbb55308298edb5b853ce2001ee3a873c4db00796f615b15d877271b85acbc38e3f68760c56605c1a11f1e2aa4ab597913f27cc973901406d0ef2d6425ec2ee1634f44a2b4e019dd02d52d83379e7f88a1ba2132e1c41dad7727778748b5c2ff0679ac20e31e988b58464a29e9301a410deaac5107d31ff657fd2276bbd2ea1a36947dc229d7aa444cadce4820eb3dff9814120869a1c1458f54f932020f8a65fa699f62e5728fb1a6ee17b2abfc1d6f4471c6e65f6f67fd5217df7193d26fb9db361daadd5ea39df7a68708805cf8a813c46363559d08610e159595ce4535fa5065b962234a653dca85d495eb52c0cf3606b51a0018793842d7c62e1fe063ed461346de369a6a3538a5e3ee8bdd8aa59bd86e723ae62372db6600eb389d4dc7850b51a2c504303ca49869e48407ead912fb096f6036cb14fe88fc815d18917351734ec2a7a1547f8185172cb11a435360d557791cf4c24a8264b39585ef68f55a44deac69204e71b1547f047c5ffd186a31ca7f420deedfb96f67cb56918e536a9d1425e9b98f14467aa6f976ff9402f28edcf53ba876bcd452f76eb3242f2a8eb2f0cae0cbc1683ea5d5d57228d499925312b1b34ea6c22bf7245d2f0977cb649d860f8d8ed5ceb0243bbd1d77c74b27777d1c3d0dadbbb2efb11081b79427bae35b007534ee61feece7cf5e505194b3950e45410e7b97e9a407b91efd9dcc590d3610538e3144828c8ed025c968877cca09e3682eb0ce074d09f163a939675bfd6b010b503caedd27dad8f88177b6b592cc83360e60181db2bbb5e51fba3da3a99827ddde4ecfce5899e7eb228124fceb15bf80fb8e3a1d21afb2e143546968da4a9ca8ef20de9e174d3f1c240a87c69bad7acf40937aa382c41208624689598c618e730f36acb728aec1a34f8454bb4bf1822adfab5f8ee9eeb7572d63eed177e61e2ad5fe9b45b74cb2ebe37748b7e4eb400d8717276833f47ef99f54f41715066a202dff0c8e20affac7f72ba68ccbea1a2b13380ee93674ab2b7fa3ee00dc708341327f6d27c2e310523d9edbdb0446d0fe107a08f36ce77d62b483d6673b2f0dd8125cc659c8069ec596710e9d5d699b94f8854c73507d99bd8b609ae684327e437a2789d8fdfd2b76c6a2d09963668ae4ac2940b67afc65f11dd0c33824a5ad04f451280d17560db06eafd2de1dbc8356d1285c53f1afd6c931652d71dd58e8c0ebefd2fa50962658ff4f47c10b5a53edf76cf96ad268c66d5d59ed3d870b08134223e2c3773c7019cf137d42de83ccefc6e53465a0a2b2f2a4610f1da86764b3c8256929b7a0c4959196b3e3c897c0df5d775194ad7f8f55d9c1cd45b08683044f4555f3c7dbba36e83310548deebec8b7b8ff336e4b3e582870aee143e9c5549ed4a49e04c05f47100b93c7c8e9f1014aa66531c8762c9ccaf8b319de2f4cd5c0912f04a00e87008244cc08e91d0f1094f1964730a4a76f6e09619bc17a90e3ffc91483334958a869db63a7574096128deae44f3edd12da3467b0b016fde0c57f50dd95cbc880dabee6c5477c8ed6d356e4a58f83cf8caaa29b94527437697abc4031d97e5eff3fb12cccb56d5aac93ec6b419def6f96438aac5b4e507f0545befcd4241d1e3b31ac57bf6b375d95fbba55c31ad8637f554e58f8dfd9fb5b3afc510d7b21d2c24922a392e03ae27ca339af3dbf6b4c41e360243867bfae4d97e508ed740da2444486ef06453ec260618b03c1b164051f6cab007df077f0b454737781d8d4d58fb52ee9b4493e98c4c43b9c5555f7396418fc9914fcc0f0f42bc9f75db2d17c02e5545c070bba38e7cb163a3d7857dffdb7be75b822c22f3bc4f3bb96f80f7f70f0aad647ce096fb090ca90bb9a1a308019a0c245db61cd0e981e4675f32dc8a77219a4d40daf20befae32aac4dc026019d8bb25b100db6df8754a1b010b39fd9ccb6b041f337265210eeaed7314dad6ac535d07e76d68cfd4db38f918079539ffcd5813b7d9b53dc16fc15a881757ea782a2e59938df5d464c119037b8ffd1a28969105506d1dc2655063452383d71a04ae90a3bee618e9e7e88845889e679d8d09cb399c2cfba0394c2d53819b30bc192902bd9a45f41c4049443dbdeed9c537dd8c966247949255f9235ab5d0e57acab188fb6e31ceb5713758eee462e66411d04c153d011b91b44e3afcac88de874ffca25ac9c3170f02c28822de8053d45db1c52d2c05ca8f650fcce4316d7edb68d1186a1f4db18e1be25abacefd4bea13126f1421fc7058e85d380aa2f5db0b8459041278216123f23ab98a6c7a1c857d1050ecd5023d5619f43b435c6b52684f1d80e63bce89fd65aa248d86b74b1bdecaa4ec82afbf6993b776a9905589cfd71901aa255daafc020ad42df7cd45001cccd51fa21d6dfce1bec80aee926019f880af38ba107a1e754c5d097433e9b8fb1b45a9bb9052a79613cd2044a4a5a03a6ab6a2618a57f1e6bddd4ccd7d1ea0252922337fac00eacd754c9643d75f6b92bc5b1a6203a121c640e9295aa92eb52caca3a424bf6222281eda931883ded2bf3f3eb7946c63ad74071b41fd0706b641d457a4ba57633184215d47de36ee628e0c4313e8236ee4d3f5ef51d6e036cef28c94c88c9b47daaec1c33fb2bba07a944821d50d92fcf69678d8065ea499de4922bb62a7679296d6e24a7fe3bcb8834dce0a8a84de4ecfa3d74985135f0eac22675a0125eb6682f85a83dc465ab9795dcdf5d15185868e3523d43a407de45cbfc4dc4bf0a08e947416dc27f13b57746c8844e875f49353581d2a59a582c13f3f4c294799f2a3351740eace05a0259b8fee5559de9f12bf05096fc5c65f02693964d92fb15837ea091ea790837403af72fd2be642504e978db411a8e8cc345e8c4df76e6e734ba76220206a7ea26809e9dde3d4f4fa3dc94831ce7a9cebccf0272fbc34b41c0b93ea2002b845e5151d463e3d3b745856048db6d8d6c17f0f94de742b797ddcb2dd33928b51c6b4829158271e8dca0726f1521ed0c7f9565062dcd7fe719e90996296a2e1601fd4b2d5108d1f39354a9f7345699317fd033deeb8e3725b5bd98d9a9fbde137602f9ea493e1817150308437eff4f806890c6539392e799f98da8e55c17c1fd902d5f38d525d4a177f374762b6d63481e91d46ef66d1d7b1d6d89f99caf90866b5d102e8bf11415919afeffbde028fc23daff2b2409f75f9f15c60f5037457745742c45f328724d170c9f4e6526bea7a6bd619faac77d3edb0dda0a8993d11138b3b0cebb2a76b0c04779bda8295ff013f40e0ada56648ed174017c29c0b0afa7726f3904ea47619e88467837ed9e74a21f872dd08b3ecae3eea492f416ffa7451c3ac90165f13887ac01c35d07a1f86bf1f3f15fc6a3367ccce324523ba0766b44a71ca8fcce79414f6a8b8bc2b6e57f1ac0e0873ceae14df1e20ca3dcf0d80f57e02908e8e87d14e10003a4d457909316884c0dc290d3e04ad0bc7d4e83cf64556bc7533637b828abd4e0da95b808c1976be6de284870c4979d47bfe59eefd213de462b7219dd21e1f22f490eab1d8e5d3df4053d630debf6941f2ae551bb7937d4b04fa7487c0afe50d52f6fbdf88a62c7158c3f371fb3c874f3fbbe2068319c826145213498dc6217eafe2f2e36b141d8f3ba9bd8f47645068342c7d463c3176538069dc6ac94061ca6b13dea8ecd323d1b5cc6b0ef9ea3d01831d63d0a19cf926d43f99f56ff5e1a214afb1496a61e7b213bc54bcb0544a79c09144a5e2d4bc0f7515a62496ba9cc120a70918a6057da8bb7cb3a630cd6fd9c942fd743eb65cf74acb2d7db02ed4a01a4abc7c4541093b6def1fe4b0a64973f5f50a87a365fb0954f641cd4f253e8bb7e5e0332813138d5da3506705ab062077c0483e1a639ae1ffb01b3a6561684fd72dc352a1151dc11e2204817d2bc24392f27fa23b4590fe38c778047af5454afee0d43de22e6117500ee854a62d4a2849cfdb970bad2a33256899974a02364ea4186849c0dca3c2063a97e7f17e1e061370915e6ff1479e3d82beb8fa015c23ed2141321868269263ca7bb410fa06af995bc3f934bf3fe5cbad4d90c0db61c4684a4596a3f4c72ca12a5ff3d8f90f0aa596d8b943a515eaeb423c81cadc511d5773ad172bfafee39a4715b89d9765fd13552d1af636b4bd5db30c97787575be1a8b3017926624bbdc7073e6d8dea9e9802d2ceb62f1274bb9cf5f7cdd3f47ed016646ac43227ba4b1a2b28724202cc95dcce360511c0007fdb94e8f75ee579142a4f60eb99565ef60b9efcb4329d1f501c647094915a86ed1772dd120963a3fc7618d1be7187563c505d415ca67dfcd68123c6f7788eb7f7087b25c8537c726cd62e16ef271a130128aa29c120a245f7488eb69840de7fb2ff61fa5e27e4e8c863ba3a4a4b647409b336624c74f1bc6509c3666c37cf10fc74380fea1e8652aaa2b4b5a4c1a6c34c6064284023c4518ccc7ea91b482979bd50f962c2a273b5b395c90dfc082e9522728158032d08a9cadfe611bd02d6f371cf7258b7d73858a47e46451155890267d7a97daddee56ad4cf59dd42cee260f98946539a3023c5347c96d48b8eac77f309e9a4ab7aba29973eb2ebe8518ddbb97b9e5ff48b644b99e9bb388059a1570fe99f94f90496f552d1fd36fb98441b0394b2ae6a848c741909a00f31e14a812077c4b7cdc7e0e60ceda2e9c43452ac84f9fe2f01aa01b7a0d3f2a419e93377fc20d6a19bdb2b0203672d61073c865987c2003a9e44a728176522c8805d452a8e19730f0a3a365fbfec5dc03e0e59f7ce7c6c72f90c6ce2e2f93b85640456c6909866715ca60585232dc1abbffdefa9af9599887458a5a87b8601aebf5af8f36e0151b2cbcbc708d5fe9efdc1c06239582b8af9c2ac4d215cfc02cb926db0803e37b32719bd62f928d9646ad1187a643eb8a0cb4711bbcaa27e5d34faefa5d2e2fc0a498e4b8a1a9e0da7429bacb4b3026382f658a69cae670a92e01d16f8542b4707558bf4529c4543149c725b5c965ac49345ca3c84c7b6e8b70ac659e573513ebf31b88f5387ff687a22fd810edaa89c296f780634ad8c4b229bbd111f26bb096f550020f8e89cce90279662e091d274f8bc87b0dfa63b53a67fa3a38316052eaf90f234164bbc88d62c45196a09a6044376f04ef63a39933c10058c0aa5b21f4e18219285231ae07157eb521eb2d657f3bca07abfdcb6a019bd2352701638dced9f38e0a1ff804fd08541fe34ef2dbae79aca19686adc57c85deac46766f17efc0d6f7f02481cdaee0122b54b59ffc89a8208b38913931ef636d4337be77a9ffaf95bc866df1ea6675f7f1112d9d835d623c96d058dab96b18540cef184c4e0f336917ea2ed59f70dddfcc301f52979c2bb7e5ce26cee03f55d463a99ad3361556bae91bf6b5454583cc7bbd03290a6bfbd4117ceb56e069e59230c1fa8d8c77a3f8c8c4232432b8cea0a206838cb518c4acc28ec1b0d488354b776091d8daae1d01e9377f64ea7561e5454a3f398858246a8c562e1555ea62d7e8bfc5694569fe4b8de488a1aa1bc41dee3d3f65543b43e705ac9d83e97061b1feee1c50e26cb0c9e54ff740fc629303246eeb496a45615d9616d28de1b5948539880f0a3a38a761a9b6accf5c705b7e9272f3b3d031f9ce6370aa024210a7ca5d8165a6bba68dc51f229f0632ac912721ed47fc97851b5a93cc2d7e0d74512e12110bcd7a541ebe2924dd61f46a67f437b7e67f9716d29f0af9eae731cee0c75c9058afab23a85a9ea6f61ff800fa02b502868ce40849ffdfc684a43b336e80803c0a62c6a4ce7596a1ffce98e54833f3e9560e2088d9fbabbe4dcdd543e80729a79d9558eb4a66ea49576f333c87c8b4f0e318e8d3e29e40e0b9e574b4ca2b211de115add5640cdd558bbe00d845c7b197a3ffb109105773c94a03ef9e8c72b32071318cbb9a4020fcc5529166cec2884df97317150ff036a074ccbffd523f36d7f9c9896d5b843d375841f9d7263d0566e9367059235329a6d61e9e18efe6b0b202efcce5c2149d75e62f6baa2e930b52115edcae174efb8c5de1471bc6cd3a3c12ce55134db430cb709addb7f9306478eb1662a73e4e81609ae3f857adc5fde8f7301ef8b5deafe1bcd8faa470b138f3daad0e91556012a5dbfd7fc5a06c6c16513d9c2915ac874abab50875b4c38ddc3d18155971953d54421f0fcf2b27401601e027565897b0f185f2f4dd60254b2a9189a136d5fd2a155f4c54e0dd305fa6c4c738bb3cf27e65b6f72ca9bd158ce6a502e94606e92ffb7c149a6b87ce1fd3d75aaecadcd000f7a1ce503bf9b176f5e8f2f6b52b023bfe016bf0c3ae7cc529c1e7d86f8047c813984051fd4e3cd99524ae30ec4f8a4384b182225dc7aadf877a52c7ff68f00dc8ad176065fd7106db01260f469f7c165fe5d687e91fd27bd23ec671df0315cf82c9e3c5a33c6e8f7a82666815bb00e2f8690fb39ded396dd45de9edc0876a25f0c6675299753c46f1798c11f1caf3e1d80f5b4dbc8594f51d3def19328078ec2af4d0d0926e03c0d1f832a89b1c055220c156dba29af86e5c4571e3990d66a38cb6db2b326be4ee42db0dbac0d30bce1f1aa55d2a7a29d99a44c0a20f00ba58753c5f30d12a80d9d4b41e4d117e11f8937bfda9faf49ce9ff53a11aeb24b244e33ff4afd880d3f3264ea3e83a4fce6ab269bcffcd9c9fe294ab131e3f3a356c31bd3d1545fb92f6b775d5f1ec27bb18280dc8ffeaefc19dbd1e2fa384e53bc757cb1b96abf4c57be55831e42164c86b719deed7194b0e9704563ee8e8f6cd01f88e5b9369e0f220025968e31040d9ca0317a62848e7f421a6b36145a93ae3449209172bc796fef3e38579a689bd5cc34d23e0ebe50284716d45ac7e2c22466ecb5515fe7b08dd16b6d3ae1b2e929d04f5f85112d31a837c73a242c30ae7d1aca71050d0f2b229a9172245be4619d67cb064c2b468158bd59a08ceead7f8900e61c11c481161de0ef4fc03bc290dab50b07b8c5b8213f7b1e8be388c0d307b14876e3979299a7cd25d3712249eb2d956c08328d6a349f4159bc32e1204fd7b8f9610008b6facc458791984d19b3515d8104dfe6065ab947f55393ab147b732f72435ec58422fb4767fd65105cdf434b5f9a2451407f41dc1c7c514ad014bdd439e024ad53019b444bae20db336f864db40722e065ea0cc65dd6faa8aaede54e8304498b5739da0a30115cba4027dd2fd6b615d754de439c1814a571c082571b1f43c2e257134addd559e349ff7c19edfefb52db8d62b952935ec4389be50667f793165e2c38d5a3ac8ad199d9086f89b5b2bbd412717109de516a50ccc43c54cf46fb0872b75771b6f842d1d0c0ba1e2dd14a8cdf6977dfaf24464a8e33cf7d58e39085530d34b5d1a1dfec867254087c9c400f19fdaa0f163b719135bfe4792bdf74022e6f4b55614e94bfa84d9b73be99a9a4244dfed3a1f9a9264a18d655bdeb21880f0939acc75bf0544a061b90a53c93c9b7ae9884c8cfd520f1001b413ab35528ac8ed3134d57e921012a8f966af76b1785f6351e238cec64be662ea81d7a055d9233b30a794f4ebc5d904ea78170f3806c4b2a34457ca5613b4ed12a104a5b86ae679bd300c0e3d8b2221bad5bb776c1f74b8912951856572a9c12e583dc9d8cf43f913e747b5919af42a402e36de09599345ef8d6bb5c5ecc1c7fbc8c7e8a233c629e63d36316357e9dc380424c31ab92f14c2ed256ec3d798be20229b2b6901785bb6712b858c40d462a05e92a8fcc6c6a9d2c1d6aa9171cd8ecbf127404f7c3885cd1134132def66230b619c14f774e80ba9d692d57948429e900e91d80ea260c5251bd603adc0ef6e78f0a435963da3f1d613745e5d63ec394ca71d1924df76f5f226465e8386f79b73f416725aa22c100c69a1682ec45da3fa398864eb0ae0b6857794ccdda9b97a441c4e6710723831ee66d0617bc5df806d9680b83360ceaf6de013646b715fb16f36308a2c21123f57f89bdbad973aef78d89bb857898ac108228eddb4b7f581fe4a169bcb998b2c23477b3d29619519f04f0dad3f7c30a1e24b6f04b994b9fd4c7c1f9cdf54a02e6abc9da534ec5708f3d0e93100c1d6975429ef570667c9efc425891d8bc521439d7f8143621aa5a6b8b515bce38e9bf2c13a368930e8b487e52bfaeb8c5fd5443b6af8350888d5e5fd519f683694e528104d6a32efb32a6538e3cd24e5630cf74172aebc703ca975b3c3471256e8157c84ac7e6a972c0c33d5f3fc3a7f0837ffd64afd454aa71f4bd986c46c0610a9a842394227866c1da0cddfd5b82718552aee85c5d8b56b19457efa11a8e25b4e9243bd0d8c4f42716478f3d85fb4354a51f8512245ab4a6e30ec672f6b1a0ec564a717637775d73c5fb4eb51c01008b5281afe98203e8389c6050b362f99d95fd51b87bc1ba5a3891a1b3c2d02031e5168bab40890b24fa62b5ffd8d25c204f418cf27bb3827d675cf46b65b81afed8ef1f0f2df14516151b09d2c9ab6a9923f13558b09f6bf7525a60b1a4b0afaf1c35568fa2e374717b957337c39e3220b015cfc7416a30d5f02aefe9313e494672b8dd4c4f1d88b9bc13ea882a68407173727c04cbbb20e38096a8e5646b5a164ed48459a67a888265efb49f3b25f404b4223a79a53ec2547fe07d305d45d917c2fb076806f3600e36bd4b33fc15527270143ae3440e8a788857cadbd6d63506ab2da6a6388258be35f099d77082ad0bb2aeb5c9ae12e85a536883f01c64fc2d50a81f7f5d77b5880c7b84b0f04dca760b1bc71cd6b19d0f5562711ef0f0e7546356712ad2f39b69ca9da4cc7d9122444a163598b4eb636168249a6b4f7ee8fb96ae5944766957d9505f4db1d4128812b7ff5140153787796b8e5ad85a36e67386ca7c92cb445ffd2c8bc94ae28e31dd551f0a62cd27067e99a1ede552cd571d8415c9cc22a609a3ccad761a958974482db649fefd126450f3782e8ee4b114ec2587632da577487eb7b50b93226a4a035f614b7f1f80a15659f65e190c68f8f6ac7883c9f71ef40783d28fe5eababe672d19c6932a56ba9ab9a7bb3858381cc41e3c9aa95309ce3fdfbaf7123501c984c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
