<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9150a6774d4c902710561de1312103c733e36b25ec2bd1b89495890f5bf08a47d7c807b9e7aa6642bbaf861b88cf1f362eb2e67eb6f9897421fb3708d2505cc41b38139595aa80e4d5df1d5a425ccc89a62f323ecdc4ffcd306fd711b09d97e9720f91c0c39ebc70e0be30c587791c9833a01481ad45f01e33d36b32f9ed76ff7d3d16284bf2b3e39125e6dc2fd3673f7c96fd8c1c98d8a54c9d00d7b001b1ca7e02c294d7d3cbf392c51ebfb7cdcc1e763cb30ce70f373fedf241872e8aa7c7dc92fbab853fe3dfc5cea436640d4d2319661aff3186c282495014d5a1a4aa50ecb8bd85441fd4dc5be5427e82b45d90e508683950a02df1758f816d8c1f2151b714301882f2b8e1abf0b553efe244e6f70210397a63d42ef6d3edd52220887528537f14d3eabb52e48f18937cf6ffee1a527deac16118ff8e8e59491251d5f12e91078a9238ab8314f504fd8789ddb05c2fa8c8d3c31964b1226cd3060a0f437ba3ae138db00e7edbc1c8f816cc6cbc41a16c4000da14fb865cc1b3c1a73cb9c8bcce0389cb10ef72c517c266dd0a33afc0a2ea8bdefb7d6c7d18188db740550d3210d34460ad425eb77afec212f737d5f00bb048bd7bca041916d031bc6022dd1cc3a2a24069267964c8ef7bd1d23680d85ff010fe707a8df7eba28266e89fcfd3064ad5c4199fc226000f79fee999395c1e77565a4e040731620a1c4731ce375d1179dda1b04320f14c0d824ce1fb3ea509fc05b99e46438dee1f377bb39184d74fab55be162c280cd8c18d5008385440029fa3b4295f6b1738ced3fef3f1d4903f223d65b42aa559b3a3acce905e165e7d9c7d5ed37f0f61421fa6e2e17e203a94c3fea3f07201a489caa69899118878555a1c212b54c5d62f986cf14732eb10a708e399aa486ad668394d140d1fe85b630b2ef80dd0a4813760e6e1abfdcca40a73b0879635abe469102fdc554c7c548b5049b7c642f111a61386008cb41ae87009d2bd7e3f17d0a4e76f67fb5b7ed7de658f74f01113c451aca8d8ac3a449ed88529a562771550c87227d8012feddc6c6b113e0b69f85d7cc2676109f529e705c9b5a12600850432e1d1ad770034b3ac8433e2fcbd568729f2c10bebb10bed3f797177828798860f6091aa5e488eddbea33747427630fdcd80336c3dcb482aaa28bf9fdfe79117cad5ed7e42dc0ec00791b190d653043f5cc53d1dd076cdd93246171aee118475d7794626093996e242cd8fba66e3925d4e4faa88b9c33c0fd02af4eacf6436eca7964c886380d2888ccf18b035ddce9024af9994ae0baba90b48aacf5f7deaa0f60d8fc186ab695495c5c54b1fab88504c343ba3262ddb6563165704cd1d5b32199f5c31efc9fa06029616e79eaa8753fb651710da824a9d2fc24991e6def5ff8bebe3b7a5ffff8ea5a5b5ca883aa28608816c763f6681635920203acc14297fd31837a20217103c5740928b7e8902738c167299ac99f5813dfb0d0fc9a5120f5148dca1ee5f42182396ecc4582f37d0a225746418dd3c7e464399894470a2e505b3daa26e66d29174c3b4d3ac88bebab1fb0084ac9329c07958bd13a347e84eef1d5b8f887c0edcf57a2bccbfac84d1eba0e8bf2640a73ef12b8992a38bcf545133f32251224b15abbba3514bacf39364d54c345f602f8070cbbb4231c0aba1356bf30b61be1539db4593d284938e2df7f988fb6015c63742bbe28694f4144ed72efad96ba705e10e8a78c0689c0d2a47903c106e0b39b398627409f24c376c4d1ba5ba1deaa3739625d75fb9eade7cce710901831b0e38e13baa33847124ee7b4dae490feedb5f2919b3d48aac317695a91f1776b665ba8fbf3ee60010934311ab32336d9e0ecd8404530c33dc740c6c103603126cce980936e218b4a0b3adb6ad198ec5baaa022aa49d7fe6a0a782adfaaaac6109122aadec97724c4154ac6fd68824ee389784720e1ff787f132b4bf6734bebc67c7eb4cfa228930808c7bc104dc956e154239c391233a2f56077e19d350ba8036ef7720985c76426db4eb444ac5bf126b7cc042eb14c7bf50bbd29f326bcc916f44c6777699be55077defc2e2cec1cf9777ce74bc27cd6a82e7b0b49a37857496cd0c2c74890d71bb3f1939a96406754abd523d82465c7d9d755a55cb23d7b393ac26909fb5a12571c2d7fabab2b4ee2d5906c012795e7126787cae1fead36e32b6cf5eb8ff3e52605fcc62ab9d98ac24663fe95ad1b984dc334423bc8eff86f593d008fac3e6ac7bcad886d26bfc98fbbdf90fbb5e46b5bb77d609022756ab11f46aa8565f50f9f35b1a79d49a0e6c39c7e02fd6777c2768ebdea61f38fef89714efdde99b5aec12e8c052eafbea948935db96389607b43d29fdac72ad716aa18e60a147178f83207cf2f984f6303e95d1728a2c2b5c317942207f722b646a938a6b84de8a8ec73f2e9cdb8f5aed0389ed672e44cf41666cf9262a59031cf53f7f378ce93bd0e363677e9dde0de96f0aea1ab5ed3f822dfc6bf0a79d900e4c927bb2dc643e955cef7e46f9b14db9cf430ff155152e8ff691ad688d0c2bf95254d67a92b7323b55f40ff269657674e5ccae4710e54438bb26a31942671327b6f212a9fd98b2148f131ede1e923bb30aa2536e0d7fa1b3e4e3eddd32f688359caa374f6b58a78853a669a8055b35ad82024ec420eacf1f205bbd5d944b76764bd695389a8cf45d045255b50d0146039f52c05d95a50bda335f2082897cf6898c93265dfaed7f96047738d9fa5d2eaa6d4d8f146b528ec49a4a250c21da90a30101fd7c8e01a7e1ee5620f16b6181db473a015b60922859de9d25ddc3ccc58fb2d1f26ea5d248b69ce727637de9a781dd38129826a0dc8f1c91acf34560d07ea7a306923ce468df0f9bdd63721a0c79932a6ee248d6e32a2ddb54a00d100b618616e3231b18ee16a4b55bdedbb7e3ae7b6f22b7658fbe6e9f33ab211c0859fe11957b750bd9b86f63566ebec1eee7ae16e8332ccd293a68986bbc2ed00e0c5c84bbe4d121c94105e07d5aeff510da4236a69d37fd18ec96fdf3e9e0c83ed632e65c6f48ed53ce45b9ff2958fd93ed1725a9010796332d7afb247b4825f7952c92009bf7be46aca7e2181c40cc633c19f200bc90bf01259a6a25f79aa64bf4683e7040338368c486137af7920f4957ddb49b6f37336f5a2e8e6913e24b8ba95983e89988c92514c4fb32e1cc66539f0902c2d78bec7b36c297e714fe2d8166b7ec5f8f864027f50a4a9c2da8f04674db77eae8607925f0045aa252e68e5aed19f9edc1db9c7e8b613644cc3cb753084a435dea7b6c1e0086f45c162a4b1cccbbe29abbf98001e8b6705b498a7a726d9541947a6c05ecaf91c06409eab0e7996389e54182f659e4ca0b58f476bffe2a975220234495df0298213eeab56b12cd850283027407ce4c075855a549afd1359df0988ece3c92dbbc00f07ab7ccd996a028c6221a71b60d08e6d431784295885224733848cfd57757b4ee09c47c6b818f2af4d8dede33e1d05c577048c128e8798cd22cbef5cc011081e6f2b4f69c83d1dd81fd5a3ead73ca3c25435795c4a93790234493c8a1b7557327669245098b42bfc6dbdb1c0986c7fd63b92f240c3de9a14f9162a9dbd251f487bdcca402eb5128a75e203af754c0a56a0b023c7ada8b2a72de70a2041bdaa34cfb2e0c583445f09186b1349ddeacf18d9ab9763b5f6781023f03d70b31782548e737cf110919fa39bb303e90f4cfeec2a28531bbc6ae0fd39b9983fb3b52d22c668f21c9b89bf2ee097cae401a4fad601eea7451ae03e6272c6dc000a412a2ad2f0be34621abaa15f3de928491b4bcb103d48d891f1bf2560b8f5da1a346fbaef6f0bb5d52db9cdcc0c8c2705b99c204cdd41af9e17b7f628a3552e313673f2a46201fcdd538215e7ed93efd9b249001c6b3e5632362ff7074bbcf9ff6a4507f9c5c24c56c52b5cc20ed2c6246ebb7a98c0aff10c1be8a2411ac448dbb844c9a9bcc1b0fa73da604c1d609d4e7ecab5d57d6ea887d2b47602b84bfdecfae20b03b579082305b1f3b84e5a23647dec7ee6ccf42ef35289321bcd7a2987d47ed2b9d5932410b5fa48731908e21b66b97e65b74468522c0f9c671a9120cdaa3d42bdd75858b243930610e28d8b7ea179aa0aba234620984c71019b951c219a217ce29988cfd9b4a410e165c679ed164d048a29c3eb38b09ebb0f1f00da8c4d09ec22607f6982cb02f16f04bd940dae235719958b18366562c1d6f08ade1d5b519d36a54c6b425e250c796547dfe0246210350d0e63c5294fa98076374f4aeaa0bdb4bee2e237c0b4ea7740dd83a6550649840e400d2a3c25bc2580dd16516ced7855b3567f4326629d26ba88a69ffc8dfd47e1a606699a042eec5436d965c05a0082373a7b7df616f8a36e5357960e3b0b8a0eec1249bd22fe5cb950fc1180fcf9c8dec8c33aa4958e6e178f2d6e8c57552bba7d7f675b2eab8fc63c8e96b86d26a7d5b7190f836acabe31ef43ec87dea2b3d5f996ec952fb8dc1ffc9778b18574e7f145567cbf5c0ce09a53e0f577c658ea5c4fb03490f3cbf755602234c23631f924b1952550c7b33e004215d560b65d8951094602c87ba9f12418dd4ac45e7ee0e779cdd05606ce6264fedd6d581ed3399ec2c3ea0b64948aa95cc1e92b018b2369042ceaf2e058b244e921423f37b622fe47d8c4738df234f25a0850b1635079bd2306a47c972bcccf396f28d30cdf81d76bad51652ce29f64615342f57a1bf4ec5cb64f1c92e15e655fcbcf8e8367194fc0f92069091cf32228367e994c2c3b02bf10e26fa396af2f67c1dc1c5a421065abfcaa7cf3b06def33e1ea37df328f64275e8b7484770cde6e03aea660ccbcd91e73477fd77c96ba87e0f671bda6386193985fcc0dd3205a3c924c7ac32fb253249e1942d603456ef30906c4a4a7c221df53071071637d0b1c185bcc390f05ff1f7bfcd93e9b33dcae9ac30e02b2eeff19e02c32a04ff805b6fd75a263095a1dd70a45c576ad2986a0d493dd6ddd714901a992d69bcd0458a2f3404c836f42a4f7fea8182a40da96e4068f14404d72b854e6d245ccd4a702e215327d9ff335c5816ce0449f4300ba75dd416c80c56fb00338c0b16269ee1faa8b7da00def7121c38851e398d60de319d5cdde29ff309395976a945e7896449ad99f2fbf78cfff398f04e9b5c9fdfc35bb39c79339d935f3143137dff05296e4a5cc15b710508227971bbfa4177c17e3fdd06a91e17b344001b2fc34f00529ea3eaf2f677130f1b3350aac5e43b6efd967214f5ed69bf76ef4db1213561e55ea9e951d0b118f23d97a36dc3ab90a217c2a30cb280a7cca13aa1aac9a07fc5f80d612bc2fb499cdf375af921f12dc5b4adc14059386e7022f5ca8e299757e245057c72d7d10f25351ca3a1d873dd4c8526a915ee663cfd9f441cc2a99cf9e25d4fd9f9c58bfff13c9b748ae6ff665bb9aad4202e85af50a7fbbb08d5247f34b907f6fee6078fc8a08be1c26119d6bfbc22f866c763dac5d9475f267d76a542c232b7aea2ee0f1252c2edd3ac0e5c8a9911fc7da728d999217664a65b4d323e38ba4cca695859701da49e9e516af8cb2e631a29805a4c18708a00d91041f95405ecbfa727d57b9d78e3d7009f78e967ad60427dacf171cbff0421d3f7b659c047d87179dd477b4cc4431daa51427d785ea30e8e40b4d76d16edf2ffeaeb344ae94b6abce19a49494c9dc0549b3f01b266e4fd9727b25cb98ea8b1e2559dfc222bdefa8595cc8181052a8a85ca15ec3740e482e9c1b4ebe4cd6492b9ca0e5173e22d7fb50880766057f2e9f6248a6f5988ea717f170d8f4c6c7344064168d8d676a255c32ce373736ef93f9a24913782b6ed002a603e66127bf5e99423c40f5cea5f4ae16ec30c0d7ebe2a0dab5b06c6849733cca74f817bf782a83db4b8443fb55a4bf6fc1934c97727fa95cca2dce9f600e1ca891ba81644a30731200a15d2e288b69bda268e8e7f6dc1bb9277aa1bdcbd5d6a6a1b9519ddc20fbbda1aef6e83087a5e52cba953af057cf513f83283741bfa4a84881b688bdc4fe6878c401c6d8659933070fc3efba4a1681a6a324a693fc32210779149e2e12e3d9697bb343b923e91dbf3fa1ceac8b2ec7befb01a7f2acb4e116b7082f3b93568a7a0ffab3c6136d1db8795f530b0babe4856b4d5c46b0187d6f0951746dedb1cfe27db5893b05f7030d11205dc7ca793db810caa6dfe753cd65e62e0067be690e13cefc666d346f4a8b10583a6a9a925f1cc55aa31d41e8acd33c2ae4ff22fc1e998d6fff552d181375dda7fc2fe3c9b715d744cdd3c6750071541518bbb6706dd28d2c74c997a500058925a70e2e2e9a19940222f563075b38e2abab4fb4512e2368b58480981a01dfcedb5c8c71dbef1b0a04b60848513ef770a89ff6ac1b1645d5a8a35d1e5092a50af8e6a4fa97af598899076e787fd3c9a5bb99b7b8fd0ca7d66e87a82b2c2ab443e401df4d39ade9c87118dee8b48b4069def5d975d171bd8591b42943f54bf1c7f761c2d706ac4e92a358f0eba29881c05c946de19a980e069b95626db2f19f372f7f7a96ac1b15d61581968d82381dc52ac556d43f5af95462d4817861c7063baab80370fe9371298d04546ec505251eddbc6037f82fdc37d1dae972c4a853c3e230f128fb317bcaa57bd66e707baa3a06f83282d032545ce372085f2bb6a3a792b92f38f77d004338e58d7cf3a139a55fc5d3696e9763810fd9159fb724dd24075d5c12b47d1506a7feb66f442a58cea75d4f9dae4dbf85e19854fdda433fbd8b58e5a0179ff3f12f91b28bb102cb73011c552d6f93b1fe29b39eecae69e22ed4658a19146b283c37e68ac856dd6d0ff777091884cf5ee75f4099d7b7b349355644b3e18ab3adbd8f87c0463c6f1eec6a86d4d01c36aa4bbb3c5d8f8fddb9e1a5391c42fde68b21c265e37aeb07e1f39438aebd895156953ee60c34523a077c3b673493fce00a9e32ef2d28d66de5bc553868316c8b9a7ac0d4b30905a82fa03f315401201b1891e23b884556731a63ecd2a0434b5df538f033bb45f95f0ecc2140d8ebfa91c5743218010d6c12e274a53cf3e459f96c3d52b1c496d9157d5d457100b99f2d900ce720211266960e404822f5809f5b9f93e8eb341a3b1389628450e32cd4e92817c95eace9a5082d987492b2a38377338da2d4b488a558c9e5d22cbc10f4c913efe87d9901de142ccb27a73878942093f0d2891cfecdb58c1fffe0c3baf97542171c9ba454f51a66ef886a6cc092eaeb702a5a0ed8dc79aab976b6f77c3ae3e96e5b5037b83030ef9a55f991843b6d5d5d7f719feeec19c48d64ba29b47ab0faa2a1d07aab82ff93f8ea935debf901c6af54e5e3d48ff9f852f46d21999c056df76b2476acff8b7fa3971e6f7b81e41f17f2b2d683a58258740529cfe35e460ed66c0858d9537b5db9f67f90699e8af6d1351fc9243c7c5f8259da4bca3bd1adb0a804bf69d507f7908671356949f321ab618a62ffbe114177493b7a6ca02c4ab40854bc9b436cb49cb0d7c53cf3811b651cafc58a5b2e02a7056d001ba66acca46731871166c2c949c567084c7e87719bb8395b79875de8188b7691644ce1a041c84e1e6487d98ad9e38630ca4c0a255257e086fc2c26ca81f159fc50a1ba411ec755ff4511d6cf184a241a1b8b69fb866fa9151ffeaf9e7d7339115415e82a52704a9deb27af1a376b71962993df0297e07153d8edc88e2a3bb9bf59e5fb9bd97ca5aadfaa8c802bb79b0e84d1480b8ba65452fca2533b962795c97ec17dfca96c5efb4f486d99fbc2cc90774f67e46ba5bb44ab8c0584d84b28847fbbd6259ae7562a4bf7d623616cdd3c6043138c9b80206c7926f739107d24ca911e17058738849cdffe2d46c6b107c9c45c02eb7d3ece8d615686248b6ac6bee6e6c02c9b7994cb33b34360e4cb53493adc2bb17966232e49cc7ffdf0d72db2dbe26580f1ed8817ece5fc6bd1eeee351c3ef54e3e6ecfbb9020ef28961a785e6d98ff8bb6a35d06971090ea50d68b67e2202ef5e02ae37ce095fe851f48b20539e436ff91bbdcb558f34d10b22d02f75802f940008a8787c97edfca3b18a90298304c3391c7ed041e935fbe7696bd0fddb1a79875abcd455aca57ad693bbafae60983ca759c6e139a24222fb4b401e82f9b9f3bdb47e8185069dfbee1d75ae5cd5d7e65a2f40af942bb2a29bb9e251bc87542ee84826fb594000a89c21cdfab06fc5a1aba4cb4bb18f85c59d2b5bc45a7c9087a8f3680c11102fe70a0a3a6d43a16b6559e216844c1a62f550ecaa53ec0b4d5f3ed29673e31a47bb57219233adb5be3d5fa69c0d9c8ec0884fa097034f7bd5bdaed497804fcac654f91ef7ff04bc43f88f9d8fd18be65a0ef66c928ce83730dfae5d9c2b918c7155e330ec1c243ee0462c227654a612ab18f72e7632150d0f7b000cc42caaed8708b2a5914f7d99da360e3df1fe8ded887575116670a9d69a8d772e10bf857775d6bab58a77a42adb8961366599ae5d1e8f8a02d0dddefebd7b4725751071ecd8eddb749b140957693bb5114f08116595763c899814ff991dc2622b322f6e033e2e02638e00f40963fc1d612ce230c61d6e6a6c6aba2fec82628d9dce1f393994484b0b272108a50682cfa719325db92874f3e9292151d72d4839d282a2c15aed9ad492a56695b1e3d85a386d64fa1f83b8efd84df878d87b7372a28efd271c7e00b28741080acaa59f133ebc4fe87c9d94ddb80366149b3d1df43362f6a87b2c417b773b64c14faff50c5cc92c4ab461488bfdae62924004140e6add9293fe7d9d0315006cef09c85a9603c72076ccc2b7abfcf233c04e68bfc1ecec959b4331d79e760c3f0332c1483727898b4eaa4413604049a8ed791ef752a0b136c52bb29ba1cb86267e8e455c0947ea791613d032ce78eb797ae2c324e60de99b1d2fadd0d0f6a6aa6f8a7e844cf1e1da28823c209b5a384976524075afeb7c19a966f0cdff065014cb1f21df3f6f5fac1372adff5e13e6fac4b729ccc429be83363035848da0bae810b4e35906f1e35858e5ca036f143eecb555493717e26df09bd0fb9a9022960d5c4c017b848ff9e3df018a7c497ee9565086899a7a38d0f4c11482c89006bc2ac3b936595b8633a48abd1d72e8a881eb7fb0c361d10e4729554ac95234d9a4b68535f5699c5fd22c271c16d7b605f6b7e8ca5badc208eb11f4ccfa7ccfc82768c8f7c5dcc89ac0be314641be8a855c0f876019780919168cce244a55ecfc3d5dc90f14c19e4038c3552dca2c78d3232b5359566bbddc5541dfc2150a6a89dc1b7477ca6edcd8c8a6cda7d04d48fadde06dabee5003ef58e69bff0dcc65b2161b752e7898065043ed4c1356fffe0cfa58f9175f1fa97670433b32375f7f0ca7da591049c2ae39b24d69ccaa48da53fb963d4eeb41220b369b040f8e0fd58176fefdc77e02e977b3f164b2668527dc4a1aadeb4e8cc3e4a4b0cfcee493e90a23eb895383f62b24747b99a74d4f007ed8af3c5a7998c8d44e223db9929e2ab6c87b10d1ff811f5ee685d89249515b7ff43ab4d966c811bd9a971e227a84e5639b4222336ceb941da8a6d1aaecb8e8a7bf874def8d6b27ba1008cb15fa3881f4b586fe7371f0a70b1426e04728416fe8cae0c80718a761a3a410676989f62b1b73e23e7d1bb3895824368dd5d73821491b8fcde195c282644521fec33dd99c9799d1c9d54ef6b608393e97dec4850b61a7d03c797d84bf153fd2c52af8aed967bf133cb0e54acfcd80054b3b3d9cba9136fdef5dcaeb88bb7198d0986fc1524c677cb0780d7b707221b3b76b34992585025e5b443702510b9d8d78f69746a3998c61da4c4fa8fb4f1b2bfe156db762282dd788af49fda4a3d6c21cfc23c1414ce63a585abef37e8b3d51883c299705aaa4f6271059fe27cbcd3de8c5c748a4d8f6f7c2ab12669b120b236915b4dd6f933e36aeb10a6363af56cdbfd44d0c05c50c6aad894b6f397104ef4b77de866654727d7d3b7423d163a8e9d894fad5b55b2f69d9dd9e271dc1c341d2a4ce6ff63adbbe4a624f3e5ac871390cae45ccc1ae371b2ee22b1bc84f6e59f949f0ef87916a80639472cdd7ca36c24dcf57b3b733591fa33a3bec2fd87c0ea7937e80c75e1660eb3275cef01dd2e92b604c1da9c4019eb2b66318c78e33fa85f994d5effa60515a5f6c9b2a125c740438b4116019f2d5b555c80cace0bdc6f91ccd3d8cf88e0a977fbcf5a20cd763b8707051cfb5c5ec5ce300099e7e07942d9e4dfcc1cbd0b806f2490233b31433e2ef3f6fd9b44599b4f22cf495898b925631a0cd189664a9b523d89c41e1627595e50c23b1d7aca19b5ab0f12df0c17d58013a4c3e8ba906384f5de216ad2daff1f4945c3b24a897523729780a012bb62d4fc209a9d9f7d0bc00cae137c968db07ecdc14baeec30e97dcd4e357598ebbc101a4ee4547413fcf3cea2c97147ca60f11b115c3e8aa260fcfff32adafe54f4f5def4befbaa2237b3e41ce8b63009b360ef79f3fc6af5e0585d8d2faa0eba719e050078100b601787a273bf786b7899c916df0197fcd8d87888e5bd107c37733bcb8ba39809279b11313e06d0472cefeb63b4721b7d55082e9679b0b8bb068b6e867933ba0c5a26d2d7aca7f38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
