<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d63c92d6bb1eddbf1d3930fb7b8a73af185c59b3d310a30794ef13dea456ada6e195c56f746ed6bd7360756a12d01a30ff98e83f53133df2eb2aa03321e7213a10b1bf988e85a3d434cc3d226e0e4ac452de219bf3e2682244f2820c24d8961bcd06766d674386cec2ed0d6f227e64a9656b6449c70112ff190309a42d6f1e8f6e058bbbd94c0a337b9d82e27d6c8fe784e295aa7a109c89ac89babdf8aa20beb7ae6e707c7cdbc899868fab28aaffc47e7c9eb42ead91f51d7442aa9a2805a87f16b5824b05052185d23f5ac211ef5018ed1dbe59399e0cfa0c7327d01d497b35fab7f7b53ff2ee51215212d6e091a46f060f7ac0e5716e22630db1baa3570a2e6ccf311363ff29c61bf495c66c2c7545326bebf77d0eade680a7271d740765e42b4ac18bbead14d49ba649f02c72772058418a6809ea1ef2086d1dad6489228d5bb3f58d6ad05579b1dfa76dec9126f6965033427fe1c376de6f72973eb7ff5edf86d84f6317e8b520f37fa5abaa8c21741ac2cc6bb9d3ac3a43b9a0c83aa8611865723beb32e628a235f3b7c1d69bae23031fdd8c5c6b2cd514e88ce9e5749e31e512de5e215183135474dfde134740d9b0541bec6861433aa723fcca1d91766f8a304f2316638b7992eb74720b2b64cc1a6908bf02daf8331a594a4a1fe09a6f8339855c66574f0035e9f866e5a1759af711b98bc43c7330a0c8cae412b48eba6141f7f84ab43e98da7748a9a090a75b69c95858bb8ffce424ee7e94ac35353c7650cb35d1d9eadcc4cc58a7b29a8df35e0e634b2b1415d47bbe614c8ff72da4f6a8cb653f1fe440be62b3a2712a5a6bf103a9afcbfdd8598df062d27a5742cdf6d621ed430eb223acebd04efe7f613433378f263106d9ed8525928615046943700eeec405f2153d3a419a4f23ab464640ef3b74b22df0c51f3168f07f430562c79532083a556226ecc5d0751a8d8a9dcd10ff8382bf35bed47f3ccb70b6e310c594dbcaec78363ff4873bfc2220bf8211b79e391ea9bc2ec30cfdeab148b2355892ab0a39e77820e94f0a9006e411af7e8ec45178b42dfe205e632d9ee0965aa8f3703cabf163769d759331c89b7e15091926625d1634011ffa757cb71531d7b924625496d645297f6a5584106279584534bc9fdc43596dd2c376bf9722979289225cdf484d7dd4a19ab12cd1ed03f8adc555fc6197d76f7e23f2d5839f4aafcbbaad8abffb8469ef525313187e71ef86082ededcb2228ca0430cb9a42e2635aada98e5aa704098918b3dac0b0944fdb618481fd9717e75dc09586d0e462de4be958124527a12884a4c4520f1c0b889145af3c039f912b370808f2de9fc10e77bdef220fa2854cf37db60968b3e3cd4c85816b00a0c379c4307c48eec2ef359873d6275c6d7512d1d98e0547284232224f1e4a3739e854df3a7f70fdbed6b6f399ca8d32d007103cb5379cf98e4467448e2bc834982c2615df299ae6f9c35e3cb51590e21dd08fad5fc7de728e2970b91f4038ab02a9da6b227c8a3982239c49ac3bc8c0795f92f539ac431460cd5e2b193ec30ebeabae0ee5e23b4b929c82d46eb6d6fb2b111a6da3cc5b27b2aafe81a1d9732bbbb88ee085ca8be562fa40df3c38108e2ba72e67514e96b222229c640cf45fe089ebd2b67d64ca4019287e16b40f9ade97086909012f609d48b4ca54ec02df0599139515e431ea4b07aae6112e9e74e73b77c865e20934143e9820e405db15aedf08f0c718875f5a2e449fd1e265f70e2521d03560118550eb7a99a395317f54e1c888b99be2bd8117c2e81b4709e58ecc58d5a01b93e5895ef34386b1316747813884d239bb600231e1dce385ec086b9071eb566d3fab5c33d736e8718c99d8369e926bf712790eb3962d96f1f0a960b334710a73a0862a503f8d6f7c1ec114e69726f71c384ea7fc1b3494679e842e0919eabc21c7fd620d2c6deb464edcae81e7707d4b4315f52af5467d595c73948febd8270227bd46776e22a4af1c12915620fa4ea5b59c6e3ba44f0ae620e252910b1492b3084eb7fbc213557dedc7ce4032993ca1e58aebc4f08afe29a86f52a9eab48596f8171c594497e912ce4483c248774117834ce767b0bf79debcfe5d1a24a562599ad73bed31fa427dcd631bb80f3da60ae3fa8ddf84618a861033681cdbe07d6e4c50e0ea27202f0bbfb322a7266d9474f994e4ba21dbd4f0303aaa3862e662258321942416ba7dfbf2fd879dda134a5aa1bcf1aeb2c80c576ae400cf83fcb5853efaac8cfd67b8265ecc800f97a6caa9ed1e8cc6370f790b1d93e9bf1a12df624398ca54430b74fb3d2b00dbe0694c77aa9ec20a3a7a49e97c1417d6cb7e025416bfd2b9613e433941d9eefa5f81e5f079f91871c58bc26ef810dfe069571015f0b2d3162e22f7bbcd10cb6ed7cf69cef503a166f5baa2e47f2550ed3fba0fff479862afe648ef7a37ae19557c7f4127d7c0d953cba19e90573c0fcab746638ca834521f97f0e4c5ada9747b4404d8fce9ba76584c91e75897ae41e732f3c210b7861259e955f14407d3504440f0903f3f475ecf579c298206742385c9478014e5c6c0418fd24982d2e5e5b91f09f6f6198de38f9dd743ea356c3da09b4df3c5389e6e0c9078e4539fbcb561e462ff2c6828a2ad80fc89cd5127fb259db68d33b08ee89b4b779becd95919bac86a1e795a5fb9cebd4a16b335c2beb6ee7e1e601ebc30afd08f656b2e8550a0a65e99bc2369166c876467159d920f4c26faf168125043067254db02726188140a3d41e1739a8c5e398180ad767874f6885ce3ec495ed88586fcdc89f187d5b621ff41d3de7e08d45c919f85582d6766b8f0597b15e48db49632ab52007025ce6cdd679885e542798f8332620fb3b892c3775bc0e62eac4961e73cf77dd19f3f4f1a351d744f6063d615771d1553ad44d243d634e56d6f3e41add3cf571b218b0806462ebfea58bd74b224d2a43db09c36e5c31d6b0413fbda0405428dfa5a89202f4f15dadbd186cf5516944fef6921cd4ce431e07d93c919851423544841c9890002e5fba1701517479ace785ba60441fa68497c584058f1067cad175446cb1f58ecd1e90d30080fc470bddac1e2d817511a809264c4f66ef5f18bf5dd4694d0eb84bbdb37286b3abc1fa2bae3a64207ce254583f34e4287a4dd3298feed9878bd041cddfdd67ae9c2f37cbf17214942057884009f5b6bf78311615dffee2d5252dd2e6ce2ae87593cf6d3288b7c6fb85243d100674023b15afe0924b4118f793167e5022a049e6ba8b338d5e5449edc6df5f794fbf073eb95ce67ba7ac494acf97b94ec55e243567851f9ea70661e76e67a8a1c673ee3a1ea20ec4c5207c19c77420bd474ae12a439777853b2c3ef6682110ef8cfcf2580b1d33c1ac350fb38b66471908363d3217aaa9bc1c5a5b104d78d5cfdf33f2dca3e7708e8255abb29d74ccb8074f40691e940ec3ac4a3d061428456bd27f546ab6c09d95f971250b1c64d76518caba762bd5420457994201e24826917ad2fd9a8ea1eaeaa283eebdff4bb69d9ec4cf653914ce33cdb0ac054c2bd5f70b0f7f4ace8941f02315fd6883c731855ca5b65df279292663de4107a51778ebd387e494f38b1ee2fa5b3ac5045153a0002ded314f02b122b59aa014f22a4bf12ab09b7b10caec103f106b4af1a9798d3bd5a708d80182953ec49fd8e38393fdba583c5c58303d239bb4c9c5f7efa6c832f53ae789448ca3955af9910896ce43ffd7dedf2506a1fd47a507515df98b0f5067c92fbee2684025ed18eb2a035fa3bdc4440c2f7f83d99186ff414253787742a42c51dcdf3cd19e142e6cff0e531a7d21ff37dda4fdfc6a75298484e262aceaaf6bf3bafa39a0c46322dc390032208f6108863562b8bc5f3662e56c8b01f631146203b954d405d587c5da52202b6a02374e8f4875b44d1ceb4b9e439c47276f9a1406a24c67097d03b8d1b38aa4fffde0308d1b4d63cca78f201c657ee8c4eea55957fa35b1edeb05d52d5ecc3132eeff32c52a0604f799a34546aa40058f8d7dd9428d6e10f2b4ed491ff9d9308dfa135d53ecf972d2d9d63eb680f9aad80f05be93e302c1ddd6f2aed3d40cb584c267bc41a000332afed40fa9dbded58562654540f52f4e42500f650f130c484d92ce239fe3e6f5c48f4e1b3988a404157e71feb118f5bd1c45567fba6cf5e5adac3f362cbaddce3dcfa45e62ce02905b97e570bb84fc91f781de48fd9049648b2777cb49f15144d079bd42215c130f6886e33dec1de9bf9689d55bbd95dbc831ed0cfc01a4e18d023257b3b9f96ad81aa95944252e3efd51d76d28565377f1765d150972e50830bb01e930c0a31e7f85f531728c3cf262d0230d3c8291f9b2a7751151ebb1598b8bed26c9504dbf0b22ed100602e24fd9fcbe08a6870b54157304715a5ffdf7ad385c333a4680bd163b14341901738fcdc66e55956d0474d4a210897d76e55f61b13b276f1053582dd7c5bcce8caeec294da7616187110c65cb034bd810b69c75d225c4172e7b7e5ed127aedf36e5574607585b3bf540ce7751f8905723af59850d9c0ea03ca072496fa6995f3c65f88211e22bcd9ecce00529a87b106bdd33ced49ead84158d1e3864fe2da3567ee8d71ddae432ecc12936084b3cb141eab3c26e92ce21ebf85d6c89bccb14ec6d10b4a94ce076fddfd362f8c86e8b9412611dfa79a511872fec1f270221eaeff7c95e98f034c71c32e5c4344f81bd836a673c0f3d12b3e0d4c7c67d144d640fcde9b40981e71f6d6e317985a17b3930dea271f8ddf94eac95a2ee418b4b013752acc984326388d6068a8a364b312d248fb3e4cbf6275729719a6684aa455d6d1ae11086ad91c5441f78c55ea5823cbb16f95a9420c23ff3990b45bedfa913f7236e29bb48750b0652d7176d0def9a0a71e5dc04438c256f9cd38268b2b515a76635354c1209566e7029c11613c08ba5eff6e5905f9aee32054dad8f8cade2c114090fef5f5c8d6e5e35b412ace9c72a5b531460c75bfe749772bd856872320d52d29fa55e562d07f99591548a68d65a414f927375edf3eb027e3503f643fa8dde27a174e5ec644ea928e68cd71516170321e17eea7a4c636fcd4cc7d7d01f4169a48b00755ea29542f728021acf61c2c621c7f05b9d27d6616e915bc72c157aa4c932ff0d6edcbf835e22efa02911ab2ff199ef86fc53dcd5f025412f291137dda8497ebb267fb5a5ba0aa585e47b2c2dadfcf497361295c29071529bcfce173693e127094104b82c7d148f52bd405b54de227c40e1f013bdc04012e81721ce0f9c73a3da9ceb7e81ca707f23cbc10a289387cc7e998084f65b27efb5da50079f8aead0cd31e21dd753077d9d45354ac0df03f42448db65da92dedb307225bf3d16f9fc3d7e99834aa18a61b7d47902af0f197949425c3cfe95dec800d2b7925078d4cd5216267122ef8b5b32f03e1c5147f1a61010cdad0d404510bbeb300104d4688168f9b5bab08981b72f73c3b9acc100741da36955a8a531d598cefbda749ff308f89765249ce116c21f8b3736dd87d21b2579cac87376ea10846aeec83abd68ea5fdc3ee57d16bbdb718585620e6c895391ae3e97b353a391e15cdaf73d2c67d0c21acdcae6f741ad4f0ead577ed10e0f9b63ad147cde072373bf918f184fd4fc345528654c6825b9e7dbe62565fac2c75d7268dbf7aa137090eb0c8b65889053218305f594a99b39104d7c41499a2c234d5fbf1bd051b557ab4cf8f965e94b619a9da9852daf12407f74eb1240413b664a71b615d7434dabd096eacc15044bb5437f5eb55764d8098238e73da62877ddd0c08e136d213c9fd98b2185626846b2fc9baf74aa82d6c94a73a5b7f630e3c31d38d771e07a13600c9706652fca21d53b470797dfb9a3c31a7d51c780500ae91c5681b7469f753c9d1417a5b42ecf59f7f9dcb49a83716fa610392a633ad07aebbd1372a528e68de12ff1dd8d8d872c0da485f01bc4982bfaffe6c33d3d9d72c7aefa4a247ab2631014e35c7255d847b636ba52cbe6c67d66dae03f7233dc5c50a9f81b1620f55b97062c161e655419ac5e1f99122b201d35d1c6aed10bf1a66cf22d70a2f50c7cd438a70e2978ab62883067e0ad3625ea2518b70264a743990b5d772531901fafff2507cfddf4c71adb361017e55dd7877478524c84d1a07f60a139a2064d49360f2b8f802aa1ff6484d653f1b0c4c6782affb20ee0402bcbd753276f52a0dec993f5f2c4dca43e3849b33449e44586c15d186979bb317dce45863c797a0ba9f6548eef2b732c7d581af175e19d807000a876c5e3d8ab3344c87d6bbe28c86742f705043f3a9ae947c7d00327f370b9e30d0aa4b1610a892ccb995f18fb54ddadcabf58454c171c7ff398588e3fec3241cc239f1ec7fe5d75c4909e0d8fe220aa33bad6d70a7e7a155aa5bfab442281d60f8ccf86a7991727392c670272edc1c2108beaa06366116e38336beeb00670b42bd7338259cdf6423757d5783ca249daa0b0c7fe12d8c844c83f6fa482f3c2be0980237a3ba601b203a57997015cf2d0deb841ddb6a86eb61200f2971c5eff9b54001934e385fc0d01e2578dbf61eec9bf7c5888edb0662df5011c8d6c6a983c8cea6d2135e61497a20a4ab43e82c649ed8bb102b623711665a337fe368be48e291f075bd67c49e9fa239ba08a437c666aaf1493a3905858e038247f7b4dd7e5f5f4f133a49acffc3df124fa9b622940900977b4ba7f72b0f3cc079219fc72d4615f5b2e964ea9d73502f45cb311971e50988d79ac11bbdee8799312ac18f51bca1711be0ec78deb71aacd07c12af21ebdfd439d236a495bbe26bdbd5cf9c270f2ec6ba5767f95a940388ef850efd683b2c0ff2165aa5d863fc7162273477aad2910de5932c2327365a84516afe1bdbecba059bd1ef2477d3f7cd23459450002050a7ea22459eca1b1d2a2f79b0e6afb3a97d834502efbc09e1d24332f9dae9c4ccb47a5699235fbf048176c1220c114f63848caf82539dede7de4067c47533f0a4158c062fdcc989fda64fc5d591a5a8353030e79af06d1dcceff637586c3103965eab206776d784f6921e19364c28156a07b566e5d3500c908011f2d15133ba4c2191cdd19127a2ce401d7b2828f4984b714e448b90877bb727adbb4dc97fbd42c30d46cc8fd1579e7dab32632e3c3e4e8482fb9a89b019360c432f34693f52c8b2fb9e4791f8ef8b02afbf29c1167692682a84172740e19b8286d44db6cb7a47453472183e72daee97ddf0a45dcfdd6297c6cc042cd6ec5a28c5c785436f36a0d566470ce5b304a990963827c5123076bee66c501c54a8402d275665c12f6f9b133beaf7dd3d2012ddab21f37aeec23d92a9b5c549d3e50e66d9930196d8ae3dddbc348a78e879c35293f300039a52661e29b54c78423d8c1ae2ca88279649bf5163c57aebeaba23340c52d796486969febe2ce9407f0a86e714c7b83bf5853b7bff8855d926bdbfbfd6fb55d83ea3db23f8e2f7758e658ac597c07d04dbd86d71e28168f647641f9685dd9cfe7add4f5f25085f9b62ad097cae347fc7783918f49f47c7563dd008e0b364ad9c095577fc6accefaf1d8fcdc518e285c1a154cf449c687c778f7c444718019afcc3fe4ec9120d003b2edd2297f711000a6c70be287011d7a36e4e757829ec726b920c35ed077bba9ffd39346efb554f64a9fe0cc9e8904fda5f6e8ec727f9cff8c73693783bc78655b29b440419496f7a1af703e9e06bd060b51bebd8f0b64653ffadb731449a3d592b70e1774fa80a0d3c698fd7224550b47fc5b02121a92ca787709a36efc72d66682147690fd60d8d9e3f2209c864dfbabd99ccebd3e0318b8ccb2914fce0e8b2b6ccf24d8409760461ddc533643b114c1bd029074030706f28b0562860a3e7fb7ea6706597c0ec00c540043a73b9c097582b6da9a54fdab4c1aeba63ca0d8b07bc6af4e73de303bf1d61ffe79649bb8c69948e91fed8389d64735a20710cafa5acf1b723d675b0f62243b6fbcbc1ef980447e4c608922f69498dcef8d8bb158d67284d72d60f461839c3b0faf7454da46645a775ddd5dfde91a55051ac98958f0815738405f26b11670810182c16d8aa1e0a084c6ab7965531a013dabb93a10a5dad0bcffee517e1c383a60d05452bf80c658cf12450ba9030fc30f035f9efa07c581af0c570662a8440822e461631e1fd19c9f01e9689ab49fb50c6ac22b25c9b23c2adf54835753726dec16da49fdaefa40fd9911f37b6ab6a206a81b9a9d50803f90b8bf0f93d5e6a5b8281f450f812f2e0bf54779810e2fd5b971306ec6fb1166e9717c06d58e60c610ee742ec34d567d907ee99a5446bf7a623da411d69f589e476fbce25a877a3708d81cd6b602ca47c8552fe7089f463b8cd746e743387d26f7403929892141b9c5e55008d81dff748f5bab617d5d0f491ce91be82d36e1338bc3e2576c3e7691251b422bc4f91e941f2a4b1f068610b1770fa2373dd71442c1be1a6c30d981f3441c8c92fa0fdf310e929e3e118e0a293bb67f4ec1a9c841e819791243e91f8890ddf796bdacaba402c27b9df73ffece479f52edb8713d097f19de660a007252f1404f95e2e75339e81f2f73e87786159d048bb3bb9baeb16389d3ce5d0017eabcf83a33235474e2af4b22e5854f77e309a8fe23cca31366f36dee82ce6dc9a822d1e5b023dd7f61b6edc46f2ab72b5ef2424e8b567cda2854b2dcf42171bad7cc864817084ea1b71c7a683b8bd862e400be050714603ab6334adcec4ecb97d876f474ea60c6b0bddb74770962307cd1d2d6473000c796e00a1a8838f9ab3c3ef958f8d0ea2ea8f64e79d46f90b6fdb107e0c6af9e7c7e414539756f97b7ffed1b2fe8756b7263536e36c1812ec32fb2b23726932ecfff732132044e04822cdabe2935f68be8d1e713d856587da82768943a35cf8495d22a5c3375d6d09f92fbe1ca6b5fe792847ef65293bfc867df8b131ea679d8c2f4d9bde420febdee193e54149a172d05b4decf49d840a389765fd3bd52cf1822ddd037a13b6ffec28964c36f756f5d253b225b1bf9b45d865243d4a7bd925512d53a5f4d3e593ca3be3026ec3ed2472161ce3c666d383b4556fb551f5c6f8f16531824ded76557c2b3bdc1407b9b83b1edd63eb25203483b24bc733ab64838a83548531cdce2ae87bfb553ef79636522036484ffc6d58e36628336dfde5b554212b5c021fb362196de5855bf278945484f0d0f817249a0b5fad8206311b5b0cc104d70cff12a8b3905a1c6489ccb93e5776bbc090faba8f4657e2b19bb1bad263f99d93602f8e313ae26a61a76a6a1f068bc5a20db85b6ab2e7d95257e11ce0d171e15a19972bb726ce28304205e9efb13d9f4ca95fb24825d777820502c0e28fe31a64a390fe1c803d57c2265b36888f955142e958397515a5afb1d3b931cc732f2236d21b743dea00ec3652c8c6738d4bff74e8b9962f0de35797061400287de5256462b6540019eef428fbd66d082db675e111e95dbd83a0e249eceeef1ecc2a293daeef9c2a3a93680e177db41278e86cb38adc324f56b9024b4f662aafd30c6fd3d39cd8757bbb6502ef0835a8ef8150d00e179dac6a35d85d26a9e5d2af151ee6cb8360a3d053d9ff422ff00c4750018636c62161be39c1fde1ca2d662573450db69befa2b053023adc968406d0834609773581e554b53cfa75b143182afe35b1b1ac9fc4be3aca5f4749a7ce355824a8046420200be4e29aa1ed78ea0bdb35d6ec86a58570b1445f2cf410bb130c69676c6e0e7fb64dacc0555cd3de889a21e7a142a42c723a1762ef66baad75e49cef0a7ac05df18ff448d84db569ac5fd5789462e8fe8019363fc6ab37b0a36bd129c0ad4bbef18f7ff23f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
