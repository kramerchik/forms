<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Авторизация</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Авторизация</p>
            <p>Для доступа в раздел инспекции Отдела внутренних расследований введите пароль.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51fafa313f3be730c1464b51c9a546c676fed7dcb58fa5532f2eece53a3d5301424e4c1448b38eedfebd2df5a17a17773c65cb97f996b77263e82b6b588969dd2ae1158dc76bdfd9483babf0e038da4b4223dca6f0f6c185bd460fb03337bc8e33dc1f2bdc19a2c49bfd83a2051b7220a6b5a5905215bc16125af28b55a85c822eb19182c6fa69689576a8b33320ba5042e3f30eb1ac29f13f876cb4ba4f5e7a53c6c6c9fcff3a42b1352f89600f803a220d04d780fae4e9bf4c8742031d60bedf5468a465b46903be015546d67cfacc53b23ead6707eb3f5c06ab5a05a96c46c6b7f6ff6b1487e8d3a362b3bf46b3fcccb742cad01029cacd763e23c3a8be587ecbc2bb15191349896c5aefc35ee7f06d86d892f55d8f43e8b959e8017b8fcd30252b495a7bfd1d2f3462fe38f36805698066ba805ed3253b725b808be3345934bbe39e658a8df02659f6aa9aab1008bd7e4ee5a3a45408077676c32390aec98e5b640c81ffd57912f8139578bc484f4ba47708dd3a673296365b80b306db5d1c6e6fe83159c8a8e40fac140ef573adfad21b4b65838d13357e7577bc134b5fe3caaf405f22f41e56cb2ebda812669202ddabd37d3d2d6c04f794860973295be407ae6e5e3531c70a86b6080b2d0e76e95eccc2cce56101fa897cc2e649886e70f6b5798e34210cb596cfbd574e30f66681ea378f0158e3b154c985de78f252f6c350b1ecbc0d20085d964cec800e837e35e4789b3e8cc2d4d2adec196059286b72e5c463f49f7094fefd54b8b966c9994e0bfe9e3a561e97d9c78e9ee0be95f56af8fbe3dcfaa6db79568ceeb802f06449b80afc9cc2e838e32e576265abb56922e63718fc7ed0c1604787126be2fef82d011285dca4bf565d4e21ccd9dc40c18173604ea65c3e6d8bb763d769ff7523aee75bc966ef31a6b5c4183375901a5e6178170af91a8d9f05ed1bf385978e2b2c18e878f9bd45baa2b2e1948d6ba713e00eab7900ae38e02d7f50a94348cb693380417ee329446dcc23fddd18eaa69b76f1f9e6566547aface4c4061651a0b80cc291cb7436fa352072b97a68f9f5ca7b3783a09763516871965fff680d888979e2fc9ec94cfffcc013d41fc4f5798f950a2bfcb76f06a12b51e1e357c7a121dd320ba46a4dbfdeb0fd5f6fb9ba4038fffecda56b1378512f211036a4298100dfdca61e86031ff521a8154d0367cf6cc9522e45476e6b8b1815b376b9d0091d1fa3e9a57510dd65546fac0b4a4d73455c75ac553c713363512abb3337952817ed7d79bbb250c5790ab98fce55c7c0603c4ed0d2e7b5e656eef4de3e0886dfe00dfabdce0b0ccfedc7ad5547ab283278258a72fede0c069f58ac536b7568309f8eb257d576bd7dc4a5ce498f81b9756d89559cc671ed748512815886f5f6297bed6694fe81a2f38ebc90b01b36cec8075e4c3691390ba0f646ce805cbf96d22c4ecb8fee2b75eb8a68983140c362a364b091815c6fd5bddaf9021f1d0475aef9cf8fbb381434778503bb7e35a2d5b6a9d209ddda50e74e5ffbf9fe7bd7ed11ae499718efed95324d1afa9a287a71eb8d26e30129f873bb131376ccbee5351b4cf523875636f135f0266c35f435836aa0168ff81e8fbd3272a3a80de754346df38558d92100d06ec08f691debab564890d75bdefa82219bf208caac6c3a7243355d9805de4227e79d0d0f2e77715c41776f0986f484bee4f5ca11f51d6cd1ef0b9e516ebb1885648a3eb4e7a6a6664c37a2e4861a375f863896fcc66384843198c65c1976b3fc983fb862c4d69959613aa28a959844c46e7fe8744aad89c02f0bcefc9269ae4c1cbf371bdc41c6dffd01aa42387bceee6b854eaf3bb6b1a1aaeade7859e0e69fa3bdffc74aaa3cab4184d438fb608fd36656ebd57828041492e5c5c39cb8fc088128f882901387ae28214e361611fa87d20cd1778ddbc248b6d9fc344c2720042fc7953b8ee9c96f9d7cfe30264a59df38b8aef50d2e5a66394dfa73b62ff9389aab5b4a5767341074e9b0914d3269c564887e3ce4c93424d40d86eeb9da711be6b97723d5f9f8a844d324c37fda0e79cdf56d7c9a7e90cb090edabcfaad6fe154fc2abc2ec9849fcc97fdedca709e77dd382f3bb6e3bff9caa87ddd715e610c45c71a3ffe3c514cbd975c8a5b41ade78a3d3d4707ca3c0a32627cca9cfd33cbb8dd9e38a6b65843bd5bcef9333ff27c6e056e3237b4ad63c8cfd9689be1f63c58d162e031fdf19f4703b729d4aafa5f7adff4e5e34178c53ae1d71ecdd675a1934ff1dbc3e6bb963e810ee04a171d63400899f330699afd5f4d2002447ccc9495e84975509d8289eae26f9e9f77dfa8e44b1955886a183274b5b04d128d73f615b76b7ac4ddce4273c73efac4012bbfada2fadd60985f5d81e47198d342b52e75b4a3003ce99909fa0a72d29aaeea1fee9c41e8a7206ce364a985fc3aed1da2c3ef856408fcafb743189238b9ffcf7abe7e52b329691cc4f8758b4ac20d4f284c8618f3cab3fd7bb39383ec8b86cac603d701ef53c15b8058162639842647d2d217656421223a0a1edd7162d68ae119a92267e566a0ff40701fa59cc4e3e44315a193c38e9bb8cf7b65c3ef78f477b30dada0ba7ccbe6f9af7761173a7be52a0c2d04051754bae55a0dfe7a4b08fe1b2b01698fb4140469687ec326c798f12e9c453bc7b4a683cc86a5e95b539460350b4d741c42ae8ac26bd238b94f3b0d98bb8fbdd69944d68b7ed1593ffd7f030adfd1888af1e24a5b40f9185401384803168bf0afa37456b950621d3ab1dd28c17fae164394bbb1bd7f7049ffa3eec1df5eac2004a73de855941b8f229d91b52d137e287cd25e5fec2de46eefa858b11b62ea30e88c58fcbf58f8ca4d11449614d59868c1c84b6849acf55b9b7dd050623ed8bb458085dcc23721be0026fcd36e7656ae0f43fccd06b4139f0b3c14f9e5f8ba46855c48084e06265282f073efac404cb75b4d28be173bc3c79c3f2daef2f6440f8ee9359eb51838cdaa66658c564eb94d368ea6a413540526f25fa788e62d094982f094f0a9e4af12fafa099451d59775b4e4c23392af7637f4c842f36dc22abe03a2faed49bc73363a08237bdcf0af8b8e512e9a221e0062a34af9efe17ac78778545a77e3d6db3d913c1b1cf750540c357b549b00b03f2510f7fb0fc7291989cb597064094cc7dbea291075e834e28ee68453b4178c00ad91e73dfc4bb56d374de05aa0e629e9369222ef02cd9a1fb8208a4b53aed29ae132446708b022aff66cfe879d70aa9f34ae369a71890787afa6d0e22bb32706f930ae50f110a077a2af6f0d93dda8ba2717ddd0e3e45e3162006b6d59ae2dc67db47c6067ab9911a536a21c313e6c883dcb1af988517439cda417850ef97c7a488ee71e4e8b771d43a90d0a0426b9fdb8cb4a78ed97b7b9c65da4f86c915be2143b2629445529e6dcf47528838be05c1ad2c93d9fdf51177f65961ef73e052cc53286ebd8b74450b53e5cfa88417161e8b711fc277207c52e267b9f840737a8d5e50c6f61f8c4e40ddf815d54b3cab65af59e3e5055fe362b900c630c203e3b87cfed3cc32da231ac9721ed13b7415d72c795d3665b123a2666869f0cf569711be44164fbda11cd0c775b317cad8edffae6e4d69fad0eca58324b3522483825152081f89fdb4229963ad2dc6fffe32639f6193f05a7807f7801eb5df03ce6ade78393dba09367b3969dad85866951a920172b6561f2ada015b796e5ee2519f029d2ef3308badb928e988439dea56e656c01278bce6db3b55fe4bed1f7ff6de1662add7f8109f799366cd9eda40a9ba3607745aedc685e382fbe4f5770a3ecee52d79483ccf86b4394c0b36ea20470d306c7d597aa94c3b66747377555b8fe3c76fefebee020b2b439e13a64fc6ac4d56b42bbce6ad9925e5c2ff5a0ce752a5e8a49a03de7a2ab52926d6b1371fd09a46ac46bfc384f1db905dc81855e305a97331984185f86d8c3e547bf81e09d0a30c9749cf5f76a588c7f204bc15d96c2ebe43d0bdd03674f153584b54e1f68b1d910061dc6dcbcab78c89037ab09e08db9474a8a88653c604ea5a21344711953ab07ddd51c6e4a2a695d36fc15d28ab700fb885e03cd403cdab6da476bd20fcdf4c3e938c85b091576f79e9606eeaf336da0d0ffd608c33bb629ae240d4384aead9faf3b5ad13ec348babbc46bb7581f07c02aedb43b14992d2806914059554ccc06ab31bc93569f76d7d0b4c1006bf1214998135de021a2ea9af69c84c3b7e9214c9024f3675cfb0ae4b451598d42616ac493d12e003a593373b35f6682793c9344fd86309b0b550a2b0dd55af61fe3d8f4e22b3508ac12b0e6c87e21eb217cbc5af8f04f81e64c675f57c32d68c08026e14725ac84df1da097e636bf715ca1b8c98d6333a7e4975b7c864eeb29feca0617ad2cc1979eb31f2168656e3fbd21e487e6f2744a3b497e3b2bc5abb3fb51143bafa76a77baa5aca9f4a2f76e8457cd2d84058f94df4df411a656b1bed366939a4714d2b735f7ef6b3958acfa16cd69461cb91ec97b919cabd642dd4b35cfbcc84750afba81a094b6cd20f6d0acfd5ba05673a76365d505e76b99b58000d811efcd9ba97a25d18231b1947034c2fb472e1bf6f412d5ff30f3b65e6ad0dbae370941436777337ef84686f9947113274f1f80215c083cf57af66977e68991485e7e8658b11dec67771a35fd097e105972fc825957b79e2fe158f3b4274bf93b92f81d3e258b39ed49a1329966d6674bd52a92ba0d970dc3db381471995b233cbde7dac2f1d75cbbbe278846e0c6b68bb0ca25c331a72ca29747c8e1185b573fee05101bef54f18036a855cdcbf5d7272bc669058d6006ddaa1cce80296638e751cdda7f7fedff3450f5934227acddc5487afa3675251e76d4bc307c888019b373dede8eb1e19425c1726ea282497a8df68cce550a376b7bf3e8030a562ad34f388e28238ee21ce98ee60bd3da8e272c5c776bf24fb01a7486091468a35fa9b720d9e883c42b1a55bea6f88b9c14689c32a5248742a2d2873831eadb6ea53255f05b13cff28c3317ad35affe423a339af0368a344dc9a759404345f46a760963c40c4f436320d9cfbab63fe7a253fc27b6f83e811f6563307731976143186bfeff99c53d9209c2a4d79ac0d8db619a339d998bba1834a76d7a9c3c4d2db2a622ba0d2bb2f902b94cb6a60e5225c1a24cfb4441d7a34617ff0507c403f2501cc91f3c909c6837f9c4217bda72fd438ee969f0cf6536af6cadc0441969c59138dad7c9ec2371aa77f98d01da7062ec5a7ba4335da67eed1580072849ec03a0a7e843297c244f9fa93a710d9f5543650efbf6afb476d707c51402cc7a9d6d56bd55899b8954c80dd1755a311df64b131b057c41d69ee93ce1abce93ddb0d2421b1a729067238c41a3a5796c289dea0882bb02ef633130cd23fe4c8b4f12fc1fb0d4bd5a1772feffbd41aa16c64afcb39131c536581f0152f19a9dbe17737297afb7949e5b394b6647e880fe9c47e70f80f120a260fa408edd77cfe6109fa145615233835d8e894ca150540ae2d220f0980603c9405157ad6fb810b709cc0767964d30ac9ab554382a8edf0f01972534d73662202870491b309f623e54dd70536321cd1fa6eca0eb6c2d5072c21a2f7f8c3f637526399cd9622e9c8c60dff901bd813643a5fe90bc2bb12134766fcf66238ed2aaa591a729eeba0b22b006b02eef0d2b899d932d55d2c94b1995911d66e3de786f15e1114ca66031622e58e27231cf9b56ea01142913e19b0a48eb2ec2c3c1ecf415da39acd89ce21f72e25479e2ed21a1d6e8fd1e28330df10eba04dfdc76f95966566998a328ff4d16fdf08c280ebd48e553681fe1d272fae4ce0447d5a40a22c46de8ff75ccbf27dc843b1a4b58c522232563a8909cd4d05666fdfa7a86863595ff2d563e32e3236f6080d5a04107bf71f8c10dda675bb74036eafd7b5b61111d4385c6bca7a10befc5f8f973815229fd7a5b6dde753cd88cb1621e52b44651744443ae2596b5f557a523b0625b73f5d2bb364074d4b7c65a666a6d93c77f8842d9298ab6fa353a748b0b36ba201f4af3f53c571f9c05cda27354f78558dc90b4d5cedadf530ebc5a1a03d5a3642b98ead75446316aa3de2ff98b134ca631ce4501c5eeebc3d96154e6f7ceb7fecfc161d8ce4a3ed323e165f13ea7cf4664e4e4b3ad104a511dc9d12774a6bfcf9898f8a4d98cae5369b6fd9bc1369ce243d128e670f951f00f6ce307e9fae692c97b0c69c0b7ef88088ac00b0220f1bad90b47f5fcf3025276b2595b0e008a810566c9492f6ce577b48baa74e9acc1e450d2ccba56b0f19fd1c51a2b33ee6d9d08e42435368d3d7e670014a2d57fefe4b2ff66ac04d42c6058c3c03152dfedad48186484cd5617fb74aa80cac658440e178769a91cf41084590ae6cfbeb9dc7ca6a28329cb0970b0549e3ebc0d5f9d819ef9bcc9030f0b5adc5a4c3a92be7cfc491bd6b845e94704e376b816175ff92239ab18902f7a2627ae8869e9ced1b91bc6110fef43ab4393e721cd16385bff628d49c34e5d48690ed42264c3a1b5690d7faa6d6702a37e4bde98b956cbf02fa1e460e1b490e2c755c488685fa4d8c78e8dbab3978fe82ca26f8386e11d441d4d49cf35355b4b722db0c94d39a5edeaa00de794156261e285c31b3410d861b0f42580dc52e21248512d74a2a6346c4acbd4bd9bf8d3c375183a24c92360c9e171ea1be600649c7eb1f2c47347507e578e13f2388f15dddf24c995aebe768d3051513f440d790e1b2213783e02d2d9f746f5b0e4a2f81715b26f124f04f664919665692d45b0ff93441e982029198fed21dc5eccccc9c7b933190f82a9369773812242486b1bbd99ab391e648a63a36cf99e3d458b1b8bc8f9029ca832452c22155ab5bbbb79250915386df73707a32a21ef0831687a7a897283f8daf35bc73573c89fb58d408f70617ed9c61bb2a1974e9317b30a775c90d795bb52c1978f9276531ad1750985febd692afc1c8964bdc687f1c3128fac4faaa81721b59d5763c524d7a83ef151c9ad8617f378bf687e6c3b22066f20d2864c639214de473327ed63047b9abbd5b7f9537f2aac4e7fee259dbcf74163f483ff64a032fecf0c12d23f04fce09e4d6b89b313d9c32eb008ed4ae69b910e65a225a8991d34ec602c2a4b8aad8174eb768df9a9f9a951229618f2a20870996a296931a6d188a3680e3ae50d8224cf6ac7811a86d5e8c9f1a7f6df075eb87f256d294288d58eb653264e7505703b521f84bf208c5a545a8f680d9996022d9d8b39d27f1c18ba5c018bc7cda0911f3c5eb1475910fd9b9a90e6d54d08127aca6cb1b1a4951c639fb6ce9e6b4ddfc53b20d4801b5e86ad9fec5708467d250903f1b14ff3cb4b84744007f864cfc5b2cecc0af512c9da775a88c30aa26e4f9b2efda1c6b11466289c7dd07fbd6832860c3414889f3cdb3b7321802c3334f31a394c53ef4644efc6ccb38d0ef90780106a5289c188cfa9b6f60ab6febb67638235b931b43897794993e3cc1ebff33263efc474e02cbf5aaf6abd829a583e47fc176e0ad30c55bc139faca7dd024309591eed99728dd6c7a022dd06e9397501d2891a0ab3b497f2404cd32374dfe1d0a1fc4371bc9976c15d8c65167455a3acabb81f2b94847d0bbcc6425d1ebf041f702428f07f1c93dcf16fc70181f4663abde62dfe352d69f8fa59f3c27fca0b935f96b8bd71ef8999709a5e1a12b3e97fb7ca8d2e8e0127710d381535ddae90d19032c8d05df85a9dbbbfbca8821b0007e7326febf2b8b91cdbaf70b3eda0a839cc790c732764f4a2bd77b1dab58e8b21ffd063237ae02c1e620464cced8b98ab6b6b20f71e1aacfacccd0b57bb99e2d826535c3994ce007257bbfca44ed0a087368ce7973c76fe095f8642b381b294089cf623683da21d001c14274b1b5bad18d439482288b54baa51064bc6bd2cf6d533654a6628c2f231d07ae05120512e49b8cf89c02e412fe8f2e6341fce6677ff342fac1b2bf9f726e31f5bddee4e11d2f26b307bfd97e7e3605afba53943a8f8004dfc161c3e947a56686ddabca7e2b9c1d485c3aceef7d14e8a2555f883c22c7441cb5694951a6b49b645055c5f77f886951ac675de5b71e124adfb271237823ddbaa298d5fa3f631bdb85c4ede7c508a811a67b21ce83582824477d703a523fa03d4a12512abe3535c4c42af9d2bc2d3ec3a90b878d568ef7a49028f15f5f2cae01df2b435487a6306dd5b9e591ba1d362723a05cdceae5bee41e0e033eea73c7748819023d1627c1bf0997ed086365f5f64b38301bc43669b15defd433307fb86de001c0737665aab64dc5b164282b1b29f69aaf6a37f92c657b6f03f201c191835b63a5310d1549cc19a6bc99ceb807a51392ed8254f3a69ac343caeea2fab3b000ee3c7f63b00259af511db698c2e252e56674385a748115ff4d6a335ee2821c8ab8bc6bc3090338739f27df6bc12e45c81e15392e8aace6c172c4c1e892553344e7cf290864006c4eef0b5144c1bae8c48f9b7c03e237dde266a67cfea548d02ad016c619962b9c5c4899ddb494e1824c444244104b789141fe4a7b1a09f9d98a6ca64613e18dc6e8919e2012a25f247dff1cf249459a87fdfc733011e6b26e498de9d29260e09fe0b58e2b1c72beff133ecc2517cb6cbdafe856542dd4e164c86d94b9ed054f6a63cf7cefad12477cabad00336f21501d8f2fbe13d657e4c1406d0922014d01dc36cf6b5f8cfde8042e5dd1ab138d2b1ffce1864d585388bdf3a44c2d35d52f0f761eae62f1f9b3f914f8a4b7fcf922cfe5472f15d6278da9f9c64d2775578c1a612dd11916daa8aea1b76a56bb11c4778755250f7e42eee71506d7ffd1ebb99470dc9f7572ffe1d01b9b0332f60b5356a9be3980ac1811ceac32a288481bfa93b8b511cf8681ba1d7da35929b515ddccab0744668c67310585040facbb1a5cfa493850a13fc02a247829851ef066d01dfb361100500199a686ec8e3856b1455d04db31fbef5d346f76810f2a52a173234a4e350c72cc2491c6bb99fb4c1e14c7897a16b8cba6b7c87f1255c87fd81fd723bd321dcef23d4a0564814e87cc50a4be1b28637bba91beb49e76a877c15927fbbed15089170dc98acc8ca53a6f95d07d595240f42979eaf5ba147f7d4567e6fd6d5d57f3495ccced40226791b535db1831ff6ad6a72c3a164be7395bb95e1f0eb044bcb9fcbbcded2be3f6a95aa8063d5eeafe10361c62e580681db75be59fd17eb26c3c33a8bc60f4b09cb73898dfbe72fdc5a012c431ce00f450bbc0bc84009358279ff2afe82a7035bc0e629087d0eb9354b8fb520cfedec1e2e07bddca2e13a2bbc1a789174b6844e040054663a59aefb3af4c973c16396c602a0cc7e58522fc8a96e438479ee9d29125de3529c8ec6a7c5ef18e6b263f7a7d4c00211b33e5b2cf2ccf48b872b5f97bb33fa2971f574369d39a3cfa8c699a38235fe3f6069dfb7a1f1e939b9cc8a7783b84ca2b1318f5512884f5f71f452f64d36139fe5933343d37a38b25370d2a8d5702cb2b2db29fcdaa01836eb60feead44d4911be368b4f64b4d41cbf29e58bd3d575ee4c9f0ff685c0ad1bfda30d3873f2865a8505495fcf572c053235b6f70f9cb35d3c0547d1d2825c949f97b7125141ea7263cb68e552141e2f156421635f287e19639553ef4a0770daae1a1954bb506e2927a7d60477b6d38f8b9a8dc4c10c738c82670ab89a04433182e86504baa0da02ae22b95451c50ea10fb8e89a5d9b4ded221629569d74468700b08f4f64f17c224901b6ce7f3951283a9158c5e27db51deede5b7fb73b0be6c8fc553d7fdb2dceb057455f440d7fdcd31cb91992f7cd3f9f3af0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
