<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a983b740113eb88e7164794029205a6f9608cdcbc5236a728fab24905c540c5296126842f683c3be74e46a533fc798b27338f6189b640d784fece0689e120ff4d9bd352334c9ab9785b940a3992a1ddda06d10a6b2a53185550ed6b3c61a73d9eac5c2695d8e7e862a244491b5911012d2c80d686c383a70e97513280a415edd7c071292cea80fc01a7b3e25f1a511844b68e43379593b97e7599e66bb25a58e0bd60eea23d5691f6dbdae692600cc3c44a385f9e93f05769c63164bcacb007c2bbb26fc3412e4ab3dff1ee951145d56138d655b3b5731ac155a5cd1c6f18e162d0487a801bed326e93c08ce29239aa981748af6e3f55a20fdfe51df33c6b7f031129326b4cbbaa6c2f43a795201906a5fe7789996ab7b5d6d15cf17b4eb5c0880d00d043c8e8bad159866510d9cdaca5004b9992814c25f18c50c730de13af97e3859b4f6cbe2f7e15202ad64659f6dbc393ffa7b829aba8f8de51fc6f8473c0669559d0376e266d45ab450eaefc66d53092370c8271ab75d6525f3261e0de7b6136fe5d56a73cbf7b920073f1f26a99094779503b3904519535f12a887ebb40ef70db8ffaa0fd7904d816d2b9eafa3c2486d7de70a69ed96c1aa15fa19a29193947b1bf1102e849c0e9772df11695fd0c9245fd69dff0f9f620793b0be4d02d154d79284fe6042524f5a04a7e724c46c1e708cde6672dcc6256f935c67f2800ef150941b20d7fbf2a96061e25f5304d546eed25ebcf1c9288c26227af9131974ff72b1470f49e18bf29a48fdefbe257f606fe4e47171c7872fb9300b55668c75f2f41425b8e697fc262695a40012d925bedf4507dd11e934af684b8eebbba929e624bee021df0eb3c3ad05363caf7fd98d3386d4eb3347e4fc9d83e08e9f4819ae468e9e8a0bb49126489e6d0b3f7da68ccb8927f8e299c4949d37dd64284612e6ebdee0cdff5c91d8ac3f498ca272b183631039437130f62d2743afe30f44222c3703398862e036eb551c3485c932f6548d4b11040562b99dc6cfc81c75265ea452f002f3b61a355fd38aa8ddc78a0034a2e4f1e06692dbb20cc0f5f6d2a18c28de41a9e42b23f91a77916dd5bd0832bdbf3e93c62af010d53ab830d1974705abe463c76af4b4a61de1f1492f967c181b92c36a5f07013afb827ba626b5da587e266c975b1d1a9d79f56c8e5d8e2257c555cfef5db7f9575a47e16477dd72829e5ec3d77e2fb0494ea2f43f74cd8567cdfc4685e3e355766892a58e18cc75ebd6e3b0933014cdc15cf1280c2d9a3bf9099dd39abc2d9ee2c881423bdd9d793839aaae1a39ece365b9c226577b31bc74b86e6af1abfeafda4cd11694adbcd454bfcc583d84a71fb89ea03f194e50f02051b42bb0e56b17821e5e82c46e8986d167a3ebf6da30e64e596102228abba9150f631b9c7eb606c4157b241527d217bab91d4aa4122ce88ac62e918a3f47eb3a35906e3175036eb1d6a8f6af37700ee6464078a3a99fc74213d93582be6f2676d80c04e513852391fbb0fe5fc856e6b416f1a32d7ddc75e1d5dd7cdabd4497d577f1ce6e97ad4b44b2b4ef6c731e6064d5bbc6e967846bb0b6dd75b9114802edf33fe752030d9680d1e839e2b7673ca288defe5fdefc4b4a5cf85926d0c8cc83907cab9a59aa0a954ede846d7e47557b1f645abd3823ce1310a6c5d542b258a542926b15c0c2d3c6fa7032f43c19590fc19b67cf88ab855323827e171e6207671fefd44e4cf423922e3ca94603601c9694bc954ca1f4423ea393bd25de292a03acf1e771615b12c87b1b2c269b0a0a7277dddd3e2f3a63b3765e5bb22611126de519f3316299a393758d1a2cfffe5606880168be7e02c6b4b3398a662c244338ad965819ab8bd881c4b008397868e53fee36b3cb0bb9b4fc7982788e9a5dace7ea40a79211cd188fc4b82a10a65719c10b206c5863999162d027a9ee539b52fa43d329df03dfa0d3193ca55b5a68ada1da07afc9d18695f710a238b7d541efc95287df9b732cf87a80866fe79d2e73e4f117914a42277d6a690c04023f5a3490f48a0e370a6f6c653ef60faeaa2594735b2e8088533ff1dba122336bbd8c79941188998512d5d34962faba8e0a3b4fa4a5c130868ac11ee9eecba60c94e105f5623a9ee94110686b846054afb0b4502bc19b8d0d1797d32748cd2ae61cb6a1a449f3386c10ce992b70af0d25bfe92e87410a1bf34008755603247b1ce31856e7a4bad551bea152c6b2107891c818f0508fb445dd8231edf8d8b1f316231875f663e5c1743b2477ba75a9db6d22262c4b48cc7e78c8f22e7d62e3402733ad2f56d999ca8a6a67e5b32e57bcae21059a019bb513c5247f772b1c8930dddecd0730250e2040627d755e0e046ff4a8b4f21b37786007d9f7adaca3e84f160a7dccf0d0f43f545c17282fa67dbab7d4cbf74800470500f518688011ffb5dd57fe08c2398e2ef18bbc3af664bc4637d55fca27162c48feb99c998deae15cc617efd9f78fe5e9340f2471f79e40c6d25ea80852f3ec4ff323ef2f2309a45d59670e2910d243b8a91ea01390cd17b0431b85d71a49008be6d01acb7898586f225e68f0bc8bb2c3aec9cf31abb4d6a7e1b201ddfa40bc1b156319a3fcaf6166b6a8e92b3c64da7d66209377e25a47a03a56eccd79eb9785eece5426e559998f44ce8793f55dc727bc278f08a69a828bb873c613333a76d3734208b5d13a70cc933a33e003480eeac7bbd4dff3ae7518d9a459b61775c2a4d90ababb84bdd78ec41cf78819784af81149fc50302c6cb2781fd0078e1debbb579779e7f9c8528cd265fb4b2b2d53db20c8a72d23aae4ad9eb5b1fc089369d65be20351abf56921f55faa0e6334d3ec9b2a527b992f7b7d96b01d13fab7f223255a99702cc16b24bf8f7027145d10d1c9b0c9f3ab840d7e6873c2f21ca78586961f678f388bdebfbaa24d4c95df6485ac7c6469a547126e94b645ef8f90e43b18a28e70a8c25dce209e75a3898a57f56ff16004f5dd7d36139e9d5c0fd30af7904309c704333bf574cdaf667d52356b06963b400d0e0ed7443e96c0ad8ffac51172ea1930592289678d8532eee5ff740d8661f46818143fb8e8de9aeda1c8c7d1e08d69507ebfd01e2c9bc9c830b20bdbe00c1c12da28737cdabf5ea7d34b7045393fad40fe5bbbe0dc788cff0a8d02d97f45c668c4816f1dee5877f5509b4095041689d81907ce6bd3e22b0a734ba8ef1a7a66334de16b21f6f6d396e93da48560f2b1d9ab0d20a5d939128682d3e3823ceee74d915764a1e006e980a28b970ac8ad28247306ac9a9b857a25ca42c298686b64f8177b6709a5374e91d3752f2d23b049a28094bd5c9784116683ff28dde2b011f237ac1cb4b3a45edcb66a589aeda75f0233e5b3afb23cbd1e3c95d6053eecadd1e31e39b386fb79c35e78f4e57e9f92c69dab18c94306f4e11375856205e2c1eefda42dfa36417fd99ecb8ad0912b8e133edb2a34e51e140009435ac9c48d1dc84f9e4821b55f0396093276ca4e001447e6d207c79a8cad80dfaa9c405f52b6e5148307bcf4fe47d18111cdab04120925ed6c48acb0c010623c0e37fb88509491a2eb3246ed3d17c5dde2c6fbe4a2ade271114bd78d0095094217a64dd233f63e9b6a4aa6f9ab8ba0871374d8bf1642010e53481080e2f0f18c7e9d246eaf05d5d08d4291e47724d91c349e9e5c6f5da9508049bd2a7ec4e6a52943cbb96b57e447556be569d2b61986e690d4489182927206593d19ba8a6f4739761c3552ca28690e512a175cdbaa6de24c9b77af03c06f16c8af346dd3df56a1724b5640b086b62a68255e4495cbe52f0c6efe7d847693dee33b5846d8d291ff6538a43f2a63aa86e34645ec1fb9092dd63d1d6bea3731645849847ad3ae5bd8cf4590be84e549589eff5b8ae482c0aeaed17c755210a9685a88d30b10860032b5b03de30a3addad53ff4637279f9a14e5a3c8491aaa1c8e6c439f77f617c9d356ad218021c97356f9cc676bec002e5fe0be470bb1af6d76d83822cd96e249f0512d7763ab97341bb75d19e10e5ace8e958cc6f01843d7e67534e9efe1e9e0a435d5af7ebd2d1b3bd780b7694820cada7645244abea30355056138f845a0cd7ab7666285d1f2e7e75330331c80f72a71278a2b98c8eac16d989b9cd0d3986eff566dfe30e5b49aeab8355f4e0e20b43204ff06ea5c9c256fca8933ac5f884a60d0feca446bfb2439b28b2003d52f0473a1ff63e7bc9e985a28b9ca0f796e0759b058f8be932a4deec30bc6a9b19f11f98d0d0ef01378e370f7d5bb037fe89c5b91b02246b749f2ffe8dec7ce26d428cd818be65fb1cc95091e3e1c10d704dadacd99938c1982c99f7ef57504ae6884f10a45fa1b21db163fa337f7cd910dd6e05559badf80075829bed902e5bba6397a206df1257b4634eac6f4d800b60cebbc0c131a83d7bd01291b5ae7145d7c95e48b1fd4f45f7f7324113d01032a1ad2d73a2d158c7417e98e61101297b8c7943d5e13a63f2b1a591c002a564ae95a7566a7368b0ae9c1295ec31ec7b012627f0e016809cbb0a89355fdc1c512e6c275245be18df6a013b19beac82d742e80fa466405157956aa31ec3b7bca6769023f37dd5f2776a1d2f2d0c7119c104a2b0a56ec657c8785acb4d69f7868daf4e623f36f0d96861cbfb5a6af7948ada445ce244fe003dee45d509e8eb9b704616b1512222687f8fd3ed6aca199430ef5346d08630c23df29468e84677311f42bb3f59f26d88f7e3a2b240b393b38e391cf7e3efbdae4ff118febe2d622324ce9b4de60c7ae3faf3ab095b699906aaf0cdc695a21f818ec6b8141a9964c942e55925b45b7899890a2c6f3f412472c47a7681e3dcabafab4330c1645e257197fa2449a81c333fd83bf5b37ed9869d671cd57e9c7bc75160b38ef8913af4ed8a1cbbd4bc3de8d4aba60f6bacc8a7ad9aeff76a027163a091768c076363c7e819e5c05edb61dd51dbb7e123be65273831dbb491c9f08e884875f148ddb69879e0167d6679438541dcbec5d3b51518c418f045b80abd2b85c03be45d7a2c232b6641b64f0bfd321a277817b91ee555f3eb1bc1698c86b7044787c2c44039e579b1980ef75e84ad70083ad1f0bffab7cf05c6f67fed3f8eb558a178e163f49dced1157a224458cb7106240466ea1c7b3f5b26edfbbdb95aa33633e185a5b5a1ec29ec31d7d87aefd0a65390de5654ad54021f243c07afd2decce405eab99c993ad9d3d1c1dd9d0996ffb5c90036e216ddd0a7e51587351d2a847bac03ea8555b65f2e9acc566f444fd801910215a60437b36d4fc728cfa253a94b45acfe68a5e7beb7f51cbc8d063c5ce19e91af7b37a1dfaadb31e7c30a40bd6fbc052aaca0b0151e9ae2675b578e58ae4ae2139c71fb6c332b067b03dc895dfa846853cd95f1c72c8328e1fef523c6bb9d3d49ac7ca450576ef6357143d8d6ad47f15b03d1daaa5d46745b283ecc0316e2984050ded6588a08353abdca29589364560a9052e348655fd583f37762794791d278772f13e734d38c0088185185056616ea370e74bc9addc970075d1851b10907953e1ff596225298f31344d3cc889803317add4cb182915ad351f02e33a589f01c93a048c5e3c0e93bc94ee1a4ae2c0d3cf8a5f4aa2105727e6e738d8dd64e5b04647aa4defcd742075a3a1496b9bb7326159c9fd86463916f52f0815c5287d7d25d5ff2365d9e905fe89d6c27c5ad471b7e77a7756a6f1990444ce25a628496297a5b81dddf8c9ebf9cc4b6c015b5f19f0de7c29d34957c894e7ba9cc998c6c084a9e30f562082ba0ffc8ba994352d08a1394f0b52a11d4a41d4c1ed637a9f478daa4baf4c36865d1b6d11eaa7f6faaba67eb2ebd3bd4b284f59696bd5ed0cdac9aa6f86f68d00ee6c8303ec7c86abced74a507a6bd2312a6d7f0d900db995b963f505b717e872aed28f0742a91d2ae312279bb808bbe27700dab0635ee0830cc44e82db5d3b6829cb9b4bf3d840d6a0ea8bace83c29896472cac03461cb224a9964b4b0be42dcd3844f096b8ab20c58a6f7ad7cfe5edf6905de9b85da82b544ebc1dc0f61382b6440913738b5573e8710654c672c3981c27bef91b0ffadc37a2b608c0654c5f906b9d83cbe34e875a2c6e522348df41adfa67dd49f198e884d19dfb84d1afedeae5bd47db15ebf38afb8f8d63518f7050fc655473a7cfb315916a8ce44ebd7bf38a93c2c19255f54a1fe9cf83323906d3f1e9a5a322f6b69edf734f0a005d11724d5a6e4c480916ead0d8828d0741d3be994aca1819757a2e00ba5ab3f742937d4630cfcabda2030c9e991c6993dfbc651e839f99e8c77b3ae0363c955da6c846b566b7138450ad87d577eba1939013602e0ef7a9babcc97114d34e37c0f1972fec1a8b11613225550853a611980e06461e2792bbd8948de51a0c82ce75e769251ae7fa38a5c71ee2639c9ccd6d9090437b2c923fe46607f5cd5b9493f664be552a07f9ca2ad3a96ab8ed92b3a89421910cd3c5c7420d0e323b50a4f019fdf0399cf98d19e3782945b087c36f639802ad2108ed3053dab8d27efd9f4b867e5340aba1c2e8817e2cde6ae6acef70326ce779dbd3bad3c64da25ccc6d7fba5292e5c8310d5b9d58a363bb8a2777493c7f30c62942463320e7708e4326b221400449d6e6c4e3569894e46a93914698b81385623480f1174365875c5e968f7860e443231f8e718fbbb674e23ac22e8a6ee21e65d657de5565990ffa1ca1a0dfd1be9a77fa103dda24efdcfb5428752b756c03903ca8245593a5630acee58eb75e81cdf4e2d91faf89c901a81b5d8bdbb6667c9bfa46bf3d66ec9e08495726189cc319b64141116ff8f460948d15d8ca58a47c8345083ebe0321f096ec2e56580e6a83124d850e6433b51baadc2bb33b22e2b0023258b269e5e1074b77afec7dd20c117371c10aa117574273b7f6cae8f618992220045f2e594dc4ca433bd52ff05777932c2e69bf8138c5952acdf5f79a127d1d13f4d836602ed593c9f6d319e7b92d8a806ac07e20f0ff5d349a3e669c2cb79143dee0bd808e1828d14f3f5fe302de7137b7724614c8cccdd31ad18d5da0dc46d8968e67f6907563c01f236707ba09eacfad2d838b1fc2451be875ac9012afe70844f0fd713a9c985c169098a569671330beb247d850aaae42b233b4ea88dbfd5e9cbc307f387f0bc9663e464e41a5f946ad4b57bb23b494866c2a4bcae16ea77f8ad9fc97ead6f3046dd7cc35e47ee6775f583005218513169561c5c37bfc2407ea4217cb44690a18bb7749649ba98680192faa6f919ea60d92525113a0ce0f4d03b45766c4048f7e97cc5cd7913d0f4193ef10aa8a86e0a5e0d58f18b90762af1ecfa2355ad5106aecde8a206f0844e187d13611a3547f09fd3f69a78cb6d457d3f3a674899e5f65aeb8afe02e472ba373a834f1457b2c1088750b456e441a990a8e0227338584f02c87e9426ccbcbfee453fbce0bc197acf660772a4c8977827cb350b5a1cbb5f3b0805dbbe00f0e709c3fef3034edca8cbac9c755b3b2801155214b8688449865e5843391853c01873b1fbbaf8350c0434567e561f311dcd9db7fd90a11a6fc403d4285732f45fb3fbdc3105f735cf7f7430faf0f602f8da0762048e02f976bc8773409e2fdf6aa81ce2aa4b8049cce629a40dd68bb90583c3361bafe90da1c3a9fa3d19987feece7a6f487cd63e497e0b9e2ced6a1de4db96651711e07875a5e16027c684a959b0c4827cd2ed7c95fa9357cb08e4b03e1babe5bce3fc38779a077b2ac50ccca0284d9d56718d033b0133525dd2516dc941fa37e979dbd90304d3e02d5e5a0cc4971521b84ced350db3cadb7ffb22067ff952004e1f970f87906f01fc0d085a2ac52adc87698abcd943726ea1e7d8a147e2b8cbf6a4c86ff7541dfe6a844e873b097f746ab47d51f2cd93deb175dae4848bc749600d316c428e4563c2e61f7b66f5a394b77335d6ea1ee1f4f9e56d38ab2015b98e2add0b50caf2154ebb8d8b2d156afb75a79f014169af2411ab5798136ef52f1aa31798e3b2c93dcafda458f684e4186e3e5082b98f2bd921e719fc0f91fab94710ceca07691243fe8ce66027a8feaefe65914aed19bf8f427b11a0f69fdb8cf67cda2bded1f9a5676a6f1f8a04980680d9064fddea0902d789f345cd50377d3b2e591efed7e710d7829a7af191f246493bd9c167c21732586ef11f29146705311653bfba4478abe3f65150c5c5e5d13c4e1e594508c37b361cd44d3e13c0c5b7a398e31bae605144f80bc2bfbf61ff720ff93e44555a47818ee79fa9fee017ef258890ba2c7ecdbcfe276ab088b007dd0d9cb427c8505ab02b1a7cd83736e9492143c15d45af70506e94b8a6e305e389540bf48967d9e2f421dd928f0d3441bdafca8603478cc68e55b9f1d1d8e9fb4ea766b32b6278ca1528fa86afb615c79de99d225c3486c52f15463156d9a54e2d2847eaedf5a9fa87dc87fe0e045a8c84c288b4ac4a8650df9864b5f58e88faa5e5ecb2a7ac78110a53fbf4aac5c45d6d1f3684e70d0d8954dee8e694439932ff4ea83f5ebfda1597c2ba4c8c4eae0eb18f9bd059faad53bd5f02140c4438b162a2fc55dd8c13c8c797bbf94a2d7b6cfadfb047f769eb889990a7c1fce5ef0055ef5afc98f0b2ca284975adda9e52b96916a8f8fd4d3e62bd64c06cdf0b9062ba2f64f4252a7e7b562caf926aaae6c65eebcc6367d95dfd594b2a36af60ad69099537c72a4e58ef1c2a131f1929f0208f0a00609875dcb8252783948bd71eae19eadcbb8812f6ffd6858ab74dc96405e257dce63405c029022a9e512ccd63e197d0a4cbcd7d43bf866607214b1299ec49dbf68de2597621f3f7e8f98afac1baf17b046e069a50c398fc1a9de27f9db2e209a1ea2e8e00f11430e18eabb2392e0788c4cc73920b55953d749606ab41e4b8ae56f549a16e6a948e066a58398ed75e54bf020967f58fd696395c5faeb9996848a21cc5263f413aaa63730fff0ff4acbf2978e4a3a5af88d653ce7afe25415e7413cd361ddf348630be9986efb4edce40b3c907cbccca87fa4efb95384bff7d1e3f340178714a0d6e7476e4a82c643bf78ba0757f1db3da3d22f89b32b870867a828f5558007c23abfdac5c8be31512233bee20a61c14ad02706911ec0412081529a22e03848390252d112c712269f6e30212dd93bdf7344ec43985bbf2cec64d276e4752a7373450e9e582471a74c6234b7ec8c1032f9bd07cfad331fba96a9d18a44c790d19398ab43ea82acadffd8347f300084b4aa2a30dc97bfcdb858bcb2d5c9600c8ceef1ae0f2d98fe12014fb325fb52c5a7e7b47decc3ed4c819cb4123ad73c44e35bccc045953c9d2b5c6d73d837e0fea0305e88fb7b5ca58eae55342a25d579d331bb9ca6fe9078c76d4eec10920b94cc5a476bd096d082a80f7f96e060b0795a9a0fe8e39c27e3222af51606b1cec5ce9c610c401974c4f32b280d5919054501802121dd9efb10ca63ee6faa37069e5c92fd0aa2eb5bfbe99bf7597e4fa6d604fc78fd052a9bc58e70c1ff703d7b06ba14de978e7ce8d48b922d9a8a3d309a513c1014961beb06500626ae85be29eb1bd57a86ea3bf71b7c91294b99de8a54507e26ea16ab73703afbdc72522593cc25b7bcf7ab2b2c85d8edd25444c0b7c090acb9e0a243175694b64bd49cf5580d833f4a5e168c10ecfccdfaf4e840ac11681a73c724fce5581d18a34f8f1b86d7e689b07415ac6d476cff593f77e710611e028d7461df5aae13fbfbc7452d58aa2ee7c2393dd8b79bc0ee702be35f1f931ca4c9a5add433960ab6e5ba2a6182c5937692c5568e1c767905a09cbf26d2d6fe4c71dcb413d2a47e95d89022bf3d1c58c344f014dd01a4482740b76b326b5fc44e15a3f98970c12b3b319325f4d3d6f6a3b877bf9eb78e86319d426defdd8307eee14b2b89b6a9177d18fe616800c329b5c887e065e1d6a2505706266997a832db17454b987869fcb34ad602a8639267426c7531b76910349257772b4ea04feb82ed8351526fc9f1c0b3eadc5761661b6c269830eb9e27c0477eb7ea204ac65618a83bb6c6a5e55b20fada6a4b24a3823eea61365e572164d1a6dddb90985f79fd98ff3922e9b3197c891fc5da49f56ce5d94f3f341ec7cb02a224a26dff349d6ef43741cb267eaf99c7270b93b19dd96966ceaf71ca9f2ef067004e8421dc772be20d249ad26a0a71ddc69d439958ba0a5a4254a9e01c5f4f08c62ecbded858294b52ce379a3947eaf2ec34808f5304474e5831c2027226b50083e75d260324a70345bc7997859e0fcd95df93ff1a6c31ec04c95c7ae8e584dc2dcf344ae83140434d7f14c12819092a9e504c0497c64c898414793922b8bcfcaa43500a08e8c8afbcdff823af33bc5b1f9f146299525ab34d8f8e48ff207a7a7ac729abb73e9fe689fc24bb2ddd1ef773e21cdd6ca114f7d69c3acbde0f40a90d663b744da2580395aa7b01e81af75bb2f414534fa347e106f9c5275638d97e72f36d529371369c584d6bb9dccc67c2554194848d43298cd327f127f1acda4ca865b095895cc2cd805a920cd383b349fc11ea936da6e42169a5bf5187170cf206b1fc9fd385503588f9ea41c51ebb4b41d307cfe834333283c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
