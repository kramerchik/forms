<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <link rel="stylesheet" href="/common/css/style.css">
    <link rel="stylesheet" href="/common/css/micromodal.css">
    <script src="/common/js/micromodal.min.js"></script>
    <script src="/common/js/utils.js"></script>

    <title>Генератор личного дела IAD - SFPD</title>
</head>
  <div class="form" style="border: 1px solid #0F283E; padding: 10px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);">
        <table width="100%">
            <tbody>
                <tr>
                    <td style="vertical-align: top; width:26%; padding-right:15px; color: rgb(0, 0, 0);">
                        <div align="left"> <img src="/img/ovr.png" height="180" width="150" class="" alt=""><br></div>
                    </td>
                    <div align="center">
                    </div>
                    <td style="vertical-align: centered_text; width:100%;  color: rgb(0, 0, 0); ">
                        <div align="right"><span style="font-size: 20px;"><b>ДЕПАРТАМЕНТ ПОЛИЦИИ САН ФИЕРРО</b><br>ОФИС КАДРОВ<br>УПРАВЛЕНИЕ РИСКАМИ<br><span style="font-weight: bold; font-size: 25px;">ОТДЕЛ ВНУТРЕННИХ РАССЛЕДОВАНИЙ</span> </span> </div>
                    </td>
                    <td style="vertical-align: top; width:26%; padding-left:10px;"> <br>
                        <div align="right"><span style="font-size: 85%; line-height: 116%; color: #0F283E;">
                            </span></div>
                    </td>
                </tr>
            </tbody>
        </table>
        <div style="border-bottom: 1px solid #0F283E; padding: 1px;"></div> <br>
        <div style="padding: 2px; background-color: #0F283E;"><span><span style="color: #FFFFFF">
            <div align="center">АВТОРИЗАЦИЯ ИНСПЕКТОРА ВНУТРЕННИХ РАССЛЕДОВАНИЙ</div>
        </span></span></div><br>
            <div align="center"><form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Войти"
            /><br>

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Запомнить меня
            </label>
          </form></div>
        </div>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dea617ac3aac1748e0a2369825d11ed64da6366c1c9e2d0644b17264065dc764094651205a8ec6919f02b19bc5938f7a0caf75ee99ee5c8a9fdcb541fea95cfff9f9dd6b7d7856d3f159defd456dc229edbdee4021cceace487073a4d651110c1dd2dd6fb6bc192d25bc36e2b950ce29ec5fa0a5b2040321f861048eaff023711777f3892a72a22f10cfae84e96a9976591098963516fb1da022e351db93f56f092de5be90c6b9f4292d478f24899542cac23fbb7df10e12eec0142087ff5002055a25137281b2c53be0831930c66f42707f7fcce8abd26cda343dc59c71b03f0edcf9fa0fbe723cf1aaf200d7a1153ba912181d1f409b70b687db9be6e0f7abd20f5970ab5c5d6f4cbc993e5d2f1aeda077461426813fc062ed95f5f6664380f6445ae809edcedb46a16b187e186f73de03972611ebec4597ea856771ab519b1896153fc0eaa7bc4621eed2e77eb39038df64439ef4860b44320a9fcdea7652d335150d97ca05b1025d1bd8cb0b501fe3de09c68556a21b085c0a2e2f622547bead9d0f916322321643643016c410863b700bc3c8d66218673c3c5489eb640e50dea4addfca25fb7769e12172ad0d9307a95775b0566fcd0f38773d9458360c9c4fb552360c2be7ac5fbf51efe8cb2998d9976a6ce5169ab4d9615c7c6a11cb42f187a5a798a9d5e8925d97c72882eeb0ec6dd21614f0f1d46ef7612ee157997e923813f992c05623783f96335ff7c7464506050b40b528f911d2c1db3af77ea9803a71f5dce14e847386ee48e99004b41acf43e3bec260eb30ce25c61eeaadba648b92eba06d6798aaea9c649f33ff25ac16142e6da7c9d961658a91617450c026e4ae5ecc2547ea53e3d2c8b1017c4aef2734121bcf0a1e1c10a8a41a6b9d004e4964a1ae3d791ee4c03ac5350fb72215d4b0498d46bc1d26143b345be657c9c0b6a50bb275eca7d0d83975f9373c8e473ff3e48e6ad47489da32d2697c3d6e25488cf276444ddfbc080c0ae7d3c78d4fbe1427d957aac79ab2c514133ba781b45660af64ed691dc068e7b03b07ec971ebd052e6545c28605011bb67ac0a5b60daad940b78db961d17a7c98924e2f5e020d4f8be265db490b1f72671f8fa963752112a58924b4a7db38f6e5cee296ae4dec56a6f46d2266afcb44234bd5d79a68a5009b21c84f1dcb1056e66bff09570f7bd0c21251ca05bf17ec554d0b05427dc4078fce3a9f148f3c8a9b751e248d91ec6645a42d532c99f813af9d8429d056816b028df536013f8b26adce5c2178af8afa7a4d26c7353ee28c91134da54fe3b91f66b53ea92376aa677c93fcfe86f91322e7f8d7bba8fdfcab38f77599423badb4fa6544ab10ca07fc81a02e7f10472c04e0ee6b04599a9af24b89acf5633be6fa92e98b80d08478316ed863937a5a0ec868a1cc6e70022c52dc529956da33bf05d1767ec02c06fe5cfe2254f90db6783e4dc0082bdb1c4f4ab74774259a222049f78f50d456a06ad2ce9e3ac1a8f93be75274a6659eed6e1f649e8b75329a7ad3b2a4fc92a84c8f686d261ff638b4e66681e7262a2ca92dbc3babfb1b9abd92bf37a6c82a26f66cc696fe505ccff50415167b8b2af8de55d45942f5878c745e2521e43d65b4109306631f0e2091a3df5e193511b9c31df343ae7d1da728d2f848fe40a03ec35d9b537daca343f4531a1e35ed6912b1bc4334bf820105f1860ae61430a847adae19f15b97df599af3f7a51a8b3cee6c55f9f145c6dee4d18387100e277e5df6d0aab8c9ddd0f199ef8cd9f3b615adbf1d728a74a95a4d655d4cb3b65e3abd51ef785422c78ec002119f24190669692078823013c71ca5eb2ee864aba5a19d15a1aa5ea62590e4609b8be0cece9766c2b06d395e09c1ab3ee1f8afcf026943f5c139e430843c14045647e41e58386f6a682b9ab15e31842cc066fd0dff02aa8b992593a7140a22fb901ad27c52f87aaf80fbcc5e9cc130467a4df6823bbef8949e2f9f4b96385660ab225c33f08ebf04c4493bfea5905c2b02c28525b9815fe710a743fc014d27c52140351dbcb60b458f68192e2854479711876a589ff2780aadd2c3b450cf677a4e4baea89d0d7dfd0b561c6594a7dbc7333028a3427f5b4705448f2bca7959130eea642e0cbf300537fa2e956f0a6e5ad9d84984856e5f5a08b98b002cf02b532caf0598a0d007d5ff8fa7d9d2f3a7c29e97e2911eaec0e4fbd956f1876f98f2e4b836c035d67bfe6cc8724bab1250574587fac7627adbc983e752e25c2a9160553e7a0d78fab073f533930eb6ca01be0ab8db46dd91a2c3b0f12842c763a0e2a38700aced3864c911e867ea80372d05cd551170eef33b7db8d810b33b4c2edc3e37a522c2977723a516bc60251eff58db6e2d7f596f855e095c7f3d3f5b719ba62b76c4e309a0b000092f6e36109fd039cc43cce5c10f37d42612ae7a1237a20be1138eb1125bfad28752607759584c3364c24e67af14708f16506ab0f83d28b2433e5032f620bb8cecff1ebf4f20a8ef30a9cc98434493cd7152d783bef8c79aefeed1707648dc0e3e2e487a04be2c501ca514e3645615c00791f605e255f1a7d1dba6e65500d6d76f3d30f7e498c936da333d84a13e0dbba27faf585f777714ff7706730708e0cc9135b227c7440c4a94ef49646ea394523f91362616e708a2573ada9d9f184470787addb2b0ae2fdd794a8a5fdf6b98c0e8c6c1e1476112565599943877d706d57623022bdd6ca4ee47fa0d2b3a9683c8cf5b1e83e0d456dc33da68f20cee7befa96cb9fdb3b5ad21fd5a7db80c3764d4098ba3e268b689be354adaf92b1deb635cf7b03935681b7d8e410bdab5dc6c338b42f91c81d1759752524ecfa10b6fc30ab8122710c2e8038e4730bf0c2d03af42b2417ea4a9399f2bc4656171374051da3a9744824853b8959a19ba9b9f280df810b3e0923b0eda110801012c2ab64589d46fbce0fde26726cfc6eefd5641c9a8cc8d93f0b9ddaacabf00d9c3d765b0f469cd5c5faeef63974dd36dda580c69bddf5964cf1d16e0299f657294214c91a3d433fdf634c05bbb2acb830ff3a0232eadb2a746f6d18158568f178f40ce907af82bd7eb242d8a2e2892bda78fd14670cbc6c2afc5d090d23413451b6755655dbc2fb27024a4fee54bcb751a69ec3c4c586f365feea0ba39d34c75b22a42fa177f5a7877f0d7d17aba0c74fda0d4e5f59112ef1d11cb214a7b2157b725c70716df2f9f8715f4f5b90a4bd71ff1ef95b51d77a16270495a2c5bddc4489a4e31c5e0f7e379902297544c205a403609f8fccb7e8eabd6799956eac322ba657df0365cd264eb2ee0606ff7bfaa0901ca0cf73a8b89fc78311fd318413d29679151c05858e5590f2b07ece4089eb130006912020d3766e29e35cf636c17a777b0fe810e180c1458988d627dccaac16dae9f9bbea30eb9c08535861a5ca0bef14d140f140124418a45bc1690e1c185e7374a88ed5f8a36730a558de28485f6b48c958097f3e25deffb6acca3408a0e3986acb956ff6bad2337ecab7f297ea5d53a6f7b83bbd3729f33b7a0e5a61ecc08788caaeb92f3c51366dcd783719175259bc2154f0237fc3806baf3bcf4c46c7ea1d881076a3170971b3cdedc2871635beeed5f15967a0af2b19375b57db9a057c2aeabd1c3df5e81f6270c88c60be09b2c4bc705060893c38bc14a581312559afc3264aa9154e58ef9e1f23543176fcd6b96bc7d704d7850965923e62fd61a774a9ee18e12a4fa7f56b96beaa551c2e21b13fbc18613f75482f1c45369ebd37a5c1348100f08db9172e57690aafa387ca2819893f89d9fdb58e8874db2c10e822da1219b7ab45fcd891635f0236336d8ea8c2bc0a77fc31658041e62d0632b4037cb1c338e85fdbf931d8ad407bc4062740ba0dbfc283f29fed1166809bb15404b625913a834fbeeb95d72486de134c548a87e25884a79d4222891c9ac6379f6117d98e7ccdbb7540a9c5ee27ee0053ac366c77a8456e2213a78784c3973cf2c4e9742cdd1d1c977f5e2b562f4a9cb373298370850c765e350aec91425f5cafed8dc80209ce4f502006c86a3875b7d0164c074e31a33ed3f4e782486ef2f3c5d96aeed4e33afe900c782c7928af4c310ae8289e9d3c6db058ed52bd88edba9e42f37c597f9defdfe4bda0fa3d2525239089d38de783559b379dad01b97c6acceda412e658eb7e43d512d5a18c2c014d09c15fd433ecee1f0c7c841eb1e752dd3e4630da05fe0be1c60df1681b892bb8b1fc1f102464c83715f0b4c9dfa0a602765470dd8ab12ad8745d9c5dd2fd0df58fb3c0077b4bebbc4faa649a8a3d04ee926bcabfb5a34524b4fc0d7efbe4adb41d09260ab4e893e484c39baf3b7810c1accb45186a0e61aa2587edf5f7545cf296c278cf37a5347c15554f040d4fcbbe9ad2404a225dceb120512e80b67485afc5c656dd9cdb3087d0ad646795a93638ff317ca85836e363609eaa8d494929f33feee7405367983db03f9e97f12e3c1c93228313ede4ad42992859fc39df017e07279bdaaed98470885d1acb83eb859ad5e9b8936225ca2b019c6daba0f731d36f3948e316864f574c7efd824d1265d5fb60552626a3cbccac466d790949f27ddf18093f779cd40b1694b59fcc957acc88d9387b25f8d480995af5e5a1304b3be08c331bf9ca1355eada67114de18de11f30ee263224dc409b9b69e12b3b7caaef66fc6c202a17cc670a743838a2c736b812ebf9480e8916a6caabd93cf4308b454775ddd623ef6d336f60932466ae45a9ad76911d6e9e18c1bc8aaac34120cb601c6fd46b2822de013f182076ae1f35f5d74360c3c430749976f7ad8b66e17662b5d3e7850861f890f8459abd99f731ff6de52a107b17702301ba2fd0d8d23b96757458ff16cf9acfa8388ab985ba5de8a4441fd6bcafc2861096c83e4472e6f0e4be9c746f3d98392853b416b459ce694ea6c78adce41c5fec2910889a3b9a579fa4bbc633caa612b7cf53e82d6b9a8f81ef5cf7ccae2cd336837ddafa31f9d711a41456e272abc2cb4050f774fb5081ff2f7c61cfe69b895dba2127c544918cb6893784cc9db8ef4f233b5cedf28189f4885444b8bb4c8d06a23e2db29a347cefd02c9510c5271a37848af88e4a6c736529210e99a853046598053485f6e83c1400952da289a6fba48121639325343c4312d3f6a6ba56a35bd5ce18705f0d4e123e62e7c6b350377a421c1e05dd80613ddf5d8cdbd7cd808c997efe4323e6b677ec2161bb5fbc701bb937ab8c63c707f60f5d3696c16e084f67df786a585dbc91d93cf23e3282491303600cb60167d60d117ef3f1158e578318290428cd3a3c0719aa71604c1c41abe68faa3b9050b745eb37e0e6c339ff7bc85ca914818ca8ee11295f3fab549fbe2c9f7c51f1382305d8b2a3f8d1127b3ea463adf70f3dac3d7a49f2682751dac8325debcde94904d5b50784e05cf4f1530bd5ab94f986b0ad7ce1d56ec2983f0e99c695c846a5fad52e5844869fa63f31fed8f994db9117ca09cfa7a8002e21a1388325bc007818725b468f4e65bfc9dfb7a28472402734287dc9176b7f0a35d76a7cad8f00e1d732af0d3998b31756986a5602512e7ae727bdb0a5d22e40f3b4ed5ac9cb9636ac1412a4865a2ca1bf43fa557571931690dc41e28583a048d653c56615345774269390bec74bdfdd8993bd641834197ae8f91656319fe547903459356a0fd6d47256a9ee9364946f816ae890e2e6effa347834fcb63bf7ab2ff4d1b5b2eae376404e164b97ebfb434066f77a67be7d62d4af360eeb0f6200266f9abf789fcd4aecedb02c66663182e585a2fc754d712498a7ab321fa3eea31143b39a161a6ce28c1ceb4e41f0d7ba67615a28ef81b0d725ba51d29d2b03aa1e012fc315135af7926aa807a1f502bbb5c2789193938a25680f6a62ea9ffc1eb1cbe217ae45fe4e86168ae4e50b0e7f9c4c7edd2591d5a7039fef0b7711b319e79f6ca4d48ea3bc81f56e175581b1f5195d217b0a773e397d25121649a7ab7cc39e52bf41c8c673241dcb4563a0919f16aad65eafe6f688f98217a7b13f213b0b334b0f22b3e608606364e2d0cf332b44a83a1459d91c4c370557082c66de854073b7be12f6666e83ff49261de44cabb359181d2d84d44dc65cc665589cc454522b18bfb84ad4eb7621c17eae6d9836fa87f51f65db7b4043b05a635eada3b574fd765713e4b44fcb2a80eb2f5a3750aee14122e7cc0d8803c0f81ff5341369f35c786b909b365e54e76ad9d312b462872ea85fa63f53a25b05c87996de28562eb5654c4e89bd39322a9e1c629470219157ac5129430deed6545c2216089b4a2fa2128a9c3d7ab5e776bdff5e3f070d5aee33479d95897db16d02ca58b698de647834f648208c23401dd023c5e2dd9fded3f392abc488f23212f3bea19ec31584eb173b38187417c52397bba7926587e7a2003dc4c355de8918ed8e01bbb5a754647c9df1b1988c9e305dd27b993085183d111ceb331c44e15d3bfcc3af98bebbec2367bb68757aa016823d0be1cc5f926fc2892201ecdc39634507a51e7a0fd9c9d192e149594a04f21ce24ee8c6eed28ce9cc7a5ebffc963bd51e6e9565635a44b2b536aa1e368a9cbc60a997542f158cd375280ad2aa31f5f73de3a957511fcad3d068f76106c015fe2d1e0b193f0afeee56f950d6462e1d4357c607cb4ae470d0871a7ba84b0d758e549b245e200c63a91ed93a406faca04d632cee7498b1b21eba36fc5f52e3e87ea3ff3c65fe2785d94a5c24c118e98a66848d9b9ebf59554d6cd184b2b85231c6fcec158385e8f68cabe35e9e6386c91ad7012c2b13fae56e2be891783c744aaafec37d50937e81372a34a1292cd42aa9eb60ed025d66fea087c96b83dd7443ce1a01e6705f3e0a0fa771b419123ebb0613897a7c23e4914d426bfa3680a275c4a95391d5a07531824e3882af9fd835d18d123cb7fb48e7e6e115d3578b865002c21d8e15f27fb753bf4d06e8ae7f09647f67f90828146bc1023bd7918acdbb36530e28161d972fa16973952621f69de28628a2d9385f0b5f44f5ad20f9f7ba2f277636c24b2690fc954cd79576bf607afc884b9890fc6687ce85c4ecf05f7237c3e552f08529c410c2a8fc56f0e788a406244978a93feae8b1cda90de58cf6d4f15421827b241667c014b5e28ee09caa62b64ba29ff0c18205057124ddfecfdbfa9b411f180710e53827151a8282417e4dcd6d984a88fa136546f112fd7fbc8becd14bddf1da8d2196d712eaa90cb23c594f64398f9b5b211c97dbceda33841ed9a17f869d90372d325393f0bbb20dc0baeab610ca9730dba91cd6fc1af056561c7b21326988fa70e0159a4c18be4da4a21ab2ca064c1a7aace6c0d6f891cae2c6aeb07ec119a50048356a5425a58b0f80e30bae2cc73ff6c2bf7c5bb8c414c4f3213947774bac2b0ef59cfcf52fbeb4fe7f69980e475432099f54069b774a018b8e519762eecf6aad3af25ac6a845826c0a64f9d87ef65d56cbfa2ade2158f532549341ca78e2c3a99882e9b2ccc039c4e081387e5061e7ad24003f029cfe9df8aab3e9bff9f9b4a3af6a1d5b8d733cfee18b4b119ee147e89ce8a53cc5d7e804cbb65506d1574fdf67b3616dc887622d9bd466346b58851a18cbcae5dba757be9bef53bf3c003ddf554a50a6b2bfdc16b4abbd7d6f976102eb5c58542fb98e35f0eb8f5c8e31ed7ecd8c3ce9b9b3c4432cdf349f23d36a368e4548eff480be97df6a2d9bc83c7c0c0c687790b7f688f678b342931b1ee5747b5269d309e907437d258c589407cdb2a7e9cb4420a10c18bb67ac12363a63a12d3d7f9d7fed868d6fc5c8c72a5b8cc1af5abe1ec7515391aaf0c111aa25ae1e51ec9ba247f6cd52554b1b89abf708bbae7806fcae8a66166eaa5469423060e4ac1fa1ca9be3b365dde7a5f0ece29f3c7a78cdb262c69895e8c619760d640a0c5fe18956fb2da156bb5061bbb58d06f2a81234e418d3c1559118fabc3c9f49629f1b729b09f37b54891ef569568ff6004d4e5267158fd3d3d092d5a6f66bed99d471ea69da8c831eaaee5b2a5fc2e9f676f38b4ecb043a807cd0cf1da4e00f0d64dd2fb6b019147044710f23cae62af12d1193856f7f2a942911cd76348117ccfbddd0a123f4482e8781fa3f2924079ee996452a6e991dae4dd7077ffc309a56fca5673cf4fbbc24d98fb29f012b1eee8af6b729e7fe88b010075e9c7caa352481aa6580e702989a7c1631a260f97748061f26f7aabca2a1b3a195a57e70cdb0b65d246a14644ad75d310a0606351021217e99414de2f56a49f1a5d4863916764b0e6682499c8d386475b2813868bb89ce2428222283664c2653795dec7940bb468a1b97fba1cd9b8ef68f541130e29e0bc66cb72fed675660ba9808d41bd4e59806b5a23308b2ac717124b33bc4f789db0bf26339380399d97c8845ea178eefbae22f14f5794e7b674cadabc59ae6d41cd1171a2b46c44ebb838d92fbab9b8369e8931be1f4d25a30350c29c5bc2d56cc587598d1cae0d062bc46f38d3cce622caa061ea7bc20e9b2fcd596e9c20d4a3164243ffbebf73ab08f8a8db1ac6f4eafb0bc37e816f4cd3aa39e1ca9c29661530cfc1b5d8d1ef7f9c4a9c94369fd0eeb830778dd6fe31d3b43034f7e3b4ba8b0e4410afd06a9d6368e2527489d7bc3c8d95f6403e8d611c44fc866284360c985dfaa13ba75de0af62f1b27c4ec0b9633d4ae58975dbc0e7a5862506800f510e0d332504b6b5fb12b355f35533d863320eb6e201c517430862302f5fc7b39d22fc961bf65e914b9d9a701f958e8ce730fcb7432d298e4581d19fb1d24a7e6cd57321ab74f15771b30678302dc55550387917d5cdb98b2e1c68abfd58b4bdeb9c37bba82aee9f9bc6fbcd97473c4313125117dfb0e2065700aa76aa5a6d29ea7741deda52400796a36a7f5c1d36b03bd1bda9cd1a4da4efdbaf4ad8a4a11242e67498e435adcb221de1b3869b757ef38baa802dd12941f30ad0ce0169ff5e385ecb29e28251341810cfbe60873c9728b787908397bc6d6a539edc6d2aa2b9134fa02d909029b98cfc51ffbb1dc707a8c529a49732cb54ba6766738c3b9a9b24dddbafe5d8f389ae94863bd125619d064e019ecdd565e947ad4f2ff2280a5f89e42b17dabbc3b898bf744acef623c1f34744dbaf242bb6efcd0c9252eeb6e34812eec0f65ec7cd8ba6ca21849886520db4474cfd174efde0606069656cebedc15a1a08c7e96b66978e07535ddac989965877813a3e623ac66c088f6e109d7f9ec1f0e0f6be93301bfad91ede9712de98771623293310149a3e7353ac6135a23fcd0db71a11417038fb82eb63ecc55e0691f3e0165ff3e6fead9a31e0c311c9618076e3407e64c1a2c69bcb3cfda5c54d08e97dc03977c5448d609c16dab4ea8fe8129b017f60008963f646a4778dc60dc256f8626e23d74e0f9a4ce4f9797a5eff099c2a4673042c74fb2f82aaef4c013b4588f2396e41e0a5e458b058465d349888a124ff49f1f17db24f5b7fe9942a82c70e1ef18601c7bb215c3b5b1e75244e7eca92e1dffb5c347e372571b7ea6cf53c3d84f964701fb758749b6f412e6df31f0108c7165ee8f2d5298d2029a478ef67f807c086ec592c65494325916d8dde7586a4ecfce7edfb622582daf55512c9444efba710dd3941a1e4801c7ae6ef0d286b111cd949a35603b3d8acdf5c29285d7622e5d7aacac7e47fbac8643c75163c8b428af9a1ee4af3842e9d51f203f12a5096c5cbc8ef64cf3cca414a7726921a357b7938450110fab5937d9d75ba601990974ab69a919a87d38e3c2786649fc343966e7bd947d367ac8aa13462fe7b7b01da258beff15320ea0ce1ec23c1380c8a9fbb30284e24ba534035228468b2998f22967fbe54f964460ed54318d7d8104bef14873fd919e8aad0cfc28c326892d07a72257e216d19550d384f37a362ce967123a43d8847f14e6f13724b09e8f015aafc4abda32a976cc3ac065f6310041c4eb8ba43f3ead1e9ec89aebea598924c0826682aa87184e2004e4069828ed1736e0585b11d073f883a3058bb53c32fca501336c4efc410249fe5286bfc21e6fd89cd722167fc565a2d97263be0d0cafcaa80512ea63dbd425a055c92bdec7caf523495090f61f902b22638532cb7cd863bf4c806fa02c0b1b48e3035f419f779df08014c4d3b15895be147935f0404fb410d6b67259fb51514051db4f7f27d1303b51c680f363fa973e26928a6f0477a1db5f3d5c5d5759819ccaad95baf309fcc0be24501eee4b356f6b5befbd14da3126924bb0f4e83c7f57337010fc939d41267778c501797a09f0738e335f5cf7ff1b9827fea4ee320ee62ad0bac4a4b51609ad5df76965f565b1f1be9a9d75bf93c3bc3e5184d788eb72fc9f7a9aac1696388e2ffbe0fe9e5c70de1753c2a1f78bf091816b97407713cb79c1cb7127995b7414ec7a438c87d59509aee7b45310ba3dc73ead25faeaaea8477e96de5b43acd0c2221c95243361dcd1c1e078a4b164321bc20e244f22446e9ce24711ca74d647004fcd4fc69787694467127d84d19de75a11a9fdfe7c93bc9f2af4ce0e986695e769acb83b8991c1168eebbff6bffa080f75920181494dcbf2ec8649787a902d782e2d3199a4ad82f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1dc4a4cc0ac57eda4e1eae948af76004"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
